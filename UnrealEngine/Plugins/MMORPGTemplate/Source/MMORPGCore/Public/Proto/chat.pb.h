// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chat.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_chat_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_chat_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
#include "base.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_chat_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_chat_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_chat_2eproto;
namespace mmorpg {
class ChannelInfo;
struct ChannelInfoDefaultTypeInternal;
extern ChannelInfoDefaultTypeInternal _ChannelInfo_default_instance_;
class ChannelJoinRequest;
struct ChannelJoinRequestDefaultTypeInternal;
extern ChannelJoinRequestDefaultTypeInternal _ChannelJoinRequest_default_instance_;
class ChannelJoinResponse;
struct ChannelJoinResponseDefaultTypeInternal;
extern ChannelJoinResponseDefaultTypeInternal _ChannelJoinResponse_default_instance_;
class ChannelLeaveRequest;
struct ChannelLeaveRequestDefaultTypeInternal;
extern ChannelLeaveRequestDefaultTypeInternal _ChannelLeaveRequest_default_instance_;
class ChannelLeaveResponse;
struct ChannelLeaveResponseDefaultTypeInternal;
extern ChannelLeaveResponseDefaultTypeInternal _ChannelLeaveResponse_default_instance_;
class ChannelListRequest;
struct ChannelListRequestDefaultTypeInternal;
extern ChannelListRequestDefaultTypeInternal _ChannelListRequest_default_instance_;
class ChannelListResponse;
struct ChannelListResponseDefaultTypeInternal;
extern ChannelListResponseDefaultTypeInternal _ChannelListResponse_default_instance_;
class ChannelMember;
struct ChannelMemberDefaultTypeInternal;
extern ChannelMemberDefaultTypeInternal _ChannelMember_default_instance_;
class ChatCommand;
struct ChatCommandDefaultTypeInternal;
extern ChatCommandDefaultTypeInternal _ChatCommand_default_instance_;
class ChatCommandResponse;
struct ChatCommandResponseDefaultTypeInternal;
extern ChatCommandResponseDefaultTypeInternal _ChatCommandResponse_default_instance_;
class ChatHistoryRequest;
struct ChatHistoryRequestDefaultTypeInternal;
extern ChatHistoryRequestDefaultTypeInternal _ChatHistoryRequest_default_instance_;
class ChatHistoryResponse;
struct ChatHistoryResponseDefaultTypeInternal;
extern ChatHistoryResponseDefaultTypeInternal _ChatHistoryResponse_default_instance_;
class ChatMessage;
struct ChatMessageDefaultTypeInternal;
extern ChatMessageDefaultTypeInternal _ChatMessage_default_instance_;
class ReportChatMessage;
struct ReportChatMessageDefaultTypeInternal;
extern ReportChatMessageDefaultTypeInternal _ReportChatMessage_default_instance_;
class ReportChatResponse;
struct ReportChatResponseDefaultTypeInternal;
extern ReportChatResponseDefaultTypeInternal _ReportChatResponse_default_instance_;
class WhisperMessage;
struct WhisperMessageDefaultTypeInternal;
extern WhisperMessageDefaultTypeInternal _WhisperMessage_default_instance_;
}  // namespace mmorpg
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace mmorpg {
enum ChatChannel : int {
  CHAT_CHANNEL_UNSPECIFIED = 0,
  CHAT_CHANNEL_GLOBAL = 1,
  CHAT_CHANNEL_ZONE = 2,
  CHAT_CHANNEL_LOCAL = 3,
  CHAT_CHANNEL_PARTY = 4,
  CHAT_CHANNEL_GUILD = 5,
  CHAT_CHANNEL_RAID = 6,
  CHAT_CHANNEL_TRADE = 7,
  CHAT_CHANNEL_SYSTEM = 8,
  CHAT_CHANNEL_WHISPER = 9,
  CHAT_CHANNEL_CUSTOM = 10,
  ChatChannel_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ChatChannel_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ChatChannel_IsValid(int value);
extern const uint32_t ChatChannel_internal_data_[];
constexpr ChatChannel ChatChannel_MIN = static_cast<ChatChannel>(0);
constexpr ChatChannel ChatChannel_MAX = static_cast<ChatChannel>(10);
constexpr int ChatChannel_ARRAYSIZE = 10 + 1;
const ::google::protobuf::EnumDescriptor*
ChatChannel_descriptor();
template <typename T>
const std::string& ChatChannel_Name(T value) {
  static_assert(std::is_same<T, ChatChannel>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ChatChannel_Name().");
  return ChatChannel_Name(static_cast<ChatChannel>(value));
}
template <>
inline const std::string& ChatChannel_Name(ChatChannel value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChatChannel_descriptor,
                                                 0, 10>(
      static_cast<int>(value));
}
inline bool ChatChannel_Parse(absl::string_view name, ChatChannel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChatChannel>(
      ChatChannel_descriptor(), name, value);
}
enum ChatMessageType : int {
  CHAT_MESSAGE_TYPE_UNSPECIFIED = 0,
  CHAT_MESSAGE_TYPE_PLAYER = 1,
  CHAT_MESSAGE_TYPE_SYSTEM = 2,
  CHAT_MESSAGE_TYPE_ANNOUNCEMENT = 3,
  CHAT_MESSAGE_TYPE_WARNING = 4,
  CHAT_MESSAGE_TYPE_ERROR = 5,
  CHAT_MESSAGE_TYPE_EMOTE = 6,
  CHAT_MESSAGE_TYPE_ACHIEVEMENT = 7,
  CHAT_MESSAGE_TYPE_LOOT = 8,
  ChatMessageType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ChatMessageType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ChatMessageType_IsValid(int value);
extern const uint32_t ChatMessageType_internal_data_[];
constexpr ChatMessageType ChatMessageType_MIN = static_cast<ChatMessageType>(0);
constexpr ChatMessageType ChatMessageType_MAX = static_cast<ChatMessageType>(8);
constexpr int ChatMessageType_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
ChatMessageType_descriptor();
template <typename T>
const std::string& ChatMessageType_Name(T value) {
  static_assert(std::is_same<T, ChatMessageType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ChatMessageType_Name().");
  return ChatMessageType_Name(static_cast<ChatMessageType>(value));
}
template <>
inline const std::string& ChatMessageType_Name(ChatMessageType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChatMessageType_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool ChatMessageType_Parse(absl::string_view name, ChatMessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChatMessageType>(
      ChatMessageType_descriptor(), name, value);
}
enum ChannelRole : int {
  CHANNEL_ROLE_UNSPECIFIED = 0,
  CHANNEL_ROLE_MEMBER = 1,
  CHANNEL_ROLE_MODERATOR = 2,
  CHANNEL_ROLE_OWNER = 3,
  ChannelRole_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ChannelRole_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ChannelRole_IsValid(int value);
extern const uint32_t ChannelRole_internal_data_[];
constexpr ChannelRole ChannelRole_MIN = static_cast<ChannelRole>(0);
constexpr ChannelRole ChannelRole_MAX = static_cast<ChannelRole>(3);
constexpr int ChannelRole_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ChannelRole_descriptor();
template <typename T>
const std::string& ChannelRole_Name(T value) {
  static_assert(std::is_same<T, ChannelRole>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ChannelRole_Name().");
  return ChannelRole_Name(static_cast<ChannelRole>(value));
}
template <>
inline const std::string& ChannelRole_Name(ChannelRole value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChannelRole_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ChannelRole_Parse(absl::string_view name, ChannelRole* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChannelRole>(
      ChannelRole_descriptor(), name, value);
}
enum ChannelListType : int {
  CHANNEL_LIST_TYPE_UNSPECIFIED = 0,
  CHANNEL_LIST_TYPE_JOINED = 1,
  CHANNEL_LIST_TYPE_AVAILABLE = 2,
  CHANNEL_LIST_TYPE_ALL = 3,
  ChannelListType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ChannelListType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ChannelListType_IsValid(int value);
extern const uint32_t ChannelListType_internal_data_[];
constexpr ChannelListType ChannelListType_MIN = static_cast<ChannelListType>(0);
constexpr ChannelListType ChannelListType_MAX = static_cast<ChannelListType>(3);
constexpr int ChannelListType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
ChannelListType_descriptor();
template <typename T>
const std::string& ChannelListType_Name(T value) {
  static_assert(std::is_same<T, ChannelListType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ChannelListType_Name().");
  return ChannelListType_Name(static_cast<ChannelListType>(value));
}
template <>
inline const std::string& ChannelListType_Name(ChannelListType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChannelListType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool ChannelListType_Parse(absl::string_view name, ChannelListType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChannelListType>(
      ChannelListType_descriptor(), name, value);
}
enum ChatCommandType : int {
  CHAT_COMMAND_TYPE_UNSPECIFIED = 0,
  CHAT_COMMAND_TYPE_MUTE = 1,
  CHAT_COMMAND_TYPE_UNMUTE = 2,
  CHAT_COMMAND_TYPE_KICK = 3,
  CHAT_COMMAND_TYPE_BAN = 4,
  CHAT_COMMAND_TYPE_UNBAN = 5,
  CHAT_COMMAND_TYPE_PROMOTE = 6,
  CHAT_COMMAND_TYPE_DEMOTE = 7,
  CHAT_COMMAND_TYPE_CLEAR = 8,
  ChatCommandType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ChatCommandType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ChatCommandType_IsValid(int value);
extern const uint32_t ChatCommandType_internal_data_[];
constexpr ChatCommandType ChatCommandType_MIN = static_cast<ChatCommandType>(0);
constexpr ChatCommandType ChatCommandType_MAX = static_cast<ChatCommandType>(8);
constexpr int ChatCommandType_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
ChatCommandType_descriptor();
template <typename T>
const std::string& ChatCommandType_Name(T value) {
  static_assert(std::is_same<T, ChatCommandType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ChatCommandType_Name().");
  return ChatCommandType_Name(static_cast<ChatCommandType>(value));
}
template <>
inline const std::string& ChatCommandType_Name(ChatCommandType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ChatCommandType_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool ChatCommandType_Parse(absl::string_view name, ChatCommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChatCommandType>(
      ChatCommandType_descriptor(), name, value);
}
enum ReportReason : int {
  REPORT_REASON_UNSPECIFIED = 0,
  REPORT_REASON_SPAM = 1,
  REPORT_REASON_HARASSMENT = 2,
  REPORT_REASON_HATE_SPEECH = 3,
  REPORT_REASON_INAPPROPRIATE = 4,
  REPORT_REASON_SCAM = 5,
  REPORT_REASON_ADVERTISING = 6,
  REPORT_REASON_OTHER = 7,
  ReportReason_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ReportReason_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ReportReason_IsValid(int value);
extern const uint32_t ReportReason_internal_data_[];
constexpr ReportReason ReportReason_MIN = static_cast<ReportReason>(0);
constexpr ReportReason ReportReason_MAX = static_cast<ReportReason>(7);
constexpr int ReportReason_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
ReportReason_descriptor();
template <typename T>
const std::string& ReportReason_Name(T value) {
  static_assert(std::is_same<T, ReportReason>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ReportReason_Name().");
  return ReportReason_Name(static_cast<ReportReason>(value));
}
template <>
inline const std::string& ReportReason_Name(ReportReason value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ReportReason_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool ReportReason_Parse(absl::string_view name, ReportReason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReportReason>(
      ReportReason_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class ReportChatResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.ReportChatResponse) */ {
 public:
  inline ReportChatResponse() : ReportChatResponse(nullptr) {}
  ~ReportChatResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ReportChatResponse(::google::protobuf::internal::ConstantInitialized);

  inline ReportChatResponse(const ReportChatResponse& from)
      : ReportChatResponse(nullptr, from) {}
  ReportChatResponse(ReportChatResponse&& from) noexcept
    : ReportChatResponse() {
    *this = ::std::move(from);
  }

  inline ReportChatResponse& operator=(const ReportChatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportChatResponse& operator=(ReportChatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportChatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportChatResponse* internal_default_instance() {
    return reinterpret_cast<const ReportChatResponse*>(
               &_ReportChatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ReportChatResponse& a, ReportChatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportChatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportChatResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportChatResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReportChatResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReportChatResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ReportChatResponse& from) {
    ReportChatResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReportChatResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.ReportChatResponse";
  }
  protected:
  explicit ReportChatResponse(::google::protobuf::Arena* arena);
  ReportChatResponse(::google::protobuf::Arena* arena, const ReportChatResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReportIdFieldNumber = 2,
    kMessageFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // string report_id = 2;
  void clear_report_id() ;
  const std::string& report_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_report_id(Arg_&& arg, Args_... args);
  std::string* mutable_report_id();
  PROTOBUF_NODISCARD std::string* release_report_id();
  void set_allocated_report_id(std::string* value);

  private:
  const std::string& _internal_report_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_report_id(
      const std::string& value);
  std::string* _internal_mutable_report_id();

  public:
  // string message = 3;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.ReportChatResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr report_id_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};// -------------------------------------------------------------------

class ReportChatMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.ReportChatMessage) */ {
 public:
  inline ReportChatMessage() : ReportChatMessage(nullptr) {}
  ~ReportChatMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ReportChatMessage(::google::protobuf::internal::ConstantInitialized);

  inline ReportChatMessage(const ReportChatMessage& from)
      : ReportChatMessage(nullptr, from) {}
  ReportChatMessage(ReportChatMessage&& from) noexcept
    : ReportChatMessage() {
    *this = ::std::move(from);
  }

  inline ReportChatMessage& operator=(const ReportChatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportChatMessage& operator=(ReportChatMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportChatMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportChatMessage* internal_default_instance() {
    return reinterpret_cast<const ReportChatMessage*>(
               &_ReportChatMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ReportChatMessage& a, ReportChatMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportChatMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportChatMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportChatMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReportChatMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReportChatMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ReportChatMessage& from) {
    ReportChatMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReportChatMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.ReportChatMessage";
  }
  protected:
  explicit ReportChatMessage(::google::protobuf::Arena* arena);
  ReportChatMessage(::google::protobuf::Arena* arena, const ReportChatMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReporterIdFieldNumber = 1,
    kMessageIdFieldNumber = 2,
    kAdditionalInfoFieldNumber = 4,
    kReasonFieldNumber = 3,
  };
  // string reporter_id = 1;
  void clear_reporter_id() ;
  const std::string& reporter_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reporter_id(Arg_&& arg, Args_... args);
  std::string* mutable_reporter_id();
  PROTOBUF_NODISCARD std::string* release_reporter_id();
  void set_allocated_reporter_id(std::string* value);

  private:
  const std::string& _internal_reporter_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reporter_id(
      const std::string& value);
  std::string* _internal_mutable_reporter_id();

  public:
  // string message_id = 2;
  void clear_message_id() ;
  const std::string& message_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message_id(Arg_&& arg, Args_... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* value);

  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(
      const std::string& value);
  std::string* _internal_mutable_message_id();

  public:
  // string additional_info = 4;
  void clear_additional_info() ;
  const std::string& additional_info() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_additional_info(Arg_&& arg, Args_... args);
  std::string* mutable_additional_info();
  PROTOBUF_NODISCARD std::string* release_additional_info();
  void set_allocated_additional_info(std::string* value);

  private:
  const std::string& _internal_additional_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_additional_info(
      const std::string& value);
  std::string* _internal_mutable_additional_info();

  public:
  // .mmorpg.ReportReason reason = 3;
  void clear_reason() ;
  ::mmorpg::ReportReason reason() const;
  void set_reason(::mmorpg::ReportReason value);

  private:
  ::mmorpg::ReportReason _internal_reason() const;
  void _internal_set_reason(::mmorpg::ReportReason value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.ReportChatMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      69, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr reporter_id_;
    ::google::protobuf::internal::ArenaStringPtr message_id_;
    ::google::protobuf::internal::ArenaStringPtr additional_info_;
    int reason_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};// -------------------------------------------------------------------

class ChatHistoryRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.ChatHistoryRequest) */ {
 public:
  inline ChatHistoryRequest() : ChatHistoryRequest(nullptr) {}
  ~ChatHistoryRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChatHistoryRequest(::google::protobuf::internal::ConstantInitialized);

  inline ChatHistoryRequest(const ChatHistoryRequest& from)
      : ChatHistoryRequest(nullptr, from) {}
  ChatHistoryRequest(ChatHistoryRequest&& from) noexcept
    : ChatHistoryRequest() {
    *this = ::std::move(from);
  }

  inline ChatHistoryRequest& operator=(const ChatHistoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatHistoryRequest& operator=(ChatHistoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatHistoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatHistoryRequest* internal_default_instance() {
    return reinterpret_cast<const ChatHistoryRequest*>(
               &_ChatHistoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ChatHistoryRequest& a, ChatHistoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatHistoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatHistoryRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatHistoryRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatHistoryRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChatHistoryRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChatHistoryRequest& from) {
    ChatHistoryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChatHistoryRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.ChatHistoryRequest";
  }
  protected:
  explicit ChatHistoryRequest(::google::protobuf::Arena* arena);
  ChatHistoryRequest(::google::protobuf::Arena* arena, const ChatHistoryRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kChannelIdFieldNumber = 3,
    kBeforeMessageIdFieldNumber = 5,
    kChannelFieldNumber = 2,
    kMessageCountFieldNumber = 4,
  };
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // string channel_id = 3;
  void clear_channel_id() ;
  const std::string& channel_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel_id(Arg_&& arg, Args_... args);
  std::string* mutable_channel_id();
  PROTOBUF_NODISCARD std::string* release_channel_id();
  void set_allocated_channel_id(std::string* value);

  private:
  const std::string& _internal_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_id(
      const std::string& value);
  std::string* _internal_mutable_channel_id();

  public:
  // string before_message_id = 5;
  void clear_before_message_id() ;
  const std::string& before_message_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_before_message_id(Arg_&& arg, Args_... args);
  std::string* mutable_before_message_id();
  PROTOBUF_NODISCARD std::string* release_before_message_id();
  void set_allocated_before_message_id(std::string* value);

  private:
  const std::string& _internal_before_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_before_message_id(
      const std::string& value);
  std::string* _internal_mutable_before_message_id();

  public:
  // .mmorpg.ChatChannel channel = 2;
  void clear_channel() ;
  ::mmorpg::ChatChannel channel() const;
  void set_channel(::mmorpg::ChatChannel value);

  private:
  ::mmorpg::ChatChannel _internal_channel() const;
  void _internal_set_channel(::mmorpg::ChatChannel value);

  public:
  // int32 message_count = 4;
  void clear_message_count() ;
  ::int32_t message_count() const;
  void set_message_count(::int32_t value);

  private:
  ::int32_t _internal_message_count() const;
  void _internal_set_message_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.ChatHistoryRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      70, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::google::protobuf::internal::ArenaStringPtr channel_id_;
    ::google::protobuf::internal::ArenaStringPtr before_message_id_;
    int channel_;
    ::int32_t message_count_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};// -------------------------------------------------------------------

class ChatCommandResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.ChatCommandResponse) */ {
 public:
  inline ChatCommandResponse() : ChatCommandResponse(nullptr) {}
  ~ChatCommandResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChatCommandResponse(::google::protobuf::internal::ConstantInitialized);

  inline ChatCommandResponse(const ChatCommandResponse& from)
      : ChatCommandResponse(nullptr, from) {}
  ChatCommandResponse(ChatCommandResponse&& from) noexcept
    : ChatCommandResponse() {
    *this = ::std::move(from);
  }

  inline ChatCommandResponse& operator=(const ChatCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatCommandResponse& operator=(ChatCommandResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatCommandResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatCommandResponse* internal_default_instance() {
    return reinterpret_cast<const ChatCommandResponse*>(
               &_ChatCommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ChatCommandResponse& a, ChatCommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatCommandResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatCommandResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatCommandResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatCommandResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChatCommandResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChatCommandResponse& from) {
    ChatCommandResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChatCommandResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.ChatCommandResponse";
  }
  protected:
  explicit ChatCommandResponse(::google::protobuf::Arena* arena);
  ChatCommandResponse(::google::protobuf::Arena* arena, const ChatCommandResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
    kErrorCodeFieldNumber = 3,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // .mmorpg.ErrorCode error_code = 3;
  void clear_error_code() ;
  ::mmorpg::ErrorCode error_code() const;
  void set_error_code(::mmorpg::ErrorCode value);

  private:
  ::mmorpg::ErrorCode _internal_error_code() const;
  void _internal_set_error_code(::mmorpg::ErrorCode value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.ChatCommandResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool success_;
    int error_code_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};// -------------------------------------------------------------------

class ChatCommand final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.ChatCommand) */ {
 public:
  inline ChatCommand() : ChatCommand(nullptr) {}
  ~ChatCommand() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChatCommand(::google::protobuf::internal::ConstantInitialized);

  inline ChatCommand(const ChatCommand& from)
      : ChatCommand(nullptr, from) {}
  ChatCommand(ChatCommand&& from) noexcept
    : ChatCommand() {
    *this = ::std::move(from);
  }

  inline ChatCommand& operator=(const ChatCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatCommand& operator=(ChatCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatCommand* internal_default_instance() {
    return reinterpret_cast<const ChatCommand*>(
               &_ChatCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ChatCommand& a, ChatCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatCommand* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatCommand* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatCommand>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChatCommand& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChatCommand& from) {
    ChatCommand::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChatCommand* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.ChatCommand";
  }
  protected:
  explicit ChatCommand(::google::protobuf::Arena* arena);
  ChatCommand(::google::protobuf::Arena* arena, const ChatCommand& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIssuerIdFieldNumber = 1,
    kTargetPlayerIdFieldNumber = 3,
    kChannelIdFieldNumber = 5,
    kReasonFieldNumber = 7,
    kCommandTypeFieldNumber = 2,
    kChannelFieldNumber = 4,
    kDurationMinutesFieldNumber = 6,
  };
  // string issuer_id = 1;
  void clear_issuer_id() ;
  const std::string& issuer_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_issuer_id(Arg_&& arg, Args_... args);
  std::string* mutable_issuer_id();
  PROTOBUF_NODISCARD std::string* release_issuer_id();
  void set_allocated_issuer_id(std::string* value);

  private:
  const std::string& _internal_issuer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuer_id(
      const std::string& value);
  std::string* _internal_mutable_issuer_id();

  public:
  // string target_player_id = 3;
  void clear_target_player_id() ;
  const std::string& target_player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_target_player_id();
  PROTOBUF_NODISCARD std::string* release_target_player_id();
  void set_allocated_target_player_id(std::string* value);

  private:
  const std::string& _internal_target_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_player_id(
      const std::string& value);
  std::string* _internal_mutable_target_player_id();

  public:
  // string channel_id = 5;
  void clear_channel_id() ;
  const std::string& channel_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel_id(Arg_&& arg, Args_... args);
  std::string* mutable_channel_id();
  PROTOBUF_NODISCARD std::string* release_channel_id();
  void set_allocated_channel_id(std::string* value);

  private:
  const std::string& _internal_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_id(
      const std::string& value);
  std::string* _internal_mutable_channel_id();

  public:
  // string reason = 7;
  void clear_reason() ;
  const std::string& reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* value);

  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(
      const std::string& value);
  std::string* _internal_mutable_reason();

  public:
  // .mmorpg.ChatCommandType command_type = 2;
  void clear_command_type() ;
  ::mmorpg::ChatCommandType command_type() const;
  void set_command_type(::mmorpg::ChatCommandType value);

  private:
  ::mmorpg::ChatCommandType _internal_command_type() const;
  void _internal_set_command_type(::mmorpg::ChatCommandType value);

  public:
  // .mmorpg.ChatChannel channel = 4;
  void clear_channel() ;
  ::mmorpg::ChatChannel channel() const;
  void set_channel(::mmorpg::ChatChannel value);

  private:
  ::mmorpg::ChatChannel _internal_channel() const;
  void _internal_set_channel(::mmorpg::ChatChannel value);

  public:
  // int32 duration_minutes = 6;
  void clear_duration_minutes() ;
  ::int32_t duration_minutes() const;
  void set_duration_minutes(::int32_t value);

  private:
  ::int32_t _internal_duration_minutes() const;
  void _internal_set_duration_minutes(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.ChatCommand)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      68, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr issuer_id_;
    ::google::protobuf::internal::ArenaStringPtr target_player_id_;
    ::google::protobuf::internal::ArenaStringPtr channel_id_;
    ::google::protobuf::internal::ArenaStringPtr reason_;
    int command_type_;
    int channel_;
    ::int32_t duration_minutes_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};// -------------------------------------------------------------------

class ChannelListRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.ChannelListRequest) */ {
 public:
  inline ChannelListRequest() : ChannelListRequest(nullptr) {}
  ~ChannelListRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelListRequest(::google::protobuf::internal::ConstantInitialized);

  inline ChannelListRequest(const ChannelListRequest& from)
      : ChannelListRequest(nullptr, from) {}
  ChannelListRequest(ChannelListRequest&& from) noexcept
    : ChannelListRequest() {
    *this = ::std::move(from);
  }

  inline ChannelListRequest& operator=(const ChannelListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelListRequest& operator=(ChannelListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelListRequest* internal_default_instance() {
    return reinterpret_cast<const ChannelListRequest*>(
               &_ChannelListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ChannelListRequest& a, ChannelListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelListRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelListRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelListRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelListRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChannelListRequest& from) {
    ChannelListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelListRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.ChannelListRequest";
  }
  protected:
  explicit ChannelListRequest(::google::protobuf::Arena* arena);
  ChannelListRequest(::google::protobuf::Arena* arena, const ChannelListRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kListTypeFieldNumber = 2,
  };
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // .mmorpg.ChannelListType list_type = 2;
  void clear_list_type() ;
  ::mmorpg::ChannelListType list_type() const;
  void set_list_type(::mmorpg::ChannelListType value);

  private:
  ::mmorpg::ChannelListType _internal_list_type() const;
  void _internal_set_list_type(::mmorpg::ChannelListType value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.ChannelListRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      43, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    int list_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};// -------------------------------------------------------------------

class ChannelLeaveResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.ChannelLeaveResponse) */ {
 public:
  inline ChannelLeaveResponse() : ChannelLeaveResponse(nullptr) {}
  ~ChannelLeaveResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelLeaveResponse(::google::protobuf::internal::ConstantInitialized);

  inline ChannelLeaveResponse(const ChannelLeaveResponse& from)
      : ChannelLeaveResponse(nullptr, from) {}
  ChannelLeaveResponse(ChannelLeaveResponse&& from) noexcept
    : ChannelLeaveResponse() {
    *this = ::std::move(from);
  }

  inline ChannelLeaveResponse& operator=(const ChannelLeaveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelLeaveResponse& operator=(ChannelLeaveResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelLeaveResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelLeaveResponse* internal_default_instance() {
    return reinterpret_cast<const ChannelLeaveResponse*>(
               &_ChannelLeaveResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ChannelLeaveResponse& a, ChannelLeaveResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelLeaveResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelLeaveResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelLeaveResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelLeaveResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelLeaveResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChannelLeaveResponse& from) {
    ChannelLeaveResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelLeaveResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.ChannelLeaveResponse";
  }
  protected:
  explicit ChannelLeaveResponse(::google::protobuf::Arena* arena);
  ChannelLeaveResponse(::google::protobuf::Arena* arena, const ChannelLeaveResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.ChannelLeaveResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      43, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};// -------------------------------------------------------------------

class ChannelLeaveRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.ChannelLeaveRequest) */ {
 public:
  inline ChannelLeaveRequest() : ChannelLeaveRequest(nullptr) {}
  ~ChannelLeaveRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelLeaveRequest(::google::protobuf::internal::ConstantInitialized);

  inline ChannelLeaveRequest(const ChannelLeaveRequest& from)
      : ChannelLeaveRequest(nullptr, from) {}
  ChannelLeaveRequest(ChannelLeaveRequest&& from) noexcept
    : ChannelLeaveRequest() {
    *this = ::std::move(from);
  }

  inline ChannelLeaveRequest& operator=(const ChannelLeaveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelLeaveRequest& operator=(ChannelLeaveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelLeaveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelLeaveRequest* internal_default_instance() {
    return reinterpret_cast<const ChannelLeaveRequest*>(
               &_ChannelLeaveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ChannelLeaveRequest& a, ChannelLeaveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelLeaveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelLeaveRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelLeaveRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelLeaveRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelLeaveRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChannelLeaveRequest& from) {
    ChannelLeaveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelLeaveRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.ChannelLeaveRequest";
  }
  protected:
  explicit ChannelLeaveRequest(::google::protobuf::Arena* arena);
  ChannelLeaveRequest(::google::protobuf::Arena* arena, const ChannelLeaveRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kChannelIdFieldNumber = 3,
    kChannelFieldNumber = 2,
  };
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // string channel_id = 3;
  void clear_channel_id() ;
  const std::string& channel_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel_id(Arg_&& arg, Args_... args);
  std::string* mutable_channel_id();
  PROTOBUF_NODISCARD std::string* release_channel_id();
  void set_allocated_channel_id(std::string* value);

  private:
  const std::string& _internal_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_id(
      const std::string& value);
  std::string* _internal_mutable_channel_id();

  public:
  // .mmorpg.ChatChannel channel = 2;
  void clear_channel() ;
  ::mmorpg::ChatChannel channel() const;
  void set_channel(::mmorpg::ChatChannel value);

  private:
  ::mmorpg::ChatChannel _internal_channel() const;
  void _internal_set_channel(::mmorpg::ChatChannel value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.ChannelLeaveRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      54, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::google::protobuf::internal::ArenaStringPtr channel_id_;
    int channel_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};// -------------------------------------------------------------------

class ChannelJoinRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.ChannelJoinRequest) */ {
 public:
  inline ChannelJoinRequest() : ChannelJoinRequest(nullptr) {}
  ~ChannelJoinRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelJoinRequest(::google::protobuf::internal::ConstantInitialized);

  inline ChannelJoinRequest(const ChannelJoinRequest& from)
      : ChannelJoinRequest(nullptr, from) {}
  ChannelJoinRequest(ChannelJoinRequest&& from) noexcept
    : ChannelJoinRequest() {
    *this = ::std::move(from);
  }

  inline ChannelJoinRequest& operator=(const ChannelJoinRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelJoinRequest& operator=(ChannelJoinRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelJoinRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelJoinRequest* internal_default_instance() {
    return reinterpret_cast<const ChannelJoinRequest*>(
               &_ChannelJoinRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ChannelJoinRequest& a, ChannelJoinRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelJoinRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelJoinRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelJoinRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelJoinRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelJoinRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChannelJoinRequest& from) {
    ChannelJoinRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelJoinRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.ChannelJoinRequest";
  }
  protected:
  explicit ChannelJoinRequest(::google::protobuf::Arena* arena);
  ChannelJoinRequest(::google::protobuf::Arena* arena, const ChannelJoinRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kChannelIdFieldNumber = 3,
    kPasswordFieldNumber = 4,
    kChannelFieldNumber = 2,
  };
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // string channel_id = 3;
  void clear_channel_id() ;
  const std::string& channel_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel_id(Arg_&& arg, Args_... args);
  std::string* mutable_channel_id();
  PROTOBUF_NODISCARD std::string* release_channel_id();
  void set_allocated_channel_id(std::string* value);

  private:
  const std::string& _internal_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_id(
      const std::string& value);
  std::string* _internal_mutable_channel_id();

  public:
  // string password = 4;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* value);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // .mmorpg.ChatChannel channel = 2;
  void clear_channel() ;
  ::mmorpg::ChatChannel channel() const;
  void set_channel(::mmorpg::ChatChannel value);

  private:
  ::mmorpg::ChatChannel _internal_channel() const;
  void _internal_set_channel(::mmorpg::ChatChannel value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.ChannelJoinRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::google::protobuf::internal::ArenaStringPtr channel_id_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    int channel_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};// -------------------------------------------------------------------

class ChannelInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.ChannelInfo) */ {
 public:
  inline ChannelInfo() : ChannelInfo(nullptr) {}
  ~ChannelInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelInfo(::google::protobuf::internal::ConstantInitialized);

  inline ChannelInfo(const ChannelInfo& from)
      : ChannelInfo(nullptr, from) {}
  ChannelInfo(ChannelInfo&& from) noexcept
    : ChannelInfo() {
    *this = ::std::move(from);
  }

  inline ChannelInfo& operator=(const ChannelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelInfo& operator=(ChannelInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelInfo* internal_default_instance() {
    return reinterpret_cast<const ChannelInfo*>(
               &_ChannelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ChannelInfo& a, ChannelInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChannelInfo& from) {
    ChannelInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.ChannelInfo";
  }
  protected:
  explicit ChannelInfo(::google::protobuf::Arena* arena);
  ChannelInfo(::google::protobuf::Arena* arena, const ChannelInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelIdFieldNumber = 2,
    kChannelNameFieldNumber = 3,
    kOwnerIdFieldNumber = 8,
    kDescriptionFieldNumber = 9,
    kChannelTypeFieldNumber = 1,
    kMemberCountFieldNumber = 4,
    kIsJoinedFieldNumber = 5,
    kIsPasswordProtectedFieldNumber = 6,
    kIsModeratedFieldNumber = 7,
  };
  // string channel_id = 2;
  void clear_channel_id() ;
  const std::string& channel_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel_id(Arg_&& arg, Args_... args);
  std::string* mutable_channel_id();
  PROTOBUF_NODISCARD std::string* release_channel_id();
  void set_allocated_channel_id(std::string* value);

  private:
  const std::string& _internal_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_id(
      const std::string& value);
  std::string* _internal_mutable_channel_id();

  public:
  // string channel_name = 3;
  void clear_channel_name() ;
  const std::string& channel_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel_name(Arg_&& arg, Args_... args);
  std::string* mutable_channel_name();
  PROTOBUF_NODISCARD std::string* release_channel_name();
  void set_allocated_channel_name(std::string* value);

  private:
  const std::string& _internal_channel_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_name(
      const std::string& value);
  std::string* _internal_mutable_channel_name();

  public:
  // string owner_id = 8;
  void clear_owner_id() ;
  const std::string& owner_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_owner_id(Arg_&& arg, Args_... args);
  std::string* mutable_owner_id();
  PROTOBUF_NODISCARD std::string* release_owner_id();
  void set_allocated_owner_id(std::string* value);

  private:
  const std::string& _internal_owner_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner_id(
      const std::string& value);
  std::string* _internal_mutable_owner_id();

  public:
  // string description = 9;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // .mmorpg.ChatChannel channel_type = 1;
  void clear_channel_type() ;
  ::mmorpg::ChatChannel channel_type() const;
  void set_channel_type(::mmorpg::ChatChannel value);

  private:
  ::mmorpg::ChatChannel _internal_channel_type() const;
  void _internal_set_channel_type(::mmorpg::ChatChannel value);

  public:
  // int32 member_count = 4;
  void clear_member_count() ;
  ::int32_t member_count() const;
  void set_member_count(::int32_t value);

  private:
  ::int32_t _internal_member_count() const;
  void _internal_set_member_count(::int32_t value);

  public:
  // bool is_joined = 5;
  void clear_is_joined() ;
  bool is_joined() const;
  void set_is_joined(bool value);

  private:
  bool _internal_is_joined() const;
  void _internal_set_is_joined(bool value);

  public:
  // bool is_password_protected = 6;
  void clear_is_password_protected() ;
  bool is_password_protected() const;
  void set_is_password_protected(bool value);

  private:
  bool _internal_is_password_protected() const;
  void _internal_set_is_password_protected(bool value);

  public:
  // bool is_moderated = 7;
  void clear_is_moderated() ;
  bool is_moderated() const;
  void set_is_moderated(bool value);

  private:
  bool _internal_is_moderated() const;
  void _internal_set_is_moderated(bool value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.ChannelInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 0,
      76, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr channel_id_;
    ::google::protobuf::internal::ArenaStringPtr channel_name_;
    ::google::protobuf::internal::ArenaStringPtr owner_id_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    int channel_type_;
    ::int32_t member_count_;
    bool is_joined_;
    bool is_password_protected_;
    bool is_moderated_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};// -------------------------------------------------------------------

class WhisperMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.WhisperMessage) */ {
 public:
  inline WhisperMessage() : WhisperMessage(nullptr) {}
  ~WhisperMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WhisperMessage(::google::protobuf::internal::ConstantInitialized);

  inline WhisperMessage(const WhisperMessage& from)
      : WhisperMessage(nullptr, from) {}
  WhisperMessage(WhisperMessage&& from) noexcept
    : WhisperMessage() {
    *this = ::std::move(from);
  }

  inline WhisperMessage& operator=(const WhisperMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline WhisperMessage& operator=(WhisperMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WhisperMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const WhisperMessage* internal_default_instance() {
    return reinterpret_cast<const WhisperMessage*>(
               &_WhisperMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(WhisperMessage& a, WhisperMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(WhisperMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WhisperMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WhisperMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WhisperMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WhisperMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WhisperMessage& from) {
    WhisperMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WhisperMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.WhisperMessage";
  }
  protected:
  explicit WhisperMessage(::google::protobuf::Arena* arena);
  WhisperMessage(::google::protobuf::Arena* arena, const WhisperMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderIdFieldNumber = 1,
    kSenderNameFieldNumber = 2,
    kRecipientIdFieldNumber = 3,
    kRecipientNameFieldNumber = 4,
    kMessageFieldNumber = 5,
    kTimestampFieldNumber = 6,
  };
  // string sender_id = 1;
  void clear_sender_id() ;
  const std::string& sender_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender_id(Arg_&& arg, Args_... args);
  std::string* mutable_sender_id();
  PROTOBUF_NODISCARD std::string* release_sender_id();
  void set_allocated_sender_id(std::string* value);

  private:
  const std::string& _internal_sender_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_id(
      const std::string& value);
  std::string* _internal_mutable_sender_id();

  public:
  // string sender_name = 2;
  void clear_sender_name() ;
  const std::string& sender_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender_name(Arg_&& arg, Args_... args);
  std::string* mutable_sender_name();
  PROTOBUF_NODISCARD std::string* release_sender_name();
  void set_allocated_sender_name(std::string* value);

  private:
  const std::string& _internal_sender_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_name(
      const std::string& value);
  std::string* _internal_mutable_sender_name();

  public:
  // string recipient_id = 3;
  void clear_recipient_id() ;
  const std::string& recipient_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_recipient_id(Arg_&& arg, Args_... args);
  std::string* mutable_recipient_id();
  PROTOBUF_NODISCARD std::string* release_recipient_id();
  void set_allocated_recipient_id(std::string* value);

  private:
  const std::string& _internal_recipient_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipient_id(
      const std::string& value);
  std::string* _internal_mutable_recipient_id();

  public:
  // string recipient_name = 4;
  void clear_recipient_name() ;
  const std::string& recipient_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_recipient_name(Arg_&& arg, Args_... args);
  std::string* mutable_recipient_name();
  PROTOBUF_NODISCARD std::string* release_recipient_name();
  void set_allocated_recipient_name(std::string* value);

  private:
  const std::string& _internal_recipient_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipient_name(
      const std::string& value);
  std::string* _internal_mutable_recipient_name();

  public:
  // string message = 5;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // .google.protobuf.Timestamp timestamp = 6;
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::google::protobuf::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_timestamp();

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.WhisperMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      83, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr sender_id_;
    ::google::protobuf::internal::ArenaStringPtr sender_name_;
    ::google::protobuf::internal::ArenaStringPtr recipient_id_;
    ::google::protobuf::internal::ArenaStringPtr recipient_name_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::google::protobuf::Timestamp* timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};// -------------------------------------------------------------------

class ChatMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.ChatMessage) */ {
 public:
  inline ChatMessage() : ChatMessage(nullptr) {}
  ~ChatMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChatMessage(::google::protobuf::internal::ConstantInitialized);

  inline ChatMessage(const ChatMessage& from)
      : ChatMessage(nullptr, from) {}
  ChatMessage(ChatMessage&& from) noexcept
    : ChatMessage() {
    *this = ::std::move(from);
  }

  inline ChatMessage& operator=(const ChatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatMessage& operator=(ChatMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatMessage* internal_default_instance() {
    return reinterpret_cast<const ChatMessage*>(
               &_ChatMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ChatMessage& a, ChatMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChatMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChatMessage& from) {
    ChatMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChatMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.ChatMessage";
  }
  protected:
  explicit ChatMessage(::google::protobuf::Arena* arena);
  ChatMessage(::google::protobuf::Arena* arena, const ChatMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMentionedPlayersFieldNumber = 10,
    kMessageIdFieldNumber = 1,
    kSenderIdFieldNumber = 2,
    kSenderNameFieldNumber = 3,
    kChannelIdFieldNumber = 5,
    kMessageFieldNumber = 6,
    kRecipientIdFieldNumber = 8,
    kRecipientNameFieldNumber = 9,
    kSenderGuildFieldNumber = 11,
    kTimestampFieldNumber = 7,
    kChannelFieldNumber = 4,
    kSenderLevelFieldNumber = 12,
    kMessageTypeFieldNumber = 13,
    kIsFilteredFieldNumber = 14,
    kIsReportedFieldNumber = 15,
  };
  // repeated string mentioned_players = 10;
  int mentioned_players_size() const;
  private:
  int _internal_mentioned_players_size() const;

  public:
  void clear_mentioned_players() ;
  const std::string& mentioned_players(int index) const;
  std::string* mutable_mentioned_players(int index);
  void set_mentioned_players(int index, const std::string& value);
  void set_mentioned_players(int index, std::string&& value);
  void set_mentioned_players(int index, const char* value);
  void set_mentioned_players(int index, const char* value, std::size_t size);
  void set_mentioned_players(int index, absl::string_view value);
  std::string* add_mentioned_players();
  void add_mentioned_players(const std::string& value);
  void add_mentioned_players(std::string&& value);
  void add_mentioned_players(const char* value);
  void add_mentioned_players(const char* value, std::size_t size);
  void add_mentioned_players(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& mentioned_players() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_mentioned_players();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_mentioned_players() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_mentioned_players();

  public:
  // string message_id = 1;
  void clear_message_id() ;
  const std::string& message_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message_id(Arg_&& arg, Args_... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* value);

  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(
      const std::string& value);
  std::string* _internal_mutable_message_id();

  public:
  // string sender_id = 2;
  void clear_sender_id() ;
  const std::string& sender_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender_id(Arg_&& arg, Args_... args);
  std::string* mutable_sender_id();
  PROTOBUF_NODISCARD std::string* release_sender_id();
  void set_allocated_sender_id(std::string* value);

  private:
  const std::string& _internal_sender_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_id(
      const std::string& value);
  std::string* _internal_mutable_sender_id();

  public:
  // string sender_name = 3;
  void clear_sender_name() ;
  const std::string& sender_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender_name(Arg_&& arg, Args_... args);
  std::string* mutable_sender_name();
  PROTOBUF_NODISCARD std::string* release_sender_name();
  void set_allocated_sender_name(std::string* value);

  private:
  const std::string& _internal_sender_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_name(
      const std::string& value);
  std::string* _internal_mutable_sender_name();

  public:
  // string channel_id = 5;
  void clear_channel_id() ;
  const std::string& channel_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel_id(Arg_&& arg, Args_... args);
  std::string* mutable_channel_id();
  PROTOBUF_NODISCARD std::string* release_channel_id();
  void set_allocated_channel_id(std::string* value);

  private:
  const std::string& _internal_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_id(
      const std::string& value);
  std::string* _internal_mutable_channel_id();

  public:
  // string message = 6;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // string recipient_id = 8;
  void clear_recipient_id() ;
  const std::string& recipient_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_recipient_id(Arg_&& arg, Args_... args);
  std::string* mutable_recipient_id();
  PROTOBUF_NODISCARD std::string* release_recipient_id();
  void set_allocated_recipient_id(std::string* value);

  private:
  const std::string& _internal_recipient_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipient_id(
      const std::string& value);
  std::string* _internal_mutable_recipient_id();

  public:
  // string recipient_name = 9;
  void clear_recipient_name() ;
  const std::string& recipient_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_recipient_name(Arg_&& arg, Args_... args);
  std::string* mutable_recipient_name();
  PROTOBUF_NODISCARD std::string* release_recipient_name();
  void set_allocated_recipient_name(std::string* value);

  private:
  const std::string& _internal_recipient_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipient_name(
      const std::string& value);
  std::string* _internal_mutable_recipient_name();

  public:
  // string sender_guild = 11;
  void clear_sender_guild() ;
  const std::string& sender_guild() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender_guild(Arg_&& arg, Args_... args);
  std::string* mutable_sender_guild();
  PROTOBUF_NODISCARD std::string* release_sender_guild();
  void set_allocated_sender_guild(std::string* value);

  private:
  const std::string& _internal_sender_guild() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_guild(
      const std::string& value);
  std::string* _internal_mutable_sender_guild();

  public:
  // .google.protobuf.Timestamp timestamp = 7;
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::google::protobuf::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_timestamp();

  public:
  // .mmorpg.ChatChannel channel = 4;
  void clear_channel() ;
  ::mmorpg::ChatChannel channel() const;
  void set_channel(::mmorpg::ChatChannel value);

  private:
  ::mmorpg::ChatChannel _internal_channel() const;
  void _internal_set_channel(::mmorpg::ChatChannel value);

  public:
  // int32 sender_level = 12;
  void clear_sender_level() ;
  ::int32_t sender_level() const;
  void set_sender_level(::int32_t value);

  private:
  ::int32_t _internal_sender_level() const;
  void _internal_set_sender_level(::int32_t value);

  public:
  // .mmorpg.ChatMessageType message_type = 13;
  void clear_message_type() ;
  ::mmorpg::ChatMessageType message_type() const;
  void set_message_type(::mmorpg::ChatMessageType value);

  private:
  ::mmorpg::ChatMessageType _internal_message_type() const;
  void _internal_set_message_type(::mmorpg::ChatMessageType value);

  public:
  // bool is_filtered = 14;
  void clear_is_filtered() ;
  bool is_filtered() const;
  void set_is_filtered(bool value);

  private:
  bool _internal_is_filtered() const;
  void _internal_set_is_filtered(bool value);

  public:
  // bool is_reported = 15;
  void clear_is_reported() ;
  bool is_reported() const;
  void set_is_reported(bool value);

  private:
  bool _internal_is_reported() const;
  void _internal_set_is_reported(bool value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.ChatMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 15, 1,
      137, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> mentioned_players_;
    ::google::protobuf::internal::ArenaStringPtr message_id_;
    ::google::protobuf::internal::ArenaStringPtr sender_id_;
    ::google::protobuf::internal::ArenaStringPtr sender_name_;
    ::google::protobuf::internal::ArenaStringPtr channel_id_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::google::protobuf::internal::ArenaStringPtr recipient_id_;
    ::google::protobuf::internal::ArenaStringPtr recipient_name_;
    ::google::protobuf::internal::ArenaStringPtr sender_guild_;
    ::google::protobuf::Timestamp* timestamp_;
    int channel_;
    ::int32_t sender_level_;
    int message_type_;
    bool is_filtered_;
    bool is_reported_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};// -------------------------------------------------------------------

class ChannelMember final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.ChannelMember) */ {
 public:
  inline ChannelMember() : ChannelMember(nullptr) {}
  ~ChannelMember() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelMember(::google::protobuf::internal::ConstantInitialized);

  inline ChannelMember(const ChannelMember& from)
      : ChannelMember(nullptr, from) {}
  ChannelMember(ChannelMember&& from) noexcept
    : ChannelMember() {
    *this = ::std::move(from);
  }

  inline ChannelMember& operator=(const ChannelMember& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelMember& operator=(ChannelMember&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelMember& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelMember* internal_default_instance() {
    return reinterpret_cast<const ChannelMember*>(
               &_ChannelMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ChannelMember& a, ChannelMember& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelMember* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelMember* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelMember* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelMember>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelMember& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChannelMember& from) {
    ChannelMember::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelMember* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.ChannelMember";
  }
  protected:
  explicit ChannelMember(::google::protobuf::Arena* arena);
  ChannelMember(::google::protobuf::Arena* arena, const ChannelMember& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kPlayerNameFieldNumber = 2,
    kJoinedAtFieldNumber = 5,
    kRoleFieldNumber = 3,
    kIsMutedFieldNumber = 4,
  };
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // string player_name = 2;
  void clear_player_name() ;
  const std::string& player_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_name(Arg_&& arg, Args_... args);
  std::string* mutable_player_name();
  PROTOBUF_NODISCARD std::string* release_player_name();
  void set_allocated_player_name(std::string* value);

  private:
  const std::string& _internal_player_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_name(
      const std::string& value);
  std::string* _internal_mutable_player_name();

  public:
  // .google.protobuf.Timestamp joined_at = 5;
  bool has_joined_at() const;
  void clear_joined_at() ;
  const ::google::protobuf::Timestamp& joined_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_joined_at();
  ::google::protobuf::Timestamp* mutable_joined_at();
  void set_allocated_joined_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_joined_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_joined_at();

  private:
  const ::google::protobuf::Timestamp& _internal_joined_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_joined_at();

  public:
  // .mmorpg.ChannelRole role = 3;
  void clear_role() ;
  ::mmorpg::ChannelRole role() const;
  void set_role(::mmorpg::ChannelRole value);

  private:
  ::mmorpg::ChannelRole _internal_role() const;
  void _internal_set_role(::mmorpg::ChannelRole value);

  public:
  // bool is_muted = 4;
  void clear_is_muted() ;
  bool is_muted() const;
  void set_is_muted(bool value);

  private:
  bool _internal_is_muted() const;
  void _internal_set_is_muted(bool value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.ChannelMember)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::google::protobuf::internal::ArenaStringPtr player_name_;
    ::google::protobuf::Timestamp* joined_at_;
    int role_;
    bool is_muted_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};// -------------------------------------------------------------------

class ChannelListResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.ChannelListResponse) */ {
 public:
  inline ChannelListResponse() : ChannelListResponse(nullptr) {}
  ~ChannelListResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelListResponse(::google::protobuf::internal::ConstantInitialized);

  inline ChannelListResponse(const ChannelListResponse& from)
      : ChannelListResponse(nullptr, from) {}
  ChannelListResponse(ChannelListResponse&& from) noexcept
    : ChannelListResponse() {
    *this = ::std::move(from);
  }

  inline ChannelListResponse& operator=(const ChannelListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelListResponse& operator=(ChannelListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelListResponse* internal_default_instance() {
    return reinterpret_cast<const ChannelListResponse*>(
               &_ChannelListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ChannelListResponse& a, ChannelListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelListResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelListResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelListResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelListResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChannelListResponse& from) {
    ChannelListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelListResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.ChannelListResponse";
  }
  protected:
  explicit ChannelListResponse(::google::protobuf::Arena* arena);
  ChannelListResponse(::google::protobuf::Arena* arena, const ChannelListResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelsFieldNumber = 1,
  };
  // repeated .mmorpg.ChannelInfo channels = 1;
  int channels_size() const;
  private:
  int _internal_channels_size() const;

  public:
  void clear_channels() ;
  ::mmorpg::ChannelInfo* mutable_channels(int index);
  ::google::protobuf::RepeatedPtrField< ::mmorpg::ChannelInfo >*
      mutable_channels();
  private:
  const ::google::protobuf::RepeatedPtrField<::mmorpg::ChannelInfo>& _internal_channels() const;
  ::google::protobuf::RepeatedPtrField<::mmorpg::ChannelInfo>* _internal_mutable_channels();
  public:
  const ::mmorpg::ChannelInfo& channels(int index) const;
  ::mmorpg::ChannelInfo* add_channels();
  const ::google::protobuf::RepeatedPtrField< ::mmorpg::ChannelInfo >&
      channels() const;
  // @@protoc_insertion_point(class_scope:mmorpg.ChannelListResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::mmorpg::ChannelInfo > channels_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};// -------------------------------------------------------------------

class ChatHistoryResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.ChatHistoryResponse) */ {
 public:
  inline ChatHistoryResponse() : ChatHistoryResponse(nullptr) {}
  ~ChatHistoryResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChatHistoryResponse(::google::protobuf::internal::ConstantInitialized);

  inline ChatHistoryResponse(const ChatHistoryResponse& from)
      : ChatHistoryResponse(nullptr, from) {}
  ChatHistoryResponse(ChatHistoryResponse&& from) noexcept
    : ChatHistoryResponse() {
    *this = ::std::move(from);
  }

  inline ChatHistoryResponse& operator=(const ChatHistoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatHistoryResponse& operator=(ChatHistoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatHistoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatHistoryResponse* internal_default_instance() {
    return reinterpret_cast<const ChatHistoryResponse*>(
               &_ChatHistoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ChatHistoryResponse& a, ChatHistoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatHistoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatHistoryResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatHistoryResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatHistoryResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChatHistoryResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChatHistoryResponse& from) {
    ChatHistoryResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChatHistoryResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.ChatHistoryResponse";
  }
  protected:
  explicit ChatHistoryResponse(::google::protobuf::Arena* arena);
  ChatHistoryResponse(::google::protobuf::Arena* arena, const ChatHistoryResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 1,
    kHasMoreFieldNumber = 2,
  };
  // repeated .mmorpg.ChatMessage messages = 1;
  int messages_size() const;
  private:
  int _internal_messages_size() const;

  public:
  void clear_messages() ;
  ::mmorpg::ChatMessage* mutable_messages(int index);
  ::google::protobuf::RepeatedPtrField< ::mmorpg::ChatMessage >*
      mutable_messages();
  private:
  const ::google::protobuf::RepeatedPtrField<::mmorpg::ChatMessage>& _internal_messages() const;
  ::google::protobuf::RepeatedPtrField<::mmorpg::ChatMessage>* _internal_mutable_messages();
  public:
  const ::mmorpg::ChatMessage& messages(int index) const;
  ::mmorpg::ChatMessage* add_messages();
  const ::google::protobuf::RepeatedPtrField< ::mmorpg::ChatMessage >&
      messages() const;
  // bool has_more = 2;
  void clear_has_more() ;
  bool has_more() const;
  void set_has_more(bool value);

  private:
  bool _internal_has_more() const;
  void _internal_set_has_more(bool value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.ChatHistoryResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::mmorpg::ChatMessage > messages_;
    bool has_more_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};// -------------------------------------------------------------------

class ChannelJoinResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.ChannelJoinResponse) */ {
 public:
  inline ChannelJoinResponse() : ChannelJoinResponse(nullptr) {}
  ~ChannelJoinResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelJoinResponse(::google::protobuf::internal::ConstantInitialized);

  inline ChannelJoinResponse(const ChannelJoinResponse& from)
      : ChannelJoinResponse(nullptr, from) {}
  ChannelJoinResponse(ChannelJoinResponse&& from) noexcept
    : ChannelJoinResponse() {
    *this = ::std::move(from);
  }

  inline ChannelJoinResponse& operator=(const ChannelJoinResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelJoinResponse& operator=(ChannelJoinResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelJoinResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelJoinResponse* internal_default_instance() {
    return reinterpret_cast<const ChannelJoinResponse*>(
               &_ChannelJoinResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ChannelJoinResponse& a, ChannelJoinResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelJoinResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelJoinResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelJoinResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelJoinResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelJoinResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChannelJoinResponse& from) {
    ChannelJoinResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelJoinResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.ChannelJoinResponse";
  }
  protected:
  explicit ChannelJoinResponse(::google::protobuf::Arena* arena);
  ChannelJoinResponse(::google::protobuf::Arena* arena, const ChannelJoinResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 5,
    kChannelIdFieldNumber = 3,
    kChannelNameFieldNumber = 4,
    kErrorMessageFieldNumber = 6,
    kSuccessFieldNumber = 1,
    kChannelFieldNumber = 2,
    kErrorCodeFieldNumber = 7,
  };
  // repeated .mmorpg.ChannelMember members = 5;
  int members_size() const;
  private:
  int _internal_members_size() const;

  public:
  void clear_members() ;
  ::mmorpg::ChannelMember* mutable_members(int index);
  ::google::protobuf::RepeatedPtrField< ::mmorpg::ChannelMember >*
      mutable_members();
  private:
  const ::google::protobuf::RepeatedPtrField<::mmorpg::ChannelMember>& _internal_members() const;
  ::google::protobuf::RepeatedPtrField<::mmorpg::ChannelMember>* _internal_mutable_members();
  public:
  const ::mmorpg::ChannelMember& members(int index) const;
  ::mmorpg::ChannelMember* add_members();
  const ::google::protobuf::RepeatedPtrField< ::mmorpg::ChannelMember >&
      members() const;
  // string channel_id = 3;
  void clear_channel_id() ;
  const std::string& channel_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel_id(Arg_&& arg, Args_... args);
  std::string* mutable_channel_id();
  PROTOBUF_NODISCARD std::string* release_channel_id();
  void set_allocated_channel_id(std::string* value);

  private:
  const std::string& _internal_channel_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_id(
      const std::string& value);
  std::string* _internal_mutable_channel_id();

  public:
  // string channel_name = 4;
  void clear_channel_name() ;
  const std::string& channel_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_channel_name(Arg_&& arg, Args_... args);
  std::string* mutable_channel_name();
  PROTOBUF_NODISCARD std::string* release_channel_name();
  void set_allocated_channel_name(std::string* value);

  private:
  const std::string& _internal_channel_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_channel_name(
      const std::string& value);
  std::string* _internal_mutable_channel_name();

  public:
  // string error_message = 6;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // .mmorpg.ChatChannel channel = 2;
  void clear_channel() ;
  ::mmorpg::ChatChannel channel() const;
  void set_channel(::mmorpg::ChatChannel value);

  private:
  ::mmorpg::ChatChannel _internal_channel() const;
  void _internal_set_channel(::mmorpg::ChatChannel value);

  public:
  // .mmorpg.ErrorCode error_code = 7;
  void clear_error_code() ;
  ::mmorpg::ErrorCode error_code() const;
  void set_error_code(::mmorpg::ErrorCode value);

  private:
  ::mmorpg::ErrorCode _internal_error_code() const;
  void _internal_set_error_code(::mmorpg::ErrorCode value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.ChannelJoinResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      70, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::mmorpg::ChannelMember > members_;
    ::google::protobuf::internal::ArenaStringPtr channel_id_;
    ::google::protobuf::internal::ArenaStringPtr channel_name_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    bool success_;
    int channel_;
    int error_code_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ChatMessage

// string message_id = 1;
inline void ChatMessage::clear_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_id_.ClearToEmpty();
}
inline const std::string& ChatMessage::message_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChatMessage.message_id)
  return _internal_message_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatMessage::set_message_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChatMessage.message_id)
}
inline std::string* ChatMessage::mutable_message_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChatMessage.message_id)
  return _s;
}
inline const std::string& ChatMessage::_internal_message_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_id_.Get();
}
inline void ChatMessage::_internal_set_message_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_id_.Set(value, GetArena());
}
inline std::string* ChatMessage::_internal_mutable_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_id_.Mutable( GetArena());
}
inline std::string* ChatMessage::release_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChatMessage.message_id)
  return _impl_.message_id_.Release();
}
inline void ChatMessage::set_allocated_message_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_id_.IsDefault()) {
          _impl_.message_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChatMessage.message_id)
}

// string sender_id = 2;
inline void ChatMessage::clear_sender_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sender_id_.ClearToEmpty();
}
inline const std::string& ChatMessage::sender_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChatMessage.sender_id)
  return _internal_sender_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatMessage::set_sender_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sender_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChatMessage.sender_id)
}
inline std::string* ChatMessage::mutable_sender_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sender_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChatMessage.sender_id)
  return _s;
}
inline const std::string& ChatMessage::_internal_sender_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sender_id_.Get();
}
inline void ChatMessage::_internal_set_sender_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sender_id_.Set(value, GetArena());
}
inline std::string* ChatMessage::_internal_mutable_sender_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.sender_id_.Mutable( GetArena());
}
inline std::string* ChatMessage::release_sender_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChatMessage.sender_id)
  return _impl_.sender_id_.Release();
}
inline void ChatMessage::set_allocated_sender_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sender_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_id_.IsDefault()) {
          _impl_.sender_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChatMessage.sender_id)
}

// string sender_name = 3;
inline void ChatMessage::clear_sender_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sender_name_.ClearToEmpty();
}
inline const std::string& ChatMessage::sender_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChatMessage.sender_name)
  return _internal_sender_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatMessage::set_sender_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sender_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChatMessage.sender_name)
}
inline std::string* ChatMessage::mutable_sender_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sender_name();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChatMessage.sender_name)
  return _s;
}
inline const std::string& ChatMessage::_internal_sender_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sender_name_.Get();
}
inline void ChatMessage::_internal_set_sender_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sender_name_.Set(value, GetArena());
}
inline std::string* ChatMessage::_internal_mutable_sender_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.sender_name_.Mutable( GetArena());
}
inline std::string* ChatMessage::release_sender_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChatMessage.sender_name)
  return _impl_.sender_name_.Release();
}
inline void ChatMessage::set_allocated_sender_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sender_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_name_.IsDefault()) {
          _impl_.sender_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChatMessage.sender_name)
}

// .mmorpg.ChatChannel channel = 4;
inline void ChatMessage::clear_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_ = 0;
}
inline ::mmorpg::ChatChannel ChatMessage::channel() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChatMessage.channel)
  return _internal_channel();
}
inline void ChatMessage::set_channel(::mmorpg::ChatChannel value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChatMessage.channel)
}
inline ::mmorpg::ChatChannel ChatMessage::_internal_channel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::ChatChannel>(_impl_.channel_);
}
inline void ChatMessage::_internal_set_channel(::mmorpg::ChatChannel value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_ = value;
}

// string channel_id = 5;
inline void ChatMessage::clear_channel_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_id_.ClearToEmpty();
}
inline const std::string& ChatMessage::channel_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChatMessage.channel_id)
  return _internal_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatMessage::set_channel_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChatMessage.channel_id)
}
inline std::string* ChatMessage::mutable_channel_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_channel_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChatMessage.channel_id)
  return _s;
}
inline const std::string& ChatMessage::_internal_channel_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channel_id_.Get();
}
inline void ChatMessage::_internal_set_channel_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_id_.Set(value, GetArena());
}
inline std::string* ChatMessage::_internal_mutable_channel_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.channel_id_.Mutable( GetArena());
}
inline std::string* ChatMessage::release_channel_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChatMessage.channel_id)
  return _impl_.channel_id_.Release();
}
inline void ChatMessage::set_allocated_channel_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.channel_id_.IsDefault()) {
          _impl_.channel_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChatMessage.channel_id)
}

// string message = 6;
inline void ChatMessage::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ChatMessage::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChatMessage.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatMessage::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChatMessage.message)
}
inline std::string* ChatMessage::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChatMessage.message)
  return _s;
}
inline const std::string& ChatMessage::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void ChatMessage::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* ChatMessage::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* ChatMessage::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChatMessage.message)
  return _impl_.message_.Release();
}
inline void ChatMessage::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChatMessage.message)
}

// .google.protobuf.Timestamp timestamp = 7;
inline bool ChatMessage::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& ChatMessage::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& ChatMessage::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChatMessage.timestamp)
  return _internal_timestamp();
}
inline void ChatMessage::unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.ChatMessage.timestamp)
}
inline ::google::protobuf::Timestamp* ChatMessage::release_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* ChatMessage::unsafe_arena_release_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChatMessage.timestamp)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* ChatMessage::_internal_mutable_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::google::protobuf::Timestamp* ChatMessage::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChatMessage.timestamp)
  return _msg;
}
inline void ChatMessage::set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChatMessage.timestamp)
}

// string recipient_id = 8;
inline void ChatMessage::clear_recipient_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.recipient_id_.ClearToEmpty();
}
inline const std::string& ChatMessage::recipient_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChatMessage.recipient_id)
  return _internal_recipient_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatMessage::set_recipient_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.recipient_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChatMessage.recipient_id)
}
inline std::string* ChatMessage::mutable_recipient_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_recipient_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChatMessage.recipient_id)
  return _s;
}
inline const std::string& ChatMessage::_internal_recipient_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.recipient_id_.Get();
}
inline void ChatMessage::_internal_set_recipient_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.recipient_id_.Set(value, GetArena());
}
inline std::string* ChatMessage::_internal_mutable_recipient_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.recipient_id_.Mutable( GetArena());
}
inline std::string* ChatMessage::release_recipient_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChatMessage.recipient_id)
  return _impl_.recipient_id_.Release();
}
inline void ChatMessage::set_allocated_recipient_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.recipient_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.recipient_id_.IsDefault()) {
          _impl_.recipient_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChatMessage.recipient_id)
}

// string recipient_name = 9;
inline void ChatMessage::clear_recipient_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.recipient_name_.ClearToEmpty();
}
inline const std::string& ChatMessage::recipient_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChatMessage.recipient_name)
  return _internal_recipient_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatMessage::set_recipient_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.recipient_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChatMessage.recipient_name)
}
inline std::string* ChatMessage::mutable_recipient_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_recipient_name();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChatMessage.recipient_name)
  return _s;
}
inline const std::string& ChatMessage::_internal_recipient_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.recipient_name_.Get();
}
inline void ChatMessage::_internal_set_recipient_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.recipient_name_.Set(value, GetArena());
}
inline std::string* ChatMessage::_internal_mutable_recipient_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.recipient_name_.Mutable( GetArena());
}
inline std::string* ChatMessage::release_recipient_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChatMessage.recipient_name)
  return _impl_.recipient_name_.Release();
}
inline void ChatMessage::set_allocated_recipient_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.recipient_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.recipient_name_.IsDefault()) {
          _impl_.recipient_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChatMessage.recipient_name)
}

// repeated string mentioned_players = 10;
inline int ChatMessage::_internal_mentioned_players_size() const {
  return _internal_mentioned_players().size();
}
inline int ChatMessage::mentioned_players_size() const {
  return _internal_mentioned_players_size();
}
inline void ChatMessage::clear_mentioned_players() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mentioned_players_.Clear();
}
inline std::string* ChatMessage::add_mentioned_players()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_mentioned_players()->Add();
  // @@protoc_insertion_point(field_add_mutable:mmorpg.ChatMessage.mentioned_players)
  return _s;
}
inline const std::string& ChatMessage::mentioned_players(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChatMessage.mentioned_players)
  return _internal_mentioned_players().Get(index);
}
inline std::string* ChatMessage::mutable_mentioned_players(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.ChatMessage.mentioned_players)
  return _internal_mutable_mentioned_players()->Mutable(index);
}
inline void ChatMessage::set_mentioned_players(int index, const std::string& value) {
  _internal_mutable_mentioned_players()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChatMessage.mentioned_players)
}
inline void ChatMessage::set_mentioned_players(int index, std::string&& value) {
  _internal_mutable_mentioned_players()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:mmorpg.ChatMessage.mentioned_players)
}
inline void ChatMessage::set_mentioned_players(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_mentioned_players()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mmorpg.ChatMessage.mentioned_players)
}
inline void ChatMessage::set_mentioned_players(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_mentioned_players()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mmorpg.ChatMessage.mentioned_players)
}
inline void ChatMessage::set_mentioned_players(int index, absl::string_view value) {
  _internal_mutable_mentioned_players()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:mmorpg.ChatMessage.mentioned_players)
}
inline void ChatMessage::add_mentioned_players(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_mentioned_players()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:mmorpg.ChatMessage.mentioned_players)
}
inline void ChatMessage::add_mentioned_players(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_mentioned_players()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:mmorpg.ChatMessage.mentioned_players)
}
inline void ChatMessage::add_mentioned_players(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_mentioned_players()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mmorpg.ChatMessage.mentioned_players)
}
inline void ChatMessage::add_mentioned_players(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_mentioned_players()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mmorpg.ChatMessage.mentioned_players)
}
inline void ChatMessage::add_mentioned_players(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_mentioned_players()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:mmorpg.ChatMessage.mentioned_players)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ChatMessage::mentioned_players() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.ChatMessage.mentioned_players)
  return _internal_mentioned_players();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ChatMessage::mutable_mentioned_players() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.ChatMessage.mentioned_players)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_mentioned_players();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ChatMessage::_internal_mentioned_players() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mentioned_players_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ChatMessage::_internal_mutable_mentioned_players() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.mentioned_players_;
}

// string sender_guild = 11;
inline void ChatMessage::clear_sender_guild() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sender_guild_.ClearToEmpty();
}
inline const std::string& ChatMessage::sender_guild() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChatMessage.sender_guild)
  return _internal_sender_guild();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatMessage::set_sender_guild(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sender_guild_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChatMessage.sender_guild)
}
inline std::string* ChatMessage::mutable_sender_guild() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sender_guild();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChatMessage.sender_guild)
  return _s;
}
inline const std::string& ChatMessage::_internal_sender_guild() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sender_guild_.Get();
}
inline void ChatMessage::_internal_set_sender_guild(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sender_guild_.Set(value, GetArena());
}
inline std::string* ChatMessage::_internal_mutable_sender_guild() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.sender_guild_.Mutable( GetArena());
}
inline std::string* ChatMessage::release_sender_guild() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChatMessage.sender_guild)
  return _impl_.sender_guild_.Release();
}
inline void ChatMessage::set_allocated_sender_guild(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sender_guild_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_guild_.IsDefault()) {
          _impl_.sender_guild_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChatMessage.sender_guild)
}

// int32 sender_level = 12;
inline void ChatMessage::clear_sender_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sender_level_ = 0;
}
inline ::int32_t ChatMessage::sender_level() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChatMessage.sender_level)
  return _internal_sender_level();
}
inline void ChatMessage::set_sender_level(::int32_t value) {
  _internal_set_sender_level(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChatMessage.sender_level)
}
inline ::int32_t ChatMessage::_internal_sender_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sender_level_;
}
inline void ChatMessage::_internal_set_sender_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sender_level_ = value;
}

// .mmorpg.ChatMessageType message_type = 13;
inline void ChatMessage::clear_message_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_type_ = 0;
}
inline ::mmorpg::ChatMessageType ChatMessage::message_type() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChatMessage.message_type)
  return _internal_message_type();
}
inline void ChatMessage::set_message_type(::mmorpg::ChatMessageType value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChatMessage.message_type)
}
inline ::mmorpg::ChatMessageType ChatMessage::_internal_message_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::ChatMessageType>(_impl_.message_type_);
}
inline void ChatMessage::_internal_set_message_type(::mmorpg::ChatMessageType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_type_ = value;
}

// bool is_filtered = 14;
inline void ChatMessage::clear_is_filtered() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_filtered_ = false;
}
inline bool ChatMessage::is_filtered() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChatMessage.is_filtered)
  return _internal_is_filtered();
}
inline void ChatMessage::set_is_filtered(bool value) {
  _internal_set_is_filtered(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChatMessage.is_filtered)
}
inline bool ChatMessage::_internal_is_filtered() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_filtered_;
}
inline void ChatMessage::_internal_set_is_filtered(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_filtered_ = value;
}

// bool is_reported = 15;
inline void ChatMessage::clear_is_reported() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_reported_ = false;
}
inline bool ChatMessage::is_reported() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChatMessage.is_reported)
  return _internal_is_reported();
}
inline void ChatMessage::set_is_reported(bool value) {
  _internal_set_is_reported(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChatMessage.is_reported)
}
inline bool ChatMessage::_internal_is_reported() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_reported_;
}
inline void ChatMessage::_internal_set_is_reported(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_reported_ = value;
}

// -------------------------------------------------------------------

// WhisperMessage

// string sender_id = 1;
inline void WhisperMessage::clear_sender_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sender_id_.ClearToEmpty();
}
inline const std::string& WhisperMessage::sender_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.WhisperMessage.sender_id)
  return _internal_sender_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WhisperMessage::set_sender_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sender_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.WhisperMessage.sender_id)
}
inline std::string* WhisperMessage::mutable_sender_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sender_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.WhisperMessage.sender_id)
  return _s;
}
inline const std::string& WhisperMessage::_internal_sender_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sender_id_.Get();
}
inline void WhisperMessage::_internal_set_sender_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sender_id_.Set(value, GetArena());
}
inline std::string* WhisperMessage::_internal_mutable_sender_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.sender_id_.Mutable( GetArena());
}
inline std::string* WhisperMessage::release_sender_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.WhisperMessage.sender_id)
  return _impl_.sender_id_.Release();
}
inline void WhisperMessage::set_allocated_sender_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sender_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_id_.IsDefault()) {
          _impl_.sender_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.WhisperMessage.sender_id)
}

// string sender_name = 2;
inline void WhisperMessage::clear_sender_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sender_name_.ClearToEmpty();
}
inline const std::string& WhisperMessage::sender_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.WhisperMessage.sender_name)
  return _internal_sender_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WhisperMessage::set_sender_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sender_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.WhisperMessage.sender_name)
}
inline std::string* WhisperMessage::mutable_sender_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sender_name();
  // @@protoc_insertion_point(field_mutable:mmorpg.WhisperMessage.sender_name)
  return _s;
}
inline const std::string& WhisperMessage::_internal_sender_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sender_name_.Get();
}
inline void WhisperMessage::_internal_set_sender_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sender_name_.Set(value, GetArena());
}
inline std::string* WhisperMessage::_internal_mutable_sender_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.sender_name_.Mutable( GetArena());
}
inline std::string* WhisperMessage::release_sender_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.WhisperMessage.sender_name)
  return _impl_.sender_name_.Release();
}
inline void WhisperMessage::set_allocated_sender_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sender_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_name_.IsDefault()) {
          _impl_.sender_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.WhisperMessage.sender_name)
}

// string recipient_id = 3;
inline void WhisperMessage::clear_recipient_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.recipient_id_.ClearToEmpty();
}
inline const std::string& WhisperMessage::recipient_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.WhisperMessage.recipient_id)
  return _internal_recipient_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WhisperMessage::set_recipient_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.recipient_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.WhisperMessage.recipient_id)
}
inline std::string* WhisperMessage::mutable_recipient_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_recipient_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.WhisperMessage.recipient_id)
  return _s;
}
inline const std::string& WhisperMessage::_internal_recipient_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.recipient_id_.Get();
}
inline void WhisperMessage::_internal_set_recipient_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.recipient_id_.Set(value, GetArena());
}
inline std::string* WhisperMessage::_internal_mutable_recipient_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.recipient_id_.Mutable( GetArena());
}
inline std::string* WhisperMessage::release_recipient_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.WhisperMessage.recipient_id)
  return _impl_.recipient_id_.Release();
}
inline void WhisperMessage::set_allocated_recipient_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.recipient_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.recipient_id_.IsDefault()) {
          _impl_.recipient_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.WhisperMessage.recipient_id)
}

// string recipient_name = 4;
inline void WhisperMessage::clear_recipient_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.recipient_name_.ClearToEmpty();
}
inline const std::string& WhisperMessage::recipient_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.WhisperMessage.recipient_name)
  return _internal_recipient_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WhisperMessage::set_recipient_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.recipient_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.WhisperMessage.recipient_name)
}
inline std::string* WhisperMessage::mutable_recipient_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_recipient_name();
  // @@protoc_insertion_point(field_mutable:mmorpg.WhisperMessage.recipient_name)
  return _s;
}
inline const std::string& WhisperMessage::_internal_recipient_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.recipient_name_.Get();
}
inline void WhisperMessage::_internal_set_recipient_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.recipient_name_.Set(value, GetArena());
}
inline std::string* WhisperMessage::_internal_mutable_recipient_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.recipient_name_.Mutable( GetArena());
}
inline std::string* WhisperMessage::release_recipient_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.WhisperMessage.recipient_name)
  return _impl_.recipient_name_.Release();
}
inline void WhisperMessage::set_allocated_recipient_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.recipient_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.recipient_name_.IsDefault()) {
          _impl_.recipient_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.WhisperMessage.recipient_name)
}

// string message = 5;
inline void WhisperMessage::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& WhisperMessage::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.WhisperMessage.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WhisperMessage::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.WhisperMessage.message)
}
inline std::string* WhisperMessage::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:mmorpg.WhisperMessage.message)
  return _s;
}
inline const std::string& WhisperMessage::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void WhisperMessage::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* WhisperMessage::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* WhisperMessage::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.WhisperMessage.message)
  return _impl_.message_.Release();
}
inline void WhisperMessage::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.WhisperMessage.message)
}

// .google.protobuf.Timestamp timestamp = 6;
inline bool WhisperMessage::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& WhisperMessage::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& WhisperMessage::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.WhisperMessage.timestamp)
  return _internal_timestamp();
}
inline void WhisperMessage::unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.WhisperMessage.timestamp)
}
inline ::google::protobuf::Timestamp* WhisperMessage::release_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* WhisperMessage::unsafe_arena_release_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.WhisperMessage.timestamp)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* WhisperMessage::_internal_mutable_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::google::protobuf::Timestamp* WhisperMessage::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:mmorpg.WhisperMessage.timestamp)
  return _msg;
}
inline void WhisperMessage::set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.WhisperMessage.timestamp)
}

// -------------------------------------------------------------------

// ChannelJoinRequest

// string player_id = 1;
inline void ChannelJoinRequest::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& ChannelJoinRequest::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelJoinRequest.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChannelJoinRequest::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChannelJoinRequest.player_id)
}
inline std::string* ChannelJoinRequest::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChannelJoinRequest.player_id)
  return _s;
}
inline const std::string& ChannelJoinRequest::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void ChannelJoinRequest::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* ChannelJoinRequest::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* ChannelJoinRequest::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChannelJoinRequest.player_id)
  return _impl_.player_id_.Release();
}
inline void ChannelJoinRequest::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChannelJoinRequest.player_id)
}

// .mmorpg.ChatChannel channel = 2;
inline void ChannelJoinRequest::clear_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_ = 0;
}
inline ::mmorpg::ChatChannel ChannelJoinRequest::channel() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelJoinRequest.channel)
  return _internal_channel();
}
inline void ChannelJoinRequest::set_channel(::mmorpg::ChatChannel value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChannelJoinRequest.channel)
}
inline ::mmorpg::ChatChannel ChannelJoinRequest::_internal_channel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::ChatChannel>(_impl_.channel_);
}
inline void ChannelJoinRequest::_internal_set_channel(::mmorpg::ChatChannel value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_ = value;
}

// string channel_id = 3;
inline void ChannelJoinRequest::clear_channel_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_id_.ClearToEmpty();
}
inline const std::string& ChannelJoinRequest::channel_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelJoinRequest.channel_id)
  return _internal_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChannelJoinRequest::set_channel_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChannelJoinRequest.channel_id)
}
inline std::string* ChannelJoinRequest::mutable_channel_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_channel_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChannelJoinRequest.channel_id)
  return _s;
}
inline const std::string& ChannelJoinRequest::_internal_channel_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channel_id_.Get();
}
inline void ChannelJoinRequest::_internal_set_channel_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_id_.Set(value, GetArena());
}
inline std::string* ChannelJoinRequest::_internal_mutable_channel_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.channel_id_.Mutable( GetArena());
}
inline std::string* ChannelJoinRequest::release_channel_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChannelJoinRequest.channel_id)
  return _impl_.channel_id_.Release();
}
inline void ChannelJoinRequest::set_allocated_channel_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.channel_id_.IsDefault()) {
          _impl_.channel_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChannelJoinRequest.channel_id)
}

// string password = 4;
inline void ChannelJoinRequest::clear_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.password_.ClearToEmpty();
}
inline const std::string& ChannelJoinRequest::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelJoinRequest.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChannelJoinRequest::set_password(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChannelJoinRequest.password)
}
inline std::string* ChannelJoinRequest::mutable_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChannelJoinRequest.password)
  return _s;
}
inline const std::string& ChannelJoinRequest::_internal_password() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.password_.Get();
}
inline void ChannelJoinRequest::_internal_set_password(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.password_.Set(value, GetArena());
}
inline std::string* ChannelJoinRequest::_internal_mutable_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.password_.Mutable( GetArena());
}
inline std::string* ChannelJoinRequest::release_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChannelJoinRequest.password)
  return _impl_.password_.Release();
}
inline void ChannelJoinRequest::set_allocated_password(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.password_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChannelJoinRequest.password)
}

// -------------------------------------------------------------------

// ChannelJoinResponse

// bool success = 1;
inline void ChannelJoinResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool ChannelJoinResponse::success() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelJoinResponse.success)
  return _internal_success();
}
inline void ChannelJoinResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChannelJoinResponse.success)
}
inline bool ChannelJoinResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void ChannelJoinResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// .mmorpg.ChatChannel channel = 2;
inline void ChannelJoinResponse::clear_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_ = 0;
}
inline ::mmorpg::ChatChannel ChannelJoinResponse::channel() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelJoinResponse.channel)
  return _internal_channel();
}
inline void ChannelJoinResponse::set_channel(::mmorpg::ChatChannel value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChannelJoinResponse.channel)
}
inline ::mmorpg::ChatChannel ChannelJoinResponse::_internal_channel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::ChatChannel>(_impl_.channel_);
}
inline void ChannelJoinResponse::_internal_set_channel(::mmorpg::ChatChannel value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_ = value;
}

// string channel_id = 3;
inline void ChannelJoinResponse::clear_channel_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_id_.ClearToEmpty();
}
inline const std::string& ChannelJoinResponse::channel_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelJoinResponse.channel_id)
  return _internal_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChannelJoinResponse::set_channel_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChannelJoinResponse.channel_id)
}
inline std::string* ChannelJoinResponse::mutable_channel_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_channel_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChannelJoinResponse.channel_id)
  return _s;
}
inline const std::string& ChannelJoinResponse::_internal_channel_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channel_id_.Get();
}
inline void ChannelJoinResponse::_internal_set_channel_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_id_.Set(value, GetArena());
}
inline std::string* ChannelJoinResponse::_internal_mutable_channel_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.channel_id_.Mutable( GetArena());
}
inline std::string* ChannelJoinResponse::release_channel_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChannelJoinResponse.channel_id)
  return _impl_.channel_id_.Release();
}
inline void ChannelJoinResponse::set_allocated_channel_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.channel_id_.IsDefault()) {
          _impl_.channel_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChannelJoinResponse.channel_id)
}

// string channel_name = 4;
inline void ChannelJoinResponse::clear_channel_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_name_.ClearToEmpty();
}
inline const std::string& ChannelJoinResponse::channel_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelJoinResponse.channel_name)
  return _internal_channel_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChannelJoinResponse::set_channel_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChannelJoinResponse.channel_name)
}
inline std::string* ChannelJoinResponse::mutable_channel_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_channel_name();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChannelJoinResponse.channel_name)
  return _s;
}
inline const std::string& ChannelJoinResponse::_internal_channel_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channel_name_.Get();
}
inline void ChannelJoinResponse::_internal_set_channel_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_name_.Set(value, GetArena());
}
inline std::string* ChannelJoinResponse::_internal_mutable_channel_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.channel_name_.Mutable( GetArena());
}
inline std::string* ChannelJoinResponse::release_channel_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChannelJoinResponse.channel_name)
  return _impl_.channel_name_.Release();
}
inline void ChannelJoinResponse::set_allocated_channel_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.channel_name_.IsDefault()) {
          _impl_.channel_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChannelJoinResponse.channel_name)
}

// repeated .mmorpg.ChannelMember members = 5;
inline int ChannelJoinResponse::_internal_members_size() const {
  return _internal_members().size();
}
inline int ChannelJoinResponse::members_size() const {
  return _internal_members_size();
}
inline void ChannelJoinResponse::clear_members() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.members_.Clear();
}
inline ::mmorpg::ChannelMember* ChannelJoinResponse::mutable_members(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.ChannelJoinResponse.members)
  return _internal_mutable_members()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::ChannelMember>* ChannelJoinResponse::mutable_members()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.ChannelJoinResponse.members)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_members();
}
inline const ::mmorpg::ChannelMember& ChannelJoinResponse::members(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelJoinResponse.members)
  return _internal_members().Get(index);
}
inline ::mmorpg::ChannelMember* ChannelJoinResponse::add_members() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::mmorpg::ChannelMember* _add = _internal_mutable_members()->Add();
  // @@protoc_insertion_point(field_add:mmorpg.ChannelJoinResponse.members)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::ChannelMember>& ChannelJoinResponse::members() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.ChannelJoinResponse.members)
  return _internal_members();
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::ChannelMember>&
ChannelJoinResponse::_internal_members() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.members_;
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::ChannelMember>*
ChannelJoinResponse::_internal_mutable_members() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.members_;
}

// string error_message = 6;
inline void ChannelJoinResponse::clear_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& ChannelJoinResponse::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelJoinResponse.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChannelJoinResponse::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChannelJoinResponse.error_message)
}
inline std::string* ChannelJoinResponse::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChannelJoinResponse.error_message)
  return _s;
}
inline const std::string& ChannelJoinResponse::_internal_error_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_message_.Get();
}
inline void ChannelJoinResponse::_internal_set_error_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* ChannelJoinResponse::_internal_mutable_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* ChannelJoinResponse::release_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChannelJoinResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void ChannelJoinResponse::set_allocated_error_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_message_.IsDefault()) {
          _impl_.error_message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChannelJoinResponse.error_message)
}

// .mmorpg.ErrorCode error_code = 7;
inline void ChannelJoinResponse::clear_error_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_code_ = 0;
}
inline ::mmorpg::ErrorCode ChannelJoinResponse::error_code() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelJoinResponse.error_code)
  return _internal_error_code();
}
inline void ChannelJoinResponse::set_error_code(::mmorpg::ErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChannelJoinResponse.error_code)
}
inline ::mmorpg::ErrorCode ChannelJoinResponse::_internal_error_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::ErrorCode>(_impl_.error_code_);
}
inline void ChannelJoinResponse::_internal_set_error_code(::mmorpg::ErrorCode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_code_ = value;
}

// -------------------------------------------------------------------

// ChannelLeaveRequest

// string player_id = 1;
inline void ChannelLeaveRequest::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& ChannelLeaveRequest::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelLeaveRequest.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChannelLeaveRequest::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChannelLeaveRequest.player_id)
}
inline std::string* ChannelLeaveRequest::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChannelLeaveRequest.player_id)
  return _s;
}
inline const std::string& ChannelLeaveRequest::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void ChannelLeaveRequest::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* ChannelLeaveRequest::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* ChannelLeaveRequest::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChannelLeaveRequest.player_id)
  return _impl_.player_id_.Release();
}
inline void ChannelLeaveRequest::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChannelLeaveRequest.player_id)
}

// .mmorpg.ChatChannel channel = 2;
inline void ChannelLeaveRequest::clear_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_ = 0;
}
inline ::mmorpg::ChatChannel ChannelLeaveRequest::channel() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelLeaveRequest.channel)
  return _internal_channel();
}
inline void ChannelLeaveRequest::set_channel(::mmorpg::ChatChannel value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChannelLeaveRequest.channel)
}
inline ::mmorpg::ChatChannel ChannelLeaveRequest::_internal_channel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::ChatChannel>(_impl_.channel_);
}
inline void ChannelLeaveRequest::_internal_set_channel(::mmorpg::ChatChannel value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_ = value;
}

// string channel_id = 3;
inline void ChannelLeaveRequest::clear_channel_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_id_.ClearToEmpty();
}
inline const std::string& ChannelLeaveRequest::channel_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelLeaveRequest.channel_id)
  return _internal_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChannelLeaveRequest::set_channel_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChannelLeaveRequest.channel_id)
}
inline std::string* ChannelLeaveRequest::mutable_channel_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_channel_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChannelLeaveRequest.channel_id)
  return _s;
}
inline const std::string& ChannelLeaveRequest::_internal_channel_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channel_id_.Get();
}
inline void ChannelLeaveRequest::_internal_set_channel_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_id_.Set(value, GetArena());
}
inline std::string* ChannelLeaveRequest::_internal_mutable_channel_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.channel_id_.Mutable( GetArena());
}
inline std::string* ChannelLeaveRequest::release_channel_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChannelLeaveRequest.channel_id)
  return _impl_.channel_id_.Release();
}
inline void ChannelLeaveRequest::set_allocated_channel_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.channel_id_.IsDefault()) {
          _impl_.channel_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChannelLeaveRequest.channel_id)
}

// -------------------------------------------------------------------

// ChannelLeaveResponse

// bool success = 1;
inline void ChannelLeaveResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool ChannelLeaveResponse::success() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelLeaveResponse.success)
  return _internal_success();
}
inline void ChannelLeaveResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChannelLeaveResponse.success)
}
inline bool ChannelLeaveResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void ChannelLeaveResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string message = 2;
inline void ChannelLeaveResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ChannelLeaveResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelLeaveResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChannelLeaveResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChannelLeaveResponse.message)
}
inline std::string* ChannelLeaveResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChannelLeaveResponse.message)
  return _s;
}
inline const std::string& ChannelLeaveResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void ChannelLeaveResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* ChannelLeaveResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* ChannelLeaveResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChannelLeaveResponse.message)
  return _impl_.message_.Release();
}
inline void ChannelLeaveResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChannelLeaveResponse.message)
}

// -------------------------------------------------------------------

// ChannelListRequest

// string player_id = 1;
inline void ChannelListRequest::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& ChannelListRequest::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelListRequest.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChannelListRequest::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChannelListRequest.player_id)
}
inline std::string* ChannelListRequest::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChannelListRequest.player_id)
  return _s;
}
inline const std::string& ChannelListRequest::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void ChannelListRequest::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* ChannelListRequest::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* ChannelListRequest::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChannelListRequest.player_id)
  return _impl_.player_id_.Release();
}
inline void ChannelListRequest::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChannelListRequest.player_id)
}

// .mmorpg.ChannelListType list_type = 2;
inline void ChannelListRequest::clear_list_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.list_type_ = 0;
}
inline ::mmorpg::ChannelListType ChannelListRequest::list_type() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelListRequest.list_type)
  return _internal_list_type();
}
inline void ChannelListRequest::set_list_type(::mmorpg::ChannelListType value) {
  _internal_set_list_type(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChannelListRequest.list_type)
}
inline ::mmorpg::ChannelListType ChannelListRequest::_internal_list_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::ChannelListType>(_impl_.list_type_);
}
inline void ChannelListRequest::_internal_set_list_type(::mmorpg::ChannelListType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.list_type_ = value;
}

// -------------------------------------------------------------------

// ChannelListResponse

// repeated .mmorpg.ChannelInfo channels = 1;
inline int ChannelListResponse::_internal_channels_size() const {
  return _internal_channels().size();
}
inline int ChannelListResponse::channels_size() const {
  return _internal_channels_size();
}
inline void ChannelListResponse::clear_channels() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channels_.Clear();
}
inline ::mmorpg::ChannelInfo* ChannelListResponse::mutable_channels(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.ChannelListResponse.channels)
  return _internal_mutable_channels()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::ChannelInfo>* ChannelListResponse::mutable_channels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.ChannelListResponse.channels)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_channels();
}
inline const ::mmorpg::ChannelInfo& ChannelListResponse::channels(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelListResponse.channels)
  return _internal_channels().Get(index);
}
inline ::mmorpg::ChannelInfo* ChannelListResponse::add_channels() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::mmorpg::ChannelInfo* _add = _internal_mutable_channels()->Add();
  // @@protoc_insertion_point(field_add:mmorpg.ChannelListResponse.channels)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::ChannelInfo>& ChannelListResponse::channels() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.ChannelListResponse.channels)
  return _internal_channels();
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::ChannelInfo>&
ChannelListResponse::_internal_channels() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channels_;
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::ChannelInfo>*
ChannelListResponse::_internal_mutable_channels() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.channels_;
}

// -------------------------------------------------------------------

// ChannelInfo

// .mmorpg.ChatChannel channel_type = 1;
inline void ChannelInfo::clear_channel_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_type_ = 0;
}
inline ::mmorpg::ChatChannel ChannelInfo::channel_type() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelInfo.channel_type)
  return _internal_channel_type();
}
inline void ChannelInfo::set_channel_type(::mmorpg::ChatChannel value) {
  _internal_set_channel_type(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChannelInfo.channel_type)
}
inline ::mmorpg::ChatChannel ChannelInfo::_internal_channel_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::ChatChannel>(_impl_.channel_type_);
}
inline void ChannelInfo::_internal_set_channel_type(::mmorpg::ChatChannel value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_type_ = value;
}

// string channel_id = 2;
inline void ChannelInfo::clear_channel_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_id_.ClearToEmpty();
}
inline const std::string& ChannelInfo::channel_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelInfo.channel_id)
  return _internal_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChannelInfo::set_channel_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChannelInfo.channel_id)
}
inline std::string* ChannelInfo::mutable_channel_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_channel_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChannelInfo.channel_id)
  return _s;
}
inline const std::string& ChannelInfo::_internal_channel_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channel_id_.Get();
}
inline void ChannelInfo::_internal_set_channel_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_id_.Set(value, GetArena());
}
inline std::string* ChannelInfo::_internal_mutable_channel_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.channel_id_.Mutable( GetArena());
}
inline std::string* ChannelInfo::release_channel_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChannelInfo.channel_id)
  return _impl_.channel_id_.Release();
}
inline void ChannelInfo::set_allocated_channel_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.channel_id_.IsDefault()) {
          _impl_.channel_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChannelInfo.channel_id)
}

// string channel_name = 3;
inline void ChannelInfo::clear_channel_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_name_.ClearToEmpty();
}
inline const std::string& ChannelInfo::channel_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelInfo.channel_name)
  return _internal_channel_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChannelInfo::set_channel_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChannelInfo.channel_name)
}
inline std::string* ChannelInfo::mutable_channel_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_channel_name();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChannelInfo.channel_name)
  return _s;
}
inline const std::string& ChannelInfo::_internal_channel_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channel_name_.Get();
}
inline void ChannelInfo::_internal_set_channel_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_name_.Set(value, GetArena());
}
inline std::string* ChannelInfo::_internal_mutable_channel_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.channel_name_.Mutable( GetArena());
}
inline std::string* ChannelInfo::release_channel_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChannelInfo.channel_name)
  return _impl_.channel_name_.Release();
}
inline void ChannelInfo::set_allocated_channel_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.channel_name_.IsDefault()) {
          _impl_.channel_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChannelInfo.channel_name)
}

// int32 member_count = 4;
inline void ChannelInfo::clear_member_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.member_count_ = 0;
}
inline ::int32_t ChannelInfo::member_count() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelInfo.member_count)
  return _internal_member_count();
}
inline void ChannelInfo::set_member_count(::int32_t value) {
  _internal_set_member_count(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChannelInfo.member_count)
}
inline ::int32_t ChannelInfo::_internal_member_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.member_count_;
}
inline void ChannelInfo::_internal_set_member_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.member_count_ = value;
}

// bool is_joined = 5;
inline void ChannelInfo::clear_is_joined() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_joined_ = false;
}
inline bool ChannelInfo::is_joined() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelInfo.is_joined)
  return _internal_is_joined();
}
inline void ChannelInfo::set_is_joined(bool value) {
  _internal_set_is_joined(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChannelInfo.is_joined)
}
inline bool ChannelInfo::_internal_is_joined() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_joined_;
}
inline void ChannelInfo::_internal_set_is_joined(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_joined_ = value;
}

// bool is_password_protected = 6;
inline void ChannelInfo::clear_is_password_protected() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_password_protected_ = false;
}
inline bool ChannelInfo::is_password_protected() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelInfo.is_password_protected)
  return _internal_is_password_protected();
}
inline void ChannelInfo::set_is_password_protected(bool value) {
  _internal_set_is_password_protected(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChannelInfo.is_password_protected)
}
inline bool ChannelInfo::_internal_is_password_protected() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_password_protected_;
}
inline void ChannelInfo::_internal_set_is_password_protected(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_password_protected_ = value;
}

// bool is_moderated = 7;
inline void ChannelInfo::clear_is_moderated() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_moderated_ = false;
}
inline bool ChannelInfo::is_moderated() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelInfo.is_moderated)
  return _internal_is_moderated();
}
inline void ChannelInfo::set_is_moderated(bool value) {
  _internal_set_is_moderated(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChannelInfo.is_moderated)
}
inline bool ChannelInfo::_internal_is_moderated() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_moderated_;
}
inline void ChannelInfo::_internal_set_is_moderated(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_moderated_ = value;
}

// string owner_id = 8;
inline void ChannelInfo::clear_owner_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.owner_id_.ClearToEmpty();
}
inline const std::string& ChannelInfo::owner_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelInfo.owner_id)
  return _internal_owner_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChannelInfo::set_owner_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.owner_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChannelInfo.owner_id)
}
inline std::string* ChannelInfo::mutable_owner_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_owner_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChannelInfo.owner_id)
  return _s;
}
inline const std::string& ChannelInfo::_internal_owner_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.owner_id_.Get();
}
inline void ChannelInfo::_internal_set_owner_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.owner_id_.Set(value, GetArena());
}
inline std::string* ChannelInfo::_internal_mutable_owner_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.owner_id_.Mutable( GetArena());
}
inline std::string* ChannelInfo::release_owner_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChannelInfo.owner_id)
  return _impl_.owner_id_.Release();
}
inline void ChannelInfo::set_allocated_owner_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.owner_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.owner_id_.IsDefault()) {
          _impl_.owner_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChannelInfo.owner_id)
}

// string description = 9;
inline void ChannelInfo::clear_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ChannelInfo::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelInfo.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChannelInfo::set_description(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChannelInfo.description)
}
inline std::string* ChannelInfo::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChannelInfo.description)
  return _s;
}
inline const std::string& ChannelInfo::_internal_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_.Get();
}
inline void ChannelInfo::_internal_set_description(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(value, GetArena());
}
inline std::string* ChannelInfo::_internal_mutable_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* ChannelInfo::release_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChannelInfo.description)
  return _impl_.description_.Release();
}
inline void ChannelInfo::set_allocated_description(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChannelInfo.description)
}

// -------------------------------------------------------------------

// ChannelMember

// string player_id = 1;
inline void ChannelMember::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& ChannelMember::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelMember.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChannelMember::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChannelMember.player_id)
}
inline std::string* ChannelMember::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChannelMember.player_id)
  return _s;
}
inline const std::string& ChannelMember::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void ChannelMember::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* ChannelMember::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* ChannelMember::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChannelMember.player_id)
  return _impl_.player_id_.Release();
}
inline void ChannelMember::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChannelMember.player_id)
}

// string player_name = 2;
inline void ChannelMember::clear_player_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_name_.ClearToEmpty();
}
inline const std::string& ChannelMember::player_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelMember.player_name)
  return _internal_player_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChannelMember::set_player_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChannelMember.player_name)
}
inline std::string* ChannelMember::mutable_player_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_name();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChannelMember.player_name)
  return _s;
}
inline const std::string& ChannelMember::_internal_player_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_name_.Get();
}
inline void ChannelMember::_internal_set_player_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_name_.Set(value, GetArena());
}
inline std::string* ChannelMember::_internal_mutable_player_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_name_.Mutable( GetArena());
}
inline std::string* ChannelMember::release_player_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChannelMember.player_name)
  return _impl_.player_name_.Release();
}
inline void ChannelMember::set_allocated_player_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_name_.IsDefault()) {
          _impl_.player_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChannelMember.player_name)
}

// .mmorpg.ChannelRole role = 3;
inline void ChannelMember::clear_role() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.role_ = 0;
}
inline ::mmorpg::ChannelRole ChannelMember::role() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelMember.role)
  return _internal_role();
}
inline void ChannelMember::set_role(::mmorpg::ChannelRole value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChannelMember.role)
}
inline ::mmorpg::ChannelRole ChannelMember::_internal_role() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::ChannelRole>(_impl_.role_);
}
inline void ChannelMember::_internal_set_role(::mmorpg::ChannelRole value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.role_ = value;
}

// bool is_muted = 4;
inline void ChannelMember::clear_is_muted() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_muted_ = false;
}
inline bool ChannelMember::is_muted() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelMember.is_muted)
  return _internal_is_muted();
}
inline void ChannelMember::set_is_muted(bool value) {
  _internal_set_is_muted(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChannelMember.is_muted)
}
inline bool ChannelMember::_internal_is_muted() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_muted_;
}
inline void ChannelMember::_internal_set_is_muted(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_muted_ = value;
}

// .google.protobuf.Timestamp joined_at = 5;
inline bool ChannelMember::has_joined_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.joined_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& ChannelMember::_internal_joined_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.joined_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& ChannelMember::joined_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChannelMember.joined_at)
  return _internal_joined_at();
}
inline void ChannelMember::unsafe_arena_set_allocated_joined_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.joined_at_);
  }
  _impl_.joined_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.ChannelMember.joined_at)
}
inline ::google::protobuf::Timestamp* ChannelMember::release_joined_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.joined_at_;
  _impl_.joined_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* ChannelMember::unsafe_arena_release_joined_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChannelMember.joined_at)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.joined_at_;
  _impl_.joined_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* ChannelMember::_internal_mutable_joined_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.joined_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.joined_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.joined_at_;
}
inline ::google::protobuf::Timestamp* ChannelMember::mutable_joined_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_joined_at();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChannelMember.joined_at)
  return _msg;
}
inline void ChannelMember::set_allocated_joined_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.joined_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.joined_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChannelMember.joined_at)
}

// -------------------------------------------------------------------

// ChatCommand

// string issuer_id = 1;
inline void ChatCommand::clear_issuer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.issuer_id_.ClearToEmpty();
}
inline const std::string& ChatCommand::issuer_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChatCommand.issuer_id)
  return _internal_issuer_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatCommand::set_issuer_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.issuer_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChatCommand.issuer_id)
}
inline std::string* ChatCommand::mutable_issuer_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_issuer_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChatCommand.issuer_id)
  return _s;
}
inline const std::string& ChatCommand::_internal_issuer_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.issuer_id_.Get();
}
inline void ChatCommand::_internal_set_issuer_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.issuer_id_.Set(value, GetArena());
}
inline std::string* ChatCommand::_internal_mutable_issuer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.issuer_id_.Mutable( GetArena());
}
inline std::string* ChatCommand::release_issuer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChatCommand.issuer_id)
  return _impl_.issuer_id_.Release();
}
inline void ChatCommand::set_allocated_issuer_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.issuer_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.issuer_id_.IsDefault()) {
          _impl_.issuer_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChatCommand.issuer_id)
}

// .mmorpg.ChatCommandType command_type = 2;
inline void ChatCommand::clear_command_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.command_type_ = 0;
}
inline ::mmorpg::ChatCommandType ChatCommand::command_type() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChatCommand.command_type)
  return _internal_command_type();
}
inline void ChatCommand::set_command_type(::mmorpg::ChatCommandType value) {
  _internal_set_command_type(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChatCommand.command_type)
}
inline ::mmorpg::ChatCommandType ChatCommand::_internal_command_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::ChatCommandType>(_impl_.command_type_);
}
inline void ChatCommand::_internal_set_command_type(::mmorpg::ChatCommandType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.command_type_ = value;
}

// string target_player_id = 3;
inline void ChatCommand::clear_target_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_player_id_.ClearToEmpty();
}
inline const std::string& ChatCommand::target_player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChatCommand.target_player_id)
  return _internal_target_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatCommand::set_target_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChatCommand.target_player_id)
}
inline std::string* ChatCommand::mutable_target_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_player_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChatCommand.target_player_id)
  return _s;
}
inline const std::string& ChatCommand::_internal_target_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_player_id_.Get();
}
inline void ChatCommand::_internal_set_target_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_player_id_.Set(value, GetArena());
}
inline std::string* ChatCommand::_internal_mutable_target_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.target_player_id_.Mutable( GetArena());
}
inline std::string* ChatCommand::release_target_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChatCommand.target_player_id)
  return _impl_.target_player_id_.Release();
}
inline void ChatCommand::set_allocated_target_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_player_id_.IsDefault()) {
          _impl_.target_player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChatCommand.target_player_id)
}

// .mmorpg.ChatChannel channel = 4;
inline void ChatCommand::clear_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_ = 0;
}
inline ::mmorpg::ChatChannel ChatCommand::channel() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChatCommand.channel)
  return _internal_channel();
}
inline void ChatCommand::set_channel(::mmorpg::ChatChannel value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChatCommand.channel)
}
inline ::mmorpg::ChatChannel ChatCommand::_internal_channel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::ChatChannel>(_impl_.channel_);
}
inline void ChatCommand::_internal_set_channel(::mmorpg::ChatChannel value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_ = value;
}

// string channel_id = 5;
inline void ChatCommand::clear_channel_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_id_.ClearToEmpty();
}
inline const std::string& ChatCommand::channel_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChatCommand.channel_id)
  return _internal_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatCommand::set_channel_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChatCommand.channel_id)
}
inline std::string* ChatCommand::mutable_channel_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_channel_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChatCommand.channel_id)
  return _s;
}
inline const std::string& ChatCommand::_internal_channel_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channel_id_.Get();
}
inline void ChatCommand::_internal_set_channel_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_id_.Set(value, GetArena());
}
inline std::string* ChatCommand::_internal_mutable_channel_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.channel_id_.Mutable( GetArena());
}
inline std::string* ChatCommand::release_channel_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChatCommand.channel_id)
  return _impl_.channel_id_.Release();
}
inline void ChatCommand::set_allocated_channel_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.channel_id_.IsDefault()) {
          _impl_.channel_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChatCommand.channel_id)
}

// int32 duration_minutes = 6;
inline void ChatCommand::clear_duration_minutes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.duration_minutes_ = 0;
}
inline ::int32_t ChatCommand::duration_minutes() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChatCommand.duration_minutes)
  return _internal_duration_minutes();
}
inline void ChatCommand::set_duration_minutes(::int32_t value) {
  _internal_set_duration_minutes(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChatCommand.duration_minutes)
}
inline ::int32_t ChatCommand::_internal_duration_minutes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.duration_minutes_;
}
inline void ChatCommand::_internal_set_duration_minutes(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.duration_minutes_ = value;
}

// string reason = 7;
inline void ChatCommand::clear_reason() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reason_.ClearToEmpty();
}
inline const std::string& ChatCommand::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChatCommand.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatCommand::set_reason(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChatCommand.reason)
}
inline std::string* ChatCommand::mutable_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChatCommand.reason)
  return _s;
}
inline const std::string& ChatCommand::_internal_reason() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reason_.Get();
}
inline void ChatCommand::_internal_set_reason(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reason_.Set(value, GetArena());
}
inline std::string* ChatCommand::_internal_mutable_reason() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.reason_.Mutable( GetArena());
}
inline std::string* ChatCommand::release_reason() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChatCommand.reason)
  return _impl_.reason_.Release();
}
inline void ChatCommand::set_allocated_reason(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reason_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reason_.IsDefault()) {
          _impl_.reason_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChatCommand.reason)
}

// -------------------------------------------------------------------

// ChatCommandResponse

// bool success = 1;
inline void ChatCommandResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool ChatCommandResponse::success() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChatCommandResponse.success)
  return _internal_success();
}
inline void ChatCommandResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChatCommandResponse.success)
}
inline bool ChatCommandResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void ChatCommandResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string message = 2;
inline void ChatCommandResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ChatCommandResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChatCommandResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatCommandResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChatCommandResponse.message)
}
inline std::string* ChatCommandResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChatCommandResponse.message)
  return _s;
}
inline const std::string& ChatCommandResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void ChatCommandResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* ChatCommandResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* ChatCommandResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChatCommandResponse.message)
  return _impl_.message_.Release();
}
inline void ChatCommandResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChatCommandResponse.message)
}

// .mmorpg.ErrorCode error_code = 3;
inline void ChatCommandResponse::clear_error_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_code_ = 0;
}
inline ::mmorpg::ErrorCode ChatCommandResponse::error_code() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChatCommandResponse.error_code)
  return _internal_error_code();
}
inline void ChatCommandResponse::set_error_code(::mmorpg::ErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChatCommandResponse.error_code)
}
inline ::mmorpg::ErrorCode ChatCommandResponse::_internal_error_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::ErrorCode>(_impl_.error_code_);
}
inline void ChatCommandResponse::_internal_set_error_code(::mmorpg::ErrorCode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_code_ = value;
}

// -------------------------------------------------------------------

// ChatHistoryRequest

// string player_id = 1;
inline void ChatHistoryRequest::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& ChatHistoryRequest::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChatHistoryRequest.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatHistoryRequest::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChatHistoryRequest.player_id)
}
inline std::string* ChatHistoryRequest::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChatHistoryRequest.player_id)
  return _s;
}
inline const std::string& ChatHistoryRequest::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void ChatHistoryRequest::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* ChatHistoryRequest::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* ChatHistoryRequest::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChatHistoryRequest.player_id)
  return _impl_.player_id_.Release();
}
inline void ChatHistoryRequest::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChatHistoryRequest.player_id)
}

// .mmorpg.ChatChannel channel = 2;
inline void ChatHistoryRequest::clear_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_ = 0;
}
inline ::mmorpg::ChatChannel ChatHistoryRequest::channel() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChatHistoryRequest.channel)
  return _internal_channel();
}
inline void ChatHistoryRequest::set_channel(::mmorpg::ChatChannel value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChatHistoryRequest.channel)
}
inline ::mmorpg::ChatChannel ChatHistoryRequest::_internal_channel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::ChatChannel>(_impl_.channel_);
}
inline void ChatHistoryRequest::_internal_set_channel(::mmorpg::ChatChannel value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_ = value;
}

// string channel_id = 3;
inline void ChatHistoryRequest::clear_channel_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_id_.ClearToEmpty();
}
inline const std::string& ChatHistoryRequest::channel_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChatHistoryRequest.channel_id)
  return _internal_channel_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatHistoryRequest::set_channel_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChatHistoryRequest.channel_id)
}
inline std::string* ChatHistoryRequest::mutable_channel_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_channel_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChatHistoryRequest.channel_id)
  return _s;
}
inline const std::string& ChatHistoryRequest::_internal_channel_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channel_id_.Get();
}
inline void ChatHistoryRequest::_internal_set_channel_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.channel_id_.Set(value, GetArena());
}
inline std::string* ChatHistoryRequest::_internal_mutable_channel_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.channel_id_.Mutable( GetArena());
}
inline std::string* ChatHistoryRequest::release_channel_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChatHistoryRequest.channel_id)
  return _impl_.channel_id_.Release();
}
inline void ChatHistoryRequest::set_allocated_channel_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.channel_id_.IsDefault()) {
          _impl_.channel_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChatHistoryRequest.channel_id)
}

// int32 message_count = 4;
inline void ChatHistoryRequest::clear_message_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_count_ = 0;
}
inline ::int32_t ChatHistoryRequest::message_count() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChatHistoryRequest.message_count)
  return _internal_message_count();
}
inline void ChatHistoryRequest::set_message_count(::int32_t value) {
  _internal_set_message_count(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChatHistoryRequest.message_count)
}
inline ::int32_t ChatHistoryRequest::_internal_message_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_count_;
}
inline void ChatHistoryRequest::_internal_set_message_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_count_ = value;
}

// string before_message_id = 5;
inline void ChatHistoryRequest::clear_before_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.before_message_id_.ClearToEmpty();
}
inline const std::string& ChatHistoryRequest::before_message_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChatHistoryRequest.before_message_id)
  return _internal_before_message_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatHistoryRequest::set_before_message_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.before_message_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChatHistoryRequest.before_message_id)
}
inline std::string* ChatHistoryRequest::mutable_before_message_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_before_message_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChatHistoryRequest.before_message_id)
  return _s;
}
inline const std::string& ChatHistoryRequest::_internal_before_message_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.before_message_id_.Get();
}
inline void ChatHistoryRequest::_internal_set_before_message_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.before_message_id_.Set(value, GetArena());
}
inline std::string* ChatHistoryRequest::_internal_mutable_before_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.before_message_id_.Mutable( GetArena());
}
inline std::string* ChatHistoryRequest::release_before_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChatHistoryRequest.before_message_id)
  return _impl_.before_message_id_.Release();
}
inline void ChatHistoryRequest::set_allocated_before_message_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.before_message_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.before_message_id_.IsDefault()) {
          _impl_.before_message_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChatHistoryRequest.before_message_id)
}

// -------------------------------------------------------------------

// ChatHistoryResponse

// repeated .mmorpg.ChatMessage messages = 1;
inline int ChatHistoryResponse::_internal_messages_size() const {
  return _internal_messages().size();
}
inline int ChatHistoryResponse::messages_size() const {
  return _internal_messages_size();
}
inline void ChatHistoryResponse::clear_messages() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.messages_.Clear();
}
inline ::mmorpg::ChatMessage* ChatHistoryResponse::mutable_messages(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.ChatHistoryResponse.messages)
  return _internal_mutable_messages()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::ChatMessage>* ChatHistoryResponse::mutable_messages()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.ChatHistoryResponse.messages)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_messages();
}
inline const ::mmorpg::ChatMessage& ChatHistoryResponse::messages(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChatHistoryResponse.messages)
  return _internal_messages().Get(index);
}
inline ::mmorpg::ChatMessage* ChatHistoryResponse::add_messages() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::mmorpg::ChatMessage* _add = _internal_mutable_messages()->Add();
  // @@protoc_insertion_point(field_add:mmorpg.ChatHistoryResponse.messages)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::ChatMessage>& ChatHistoryResponse::messages() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.ChatHistoryResponse.messages)
  return _internal_messages();
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::ChatMessage>&
ChatHistoryResponse::_internal_messages() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.messages_;
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::ChatMessage>*
ChatHistoryResponse::_internal_mutable_messages() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.messages_;
}

// bool has_more = 2;
inline void ChatHistoryResponse::clear_has_more() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.has_more_ = false;
}
inline bool ChatHistoryResponse::has_more() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChatHistoryResponse.has_more)
  return _internal_has_more();
}
inline void ChatHistoryResponse::set_has_more(bool value) {
  _internal_set_has_more(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChatHistoryResponse.has_more)
}
inline bool ChatHistoryResponse::_internal_has_more() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.has_more_;
}
inline void ChatHistoryResponse::_internal_set_has_more(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.has_more_ = value;
}

// -------------------------------------------------------------------

// ReportChatMessage

// string reporter_id = 1;
inline void ReportChatMessage::clear_reporter_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reporter_id_.ClearToEmpty();
}
inline const std::string& ReportChatMessage::reporter_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ReportChatMessage.reporter_id)
  return _internal_reporter_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReportChatMessage::set_reporter_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reporter_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ReportChatMessage.reporter_id)
}
inline std::string* ReportChatMessage::mutable_reporter_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reporter_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ReportChatMessage.reporter_id)
  return _s;
}
inline const std::string& ReportChatMessage::_internal_reporter_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reporter_id_.Get();
}
inline void ReportChatMessage::_internal_set_reporter_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reporter_id_.Set(value, GetArena());
}
inline std::string* ReportChatMessage::_internal_mutable_reporter_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.reporter_id_.Mutable( GetArena());
}
inline std::string* ReportChatMessage::release_reporter_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ReportChatMessage.reporter_id)
  return _impl_.reporter_id_.Release();
}
inline void ReportChatMessage::set_allocated_reporter_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reporter_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reporter_id_.IsDefault()) {
          _impl_.reporter_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ReportChatMessage.reporter_id)
}

// string message_id = 2;
inline void ReportChatMessage::clear_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_id_.ClearToEmpty();
}
inline const std::string& ReportChatMessage::message_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ReportChatMessage.message_id)
  return _internal_message_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReportChatMessage::set_message_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ReportChatMessage.message_id)
}
inline std::string* ReportChatMessage::mutable_message_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ReportChatMessage.message_id)
  return _s;
}
inline const std::string& ReportChatMessage::_internal_message_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_id_.Get();
}
inline void ReportChatMessage::_internal_set_message_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_id_.Set(value, GetArena());
}
inline std::string* ReportChatMessage::_internal_mutable_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_id_.Mutable( GetArena());
}
inline std::string* ReportChatMessage::release_message_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ReportChatMessage.message_id)
  return _impl_.message_id_.Release();
}
inline void ReportChatMessage::set_allocated_message_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_id_.IsDefault()) {
          _impl_.message_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ReportChatMessage.message_id)
}

// .mmorpg.ReportReason reason = 3;
inline void ReportChatMessage::clear_reason() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reason_ = 0;
}
inline ::mmorpg::ReportReason ReportChatMessage::reason() const {
  // @@protoc_insertion_point(field_get:mmorpg.ReportChatMessage.reason)
  return _internal_reason();
}
inline void ReportChatMessage::set_reason(::mmorpg::ReportReason value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:mmorpg.ReportChatMessage.reason)
}
inline ::mmorpg::ReportReason ReportChatMessage::_internal_reason() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::ReportReason>(_impl_.reason_);
}
inline void ReportChatMessage::_internal_set_reason(::mmorpg::ReportReason value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reason_ = value;
}

// string additional_info = 4;
inline void ReportChatMessage::clear_additional_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.additional_info_.ClearToEmpty();
}
inline const std::string& ReportChatMessage::additional_info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ReportChatMessage.additional_info)
  return _internal_additional_info();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReportChatMessage::set_additional_info(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.additional_info_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ReportChatMessage.additional_info)
}
inline std::string* ReportChatMessage::mutable_additional_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_additional_info();
  // @@protoc_insertion_point(field_mutable:mmorpg.ReportChatMessage.additional_info)
  return _s;
}
inline const std::string& ReportChatMessage::_internal_additional_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.additional_info_.Get();
}
inline void ReportChatMessage::_internal_set_additional_info(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.additional_info_.Set(value, GetArena());
}
inline std::string* ReportChatMessage::_internal_mutable_additional_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.additional_info_.Mutable( GetArena());
}
inline std::string* ReportChatMessage::release_additional_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ReportChatMessage.additional_info)
  return _impl_.additional_info_.Release();
}
inline void ReportChatMessage::set_allocated_additional_info(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.additional_info_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.additional_info_.IsDefault()) {
          _impl_.additional_info_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ReportChatMessage.additional_info)
}

// -------------------------------------------------------------------

// ReportChatResponse

// bool success = 1;
inline void ReportChatResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool ReportChatResponse::success() const {
  // @@protoc_insertion_point(field_get:mmorpg.ReportChatResponse.success)
  return _internal_success();
}
inline void ReportChatResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:mmorpg.ReportChatResponse.success)
}
inline bool ReportChatResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void ReportChatResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string report_id = 2;
inline void ReportChatResponse::clear_report_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.report_id_.ClearToEmpty();
}
inline const std::string& ReportChatResponse::report_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ReportChatResponse.report_id)
  return _internal_report_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReportChatResponse::set_report_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.report_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ReportChatResponse.report_id)
}
inline std::string* ReportChatResponse::mutable_report_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_report_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ReportChatResponse.report_id)
  return _s;
}
inline const std::string& ReportChatResponse::_internal_report_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.report_id_.Get();
}
inline void ReportChatResponse::_internal_set_report_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.report_id_.Set(value, GetArena());
}
inline std::string* ReportChatResponse::_internal_mutable_report_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.report_id_.Mutable( GetArena());
}
inline std::string* ReportChatResponse::release_report_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ReportChatResponse.report_id)
  return _impl_.report_id_.Release();
}
inline void ReportChatResponse::set_allocated_report_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.report_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.report_id_.IsDefault()) {
          _impl_.report_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ReportChatResponse.report_id)
}

// string message = 3;
inline void ReportChatResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ReportChatResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ReportChatResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReportChatResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ReportChatResponse.message)
}
inline std::string* ReportChatResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:mmorpg.ReportChatResponse.message)
  return _s;
}
inline const std::string& ReportChatResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void ReportChatResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* ReportChatResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* ReportChatResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ReportChatResponse.message)
  return _impl_.message_.Release();
}
inline void ReportChatResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ReportChatResponse.message)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace mmorpg


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::mmorpg::ChatChannel> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mmorpg::ChatChannel>() {
  return ::mmorpg::ChatChannel_descriptor();
}
template <>
struct is_proto_enum<::mmorpg::ChatMessageType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mmorpg::ChatMessageType>() {
  return ::mmorpg::ChatMessageType_descriptor();
}
template <>
struct is_proto_enum<::mmorpg::ChannelRole> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mmorpg::ChannelRole>() {
  return ::mmorpg::ChannelRole_descriptor();
}
template <>
struct is_proto_enum<::mmorpg::ChannelListType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mmorpg::ChannelListType>() {
  return ::mmorpg::ChannelListType_descriptor();
}
template <>
struct is_proto_enum<::mmorpg::ChatCommandType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mmorpg::ChatCommandType>() {
  return ::mmorpg::ChatCommandType_descriptor();
}
template <>
struct is_proto_enum<::mmorpg::ReportReason> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mmorpg::ReportReason>() {
  return ::mmorpg::ReportReason_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_chat_2eproto_2epb_2eh
