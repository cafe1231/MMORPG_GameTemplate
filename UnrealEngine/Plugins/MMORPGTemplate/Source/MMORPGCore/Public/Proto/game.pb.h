// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: game.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_game_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_game_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
#include "base.pb.h"
#include "character.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_game_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_game_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_game_2eproto;
namespace mmorpg {
class AchievementUnlocked;
struct AchievementUnlockedDefaultTypeInternal;
extern AchievementUnlockedDefaultTypeInternal _AchievementUnlocked_default_instance_;
class CombatAction;
struct CombatActionDefaultTypeInternal;
extern CombatActionDefaultTypeInternal _CombatAction_default_instance_;
class CombatEffect;
struct CombatEffectDefaultTypeInternal;
extern CombatEffectDefaultTypeInternal _CombatEffect_default_instance_;
class CombatResult;
struct CombatResultDefaultTypeInternal;
extern CombatResultDefaultTypeInternal _CombatResult_default_instance_;
class CurrencyUpdate;
struct CurrencyUpdateDefaultTypeInternal;
extern CurrencyUpdateDefaultTypeInternal _CurrencyUpdate_default_instance_;
class CurrencyUpdate_CurrenciesEntry_DoNotUse;
struct CurrencyUpdate_CurrenciesEntry_DoNotUseDefaultTypeInternal;
extern CurrencyUpdate_CurrenciesEntry_DoNotUseDefaultTypeInternal _CurrencyUpdate_CurrenciesEntry_DoNotUse_default_instance_;
class GameActionRequest;
struct GameActionRequestDefaultTypeInternal;
extern GameActionRequestDefaultTypeInternal _GameActionRequest_default_instance_;
class GameActionRequest_ParametersEntry_DoNotUse;
struct GameActionRequest_ParametersEntry_DoNotUseDefaultTypeInternal;
extern GameActionRequest_ParametersEntry_DoNotUseDefaultTypeInternal _GameActionRequest_ParametersEntry_DoNotUse_default_instance_;
class GameActionResponse;
struct GameActionResponseDefaultTypeInternal;
extern GameActionResponseDefaultTypeInternal _GameActionResponse_default_instance_;
class GameActionResponse_ResultsEntry_DoNotUse;
struct GameActionResponse_ResultsEntry_DoNotUseDefaultTypeInternal;
extern GameActionResponse_ResultsEntry_DoNotUseDefaultTypeInternal _GameActionResponse_ResultsEntry_DoNotUse_default_instance_;
class InventorySlot;
struct InventorySlotDefaultTypeInternal;
extern InventorySlotDefaultTypeInternal _InventorySlot_default_instance_;
class InventoryUpdate;
struct InventoryUpdateDefaultTypeInternal;
extern InventoryUpdateDefaultTypeInternal _InventoryUpdate_default_instance_;
class Item;
struct ItemDefaultTypeInternal;
extern ItemDefaultTypeInternal _Item_default_instance_;
class ItemEffect;
struct ItemEffectDefaultTypeInternal;
extern ItemEffectDefaultTypeInternal _ItemEffect_default_instance_;
class Item_StatsEntry_DoNotUse;
struct Item_StatsEntry_DoNotUseDefaultTypeInternal;
extern Item_StatsEntry_DoNotUseDefaultTypeInternal _Item_StatsEntry_DoNotUse_default_instance_;
class LootDropped;
struct LootDroppedDefaultTypeInternal;
extern LootDroppedDefaultTypeInternal _LootDropped_default_instance_;
class LootItem;
struct LootItemDefaultTypeInternal;
extern LootItemDefaultTypeInternal _LootItem_default_instance_;
class QuestInfo;
struct QuestInfoDefaultTypeInternal;
extern QuestInfoDefaultTypeInternal _QuestInfo_default_instance_;
class QuestObjective;
struct QuestObjectiveDefaultTypeInternal;
extern QuestObjectiveDefaultTypeInternal _QuestObjective_default_instance_;
class QuestReward;
struct QuestRewardDefaultTypeInternal;
extern QuestRewardDefaultTypeInternal _QuestReward_default_instance_;
class QuestUpdate;
struct QuestUpdateDefaultTypeInternal;
extern QuestUpdateDefaultTypeInternal _QuestUpdate_default_instance_;
class SkillUseRequest;
struct SkillUseRequestDefaultTypeInternal;
extern SkillUseRequestDefaultTypeInternal _SkillUseRequest_default_instance_;
class SkillUseResult;
struct SkillUseResultDefaultTypeInternal;
extern SkillUseResultDefaultTypeInternal _SkillUseResult_default_instance_;
class StatsUpdate;
struct StatsUpdateDefaultTypeInternal;
extern StatsUpdateDefaultTypeInternal _StatsUpdate_default_instance_;
class TradeItem;
struct TradeItemDefaultTypeInternal;
extern TradeItemDefaultTypeInternal _TradeItem_default_instance_;
class TradeOffer;
struct TradeOfferDefaultTypeInternal;
extern TradeOfferDefaultTypeInternal _TradeOffer_default_instance_;
class TradeRequest;
struct TradeRequestDefaultTypeInternal;
extern TradeRequestDefaultTypeInternal _TradeRequest_default_instance_;
class TradeUpdate;
struct TradeUpdateDefaultTypeInternal;
extern TradeUpdateDefaultTypeInternal _TradeUpdate_default_instance_;
}  // namespace mmorpg
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace mmorpg {
enum ActionType : int {
  ACTION_TYPE_UNSPECIFIED = 0,
  ACTION_TYPE_USE_ITEM = 1,
  ACTION_TYPE_USE_SKILL = 2,
  ACTION_TYPE_INTERACT = 3,
  ACTION_TYPE_LOOT = 4,
  ACTION_TYPE_TRADE = 5,
  ACTION_TYPE_CRAFT = 6,
  ACTION_TYPE_QUEST_ACCEPT = 7,
  ACTION_TYPE_QUEST_COMPLETE = 8,
  ACTION_TYPE_QUEST_ABANDON = 9,
  ActionType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ActionType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ActionType_IsValid(int value);
extern const uint32_t ActionType_internal_data_[];
constexpr ActionType ActionType_MIN = static_cast<ActionType>(0);
constexpr ActionType ActionType_MAX = static_cast<ActionType>(9);
constexpr int ActionType_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor*
ActionType_descriptor();
template <typename T>
const std::string& ActionType_Name(T value) {
  static_assert(std::is_same<T, ActionType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ActionType_Name().");
  return ActionType_Name(static_cast<ActionType>(value));
}
template <>
inline const std::string& ActionType_Name(ActionType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ActionType_descriptor,
                                                 0, 9>(
      static_cast<int>(value));
}
inline bool ActionType_Parse(absl::string_view name, ActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ActionType>(
      ActionType_descriptor(), name, value);
}
enum ItemRarity : int {
  ITEM_RARITY_UNSPECIFIED = 0,
  ITEM_RARITY_COMMON = 1,
  ITEM_RARITY_UNCOMMON = 2,
  ITEM_RARITY_RARE = 3,
  ITEM_RARITY_EPIC = 4,
  ITEM_RARITY_LEGENDARY = 5,
  ITEM_RARITY_ARTIFACT = 6,
  ItemRarity_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ItemRarity_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ItemRarity_IsValid(int value);
extern const uint32_t ItemRarity_internal_data_[];
constexpr ItemRarity ItemRarity_MIN = static_cast<ItemRarity>(0);
constexpr ItemRarity ItemRarity_MAX = static_cast<ItemRarity>(6);
constexpr int ItemRarity_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
ItemRarity_descriptor();
template <typename T>
const std::string& ItemRarity_Name(T value) {
  static_assert(std::is_same<T, ItemRarity>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ItemRarity_Name().");
  return ItemRarity_Name(static_cast<ItemRarity>(value));
}
template <>
inline const std::string& ItemRarity_Name(ItemRarity value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ItemRarity_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool ItemRarity_Parse(absl::string_view name, ItemRarity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ItemRarity>(
      ItemRarity_descriptor(), name, value);
}
enum QuestStatus : int {
  QUEST_STATUS_UNSPECIFIED = 0,
  QUEST_STATUS_AVAILABLE = 1,
  QUEST_STATUS_ACTIVE = 2,
  QUEST_STATUS_COMPLETED = 3,
  QUEST_STATUS_FAILED = 4,
  QUEST_STATUS_ABANDONED = 5,
  QuestStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  QuestStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool QuestStatus_IsValid(int value);
extern const uint32_t QuestStatus_internal_data_[];
constexpr QuestStatus QuestStatus_MIN = static_cast<QuestStatus>(0);
constexpr QuestStatus QuestStatus_MAX = static_cast<QuestStatus>(5);
constexpr int QuestStatus_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
QuestStatus_descriptor();
template <typename T>
const std::string& QuestStatus_Name(T value) {
  static_assert(std::is_same<T, QuestStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to QuestStatus_Name().");
  return QuestStatus_Name(static_cast<QuestStatus>(value));
}
template <>
inline const std::string& QuestStatus_Name(QuestStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<QuestStatus_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool QuestStatus_Parse(absl::string_view name, QuestStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<QuestStatus>(
      QuestStatus_descriptor(), name, value);
}
enum ObjectiveType : int {
  OBJECTIVE_TYPE_UNSPECIFIED = 0,
  OBJECTIVE_TYPE_KILL = 1,
  OBJECTIVE_TYPE_COLLECT = 2,
  OBJECTIVE_TYPE_INTERACT = 3,
  OBJECTIVE_TYPE_REACH_LOCATION = 4,
  OBJECTIVE_TYPE_TALK_TO = 5,
  OBJECTIVE_TYPE_DELIVER = 6,
  OBJECTIVE_TYPE_CRAFT = 7,
  OBJECTIVE_TYPE_USE_SKILL = 8,
  ObjectiveType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ObjectiveType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ObjectiveType_IsValid(int value);
extern const uint32_t ObjectiveType_internal_data_[];
constexpr ObjectiveType ObjectiveType_MIN = static_cast<ObjectiveType>(0);
constexpr ObjectiveType ObjectiveType_MAX = static_cast<ObjectiveType>(8);
constexpr int ObjectiveType_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
ObjectiveType_descriptor();
template <typename T>
const std::string& ObjectiveType_Name(T value) {
  static_assert(std::is_same<T, ObjectiveType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ObjectiveType_Name().");
  return ObjectiveType_Name(static_cast<ObjectiveType>(value));
}
template <>
inline const std::string& ObjectiveType_Name(ObjectiveType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ObjectiveType_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool ObjectiveType_Parse(absl::string_view name, ObjectiveType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjectiveType>(
      ObjectiveType_descriptor(), name, value);
}
enum RewardType : int {
  REWARD_TYPE_UNSPECIFIED = 0,
  REWARD_TYPE_EXPERIENCE = 1,
  REWARD_TYPE_GOLD = 2,
  REWARD_TYPE_ITEM = 3,
  REWARD_TYPE_REPUTATION = 4,
  REWARD_TYPE_SKILL_POINT = 5,
  REWARD_TYPE_ACHIEVEMENT = 6,
  RewardType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RewardType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RewardType_IsValid(int value);
extern const uint32_t RewardType_internal_data_[];
constexpr RewardType RewardType_MIN = static_cast<RewardType>(0);
constexpr RewardType RewardType_MAX = static_cast<RewardType>(6);
constexpr int RewardType_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
RewardType_descriptor();
template <typename T>
const std::string& RewardType_Name(T value) {
  static_assert(std::is_same<T, RewardType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RewardType_Name().");
  return RewardType_Name(static_cast<RewardType>(value));
}
template <>
inline const std::string& RewardType_Name(RewardType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RewardType_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool RewardType_Parse(absl::string_view name, RewardType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RewardType>(
      RewardType_descriptor(), name, value);
}
enum CombatActionType : int {
  COMBAT_ACTION_UNSPECIFIED = 0,
  COMBAT_ACTION_BASIC_ATTACK = 1,
  COMBAT_ACTION_SKILL = 2,
  COMBAT_ACTION_ITEM = 3,
  COMBAT_ACTION_DEFEND = 4,
  CombatActionType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CombatActionType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CombatActionType_IsValid(int value);
extern const uint32_t CombatActionType_internal_data_[];
constexpr CombatActionType CombatActionType_MIN = static_cast<CombatActionType>(0);
constexpr CombatActionType CombatActionType_MAX = static_cast<CombatActionType>(4);
constexpr int CombatActionType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
CombatActionType_descriptor();
template <typename T>
const std::string& CombatActionType_Name(T value) {
  static_assert(std::is_same<T, CombatActionType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CombatActionType_Name().");
  return CombatActionType_Name(static_cast<CombatActionType>(value));
}
template <>
inline const std::string& CombatActionType_Name(CombatActionType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CombatActionType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool CombatActionType_Parse(absl::string_view name, CombatActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CombatActionType>(
      CombatActionType_descriptor(), name, value);
}
enum CombatEffectType : int {
  COMBAT_EFFECT_UNSPECIFIED = 0,
  COMBAT_EFFECT_DAMAGE = 1,
  COMBAT_EFFECT_HEAL = 2,
  COMBAT_EFFECT_BUFF = 3,
  COMBAT_EFFECT_DEBUFF = 4,
  COMBAT_EFFECT_DOT = 5,
  COMBAT_EFFECT_HOT = 6,
  COMBAT_EFFECT_STUN = 7,
  COMBAT_EFFECT_SLOW = 8,
  COMBAT_EFFECT_ROOT = 9,
  COMBAT_EFFECT_SILENCE = 10,
  CombatEffectType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CombatEffectType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CombatEffectType_IsValid(int value);
extern const uint32_t CombatEffectType_internal_data_[];
constexpr CombatEffectType CombatEffectType_MIN = static_cast<CombatEffectType>(0);
constexpr CombatEffectType CombatEffectType_MAX = static_cast<CombatEffectType>(10);
constexpr int CombatEffectType_ARRAYSIZE = 10 + 1;
const ::google::protobuf::EnumDescriptor*
CombatEffectType_descriptor();
template <typename T>
const std::string& CombatEffectType_Name(T value) {
  static_assert(std::is_same<T, CombatEffectType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CombatEffectType_Name().");
  return CombatEffectType_Name(static_cast<CombatEffectType>(value));
}
template <>
inline const std::string& CombatEffectType_Name(CombatEffectType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CombatEffectType_descriptor,
                                                 0, 10>(
      static_cast<int>(value));
}
inline bool CombatEffectType_Parse(absl::string_view name, CombatEffectType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CombatEffectType>(
      CombatEffectType_descriptor(), name, value);
}
enum TradeState : int {
  TRADE_STATE_UNSPECIFIED = 0,
  TRADE_STATE_PENDING = 1,
  TRADE_STATE_ACTIVE = 2,
  TRADE_STATE_COMPLETED = 3,
  TRADE_STATE_CANCELLED = 4,
  TradeState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TradeState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TradeState_IsValid(int value);
extern const uint32_t TradeState_internal_data_[];
constexpr TradeState TradeState_MIN = static_cast<TradeState>(0);
constexpr TradeState TradeState_MAX = static_cast<TradeState>(4);
constexpr int TradeState_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
TradeState_descriptor();
template <typename T>
const std::string& TradeState_Name(T value) {
  static_assert(std::is_same<T, TradeState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TradeState_Name().");
  return TradeState_Name(static_cast<TradeState>(value));
}
template <>
inline const std::string& TradeState_Name(TradeState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TradeState_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool TradeState_Parse(absl::string_view name, TradeState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TradeState>(
      TradeState_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class TradeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.TradeRequest) */ {
 public:
  inline TradeRequest() : TradeRequest(nullptr) {}
  ~TradeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TradeRequest(::google::protobuf::internal::ConstantInitialized);

  inline TradeRequest(const TradeRequest& from)
      : TradeRequest(nullptr, from) {}
  TradeRequest(TradeRequest&& from) noexcept
    : TradeRequest() {
    *this = ::std::move(from);
  }

  inline TradeRequest& operator=(const TradeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradeRequest& operator=(TradeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradeRequest* internal_default_instance() {
    return reinterpret_cast<const TradeRequest*>(
               &_TradeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TradeRequest& a, TradeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TradeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TradeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TradeRequest& from) {
    TradeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TradeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.TradeRequest";
  }
  protected:
  explicit TradeRequest(::google::protobuf::Arena* arena);
  TradeRequest(::google::protobuf::Arena* arena, const TradeRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitiatorIdFieldNumber = 1,
    kTargetPlayerIdFieldNumber = 2,
  };
  // string initiator_id = 1;
  void clear_initiator_id() ;
  const std::string& initiator_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_initiator_id(Arg_&& arg, Args_... args);
  std::string* mutable_initiator_id();
  PROTOBUF_NODISCARD std::string* release_initiator_id();
  void set_allocated_initiator_id(std::string* value);

  private:
  const std::string& _internal_initiator_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initiator_id(
      const std::string& value);
  std::string* _internal_mutable_initiator_id();

  public:
  // string target_player_id = 2;
  void clear_target_player_id() ;
  const std::string& target_player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_target_player_id();
  PROTOBUF_NODISCARD std::string* release_target_player_id();
  void set_allocated_target_player_id(std::string* value);

  private:
  const std::string& _internal_target_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_player_id(
      const std::string& value);
  std::string* _internal_mutable_target_player_id();

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.TradeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      56, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr initiator_id_;
    ::google::protobuf::internal::ArenaStringPtr target_player_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};// -------------------------------------------------------------------

class TradeItem final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.TradeItem) */ {
 public:
  inline TradeItem() : TradeItem(nullptr) {}
  ~TradeItem() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TradeItem(::google::protobuf::internal::ConstantInitialized);

  inline TradeItem(const TradeItem& from)
      : TradeItem(nullptr, from) {}
  TradeItem(TradeItem&& from) noexcept
    : TradeItem() {
    *this = ::std::move(from);
  }

  inline TradeItem& operator=(const TradeItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradeItem& operator=(TradeItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradeItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradeItem* internal_default_instance() {
    return reinterpret_cast<const TradeItem*>(
               &_TradeItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(TradeItem& a, TradeItem& b) {
    a.Swap(&b);
  }
  inline void Swap(TradeItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradeItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradeItem* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradeItem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TradeItem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TradeItem& from) {
    TradeItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TradeItem* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.TradeItem";
  }
  protected:
  explicit TradeItem(::google::protobuf::Arena* arena);
  TradeItem(::google::protobuf::Arena* arena, const TradeItem& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kQuantityFieldNumber = 2,
    kInventorySlotFieldNumber = 3,
  };
  // string item_id = 1;
  void clear_item_id() ;
  const std::string& item_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_item_id(Arg_&& arg, Args_... args);
  std::string* mutable_item_id();
  PROTOBUF_NODISCARD std::string* release_item_id();
  void set_allocated_item_id(std::string* value);

  private:
  const std::string& _internal_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(
      const std::string& value);
  std::string* _internal_mutable_item_id();

  public:
  // int32 quantity = 2;
  void clear_quantity() ;
  ::int32_t quantity() const;
  void set_quantity(::int32_t value);

  private:
  ::int32_t _internal_quantity() const;
  void _internal_set_quantity(::int32_t value);

  public:
  // int32 inventory_slot = 3;
  void clear_inventory_slot() ;
  ::int32_t inventory_slot() const;
  void set_inventory_slot(::int32_t value);

  private:
  ::int32_t _internal_inventory_slot() const;
  void _internal_set_inventory_slot(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.TradeItem)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      32, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr item_id_;
    ::int32_t quantity_;
    ::int32_t inventory_slot_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};// -------------------------------------------------------------------

class QuestReward final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.QuestReward) */ {
 public:
  inline QuestReward() : QuestReward(nullptr) {}
  ~QuestReward() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuestReward(::google::protobuf::internal::ConstantInitialized);

  inline QuestReward(const QuestReward& from)
      : QuestReward(nullptr, from) {}
  QuestReward(QuestReward&& from) noexcept
    : QuestReward() {
    *this = ::std::move(from);
  }

  inline QuestReward& operator=(const QuestReward& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuestReward& operator=(QuestReward&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuestReward& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuestReward* internal_default_instance() {
    return reinterpret_cast<const QuestReward*>(
               &_QuestReward_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(QuestReward& a, QuestReward& b) {
    a.Swap(&b);
  }
  inline void Swap(QuestReward* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuestReward* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuestReward* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuestReward>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QuestReward& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const QuestReward& from) {
    QuestReward::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QuestReward* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.QuestReward";
  }
  protected:
  explicit QuestReward(::google::protobuf::Arena* arena);
  QuestReward(::google::protobuf::Arena* arena, const QuestReward& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRewardIdFieldNumber = 2,
    kTypeFieldNumber = 1,
    kQuantityFieldNumber = 3,
  };
  // string reward_id = 2;
  void clear_reward_id() ;
  const std::string& reward_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reward_id(Arg_&& arg, Args_... args);
  std::string* mutable_reward_id();
  PROTOBUF_NODISCARD std::string* release_reward_id();
  void set_allocated_reward_id(std::string* value);

  private:
  const std::string& _internal_reward_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reward_id(
      const std::string& value);
  std::string* _internal_mutable_reward_id();

  public:
  // .mmorpg.RewardType type = 1;
  void clear_type() ;
  ::mmorpg::RewardType type() const;
  void set_type(::mmorpg::RewardType value);

  private:
  ::mmorpg::RewardType _internal_type() const;
  void _internal_set_type(::mmorpg::RewardType value);

  public:
  // int32 quantity = 3;
  void clear_quantity() ;
  ::int32_t quantity() const;
  void set_quantity(::int32_t value);

  private:
  ::int32_t _internal_quantity() const;
  void _internal_set_quantity(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.QuestReward)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      36, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr reward_id_;
    int type_;
    ::int32_t quantity_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};// -------------------------------------------------------------------

class QuestObjective final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.QuestObjective) */ {
 public:
  inline QuestObjective() : QuestObjective(nullptr) {}
  ~QuestObjective() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuestObjective(::google::protobuf::internal::ConstantInitialized);

  inline QuestObjective(const QuestObjective& from)
      : QuestObjective(nullptr, from) {}
  QuestObjective(QuestObjective&& from) noexcept
    : QuestObjective() {
    *this = ::std::move(from);
  }

  inline QuestObjective& operator=(const QuestObjective& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuestObjective& operator=(QuestObjective&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuestObjective& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuestObjective* internal_default_instance() {
    return reinterpret_cast<const QuestObjective*>(
               &_QuestObjective_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(QuestObjective& a, QuestObjective& b) {
    a.Swap(&b);
  }
  inline void Swap(QuestObjective* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuestObjective* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuestObjective* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuestObjective>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QuestObjective& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const QuestObjective& from) {
    QuestObjective::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QuestObjective* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.QuestObjective";
  }
  protected:
  explicit QuestObjective(::google::protobuf::Arena* arena);
  QuestObjective(::google::protobuf::Arena* arena, const QuestObjective& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectiveIdFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kTargetIdFieldNumber = 4,
    kTypeFieldNumber = 3,
    kCurrentProgressFieldNumber = 5,
    kRequiredProgressFieldNumber = 6,
    kIsCompletedFieldNumber = 7,
    kIsOptionalFieldNumber = 8,
  };
  // string objective_id = 1;
  void clear_objective_id() ;
  const std::string& objective_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_objective_id(Arg_&& arg, Args_... args);
  std::string* mutable_objective_id();
  PROTOBUF_NODISCARD std::string* release_objective_id();
  void set_allocated_objective_id(std::string* value);

  private:
  const std::string& _internal_objective_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_objective_id(
      const std::string& value);
  std::string* _internal_mutable_objective_id();

  public:
  // string description = 2;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string target_id = 4;
  void clear_target_id() ;
  const std::string& target_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_id(Arg_&& arg, Args_... args);
  std::string* mutable_target_id();
  PROTOBUF_NODISCARD std::string* release_target_id();
  void set_allocated_target_id(std::string* value);

  private:
  const std::string& _internal_target_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_id(
      const std::string& value);
  std::string* _internal_mutable_target_id();

  public:
  // .mmorpg.ObjectiveType type = 3;
  void clear_type() ;
  ::mmorpg::ObjectiveType type() const;
  void set_type(::mmorpg::ObjectiveType value);

  private:
  ::mmorpg::ObjectiveType _internal_type() const;
  void _internal_set_type(::mmorpg::ObjectiveType value);

  public:
  // int32 current_progress = 5;
  void clear_current_progress() ;
  ::int32_t current_progress() const;
  void set_current_progress(::int32_t value);

  private:
  ::int32_t _internal_current_progress() const;
  void _internal_set_current_progress(::int32_t value);

  public:
  // int32 required_progress = 6;
  void clear_required_progress() ;
  ::int32_t required_progress() const;
  void set_required_progress(::int32_t value);

  private:
  ::int32_t _internal_required_progress() const;
  void _internal_set_required_progress(::int32_t value);

  public:
  // bool is_completed = 7;
  void clear_is_completed() ;
  bool is_completed() const;
  void set_is_completed(bool value);

  private:
  bool _internal_is_completed() const;
  void _internal_set_is_completed(bool value);

  public:
  // bool is_optional = 8;
  void clear_is_optional() ;
  bool is_optional() const;
  void set_is_optional(bool value);

  private:
  bool _internal_is_optional() const;
  void _internal_set_is_optional(bool value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.QuestObjective)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 0,
      70, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr objective_id_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::internal::ArenaStringPtr target_id_;
    int type_;
    ::int32_t current_progress_;
    ::int32_t required_progress_;
    bool is_completed_;
    bool is_optional_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};// -------------------------------------------------------------------

class ItemEffect final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.ItemEffect) */ {
 public:
  inline ItemEffect() : ItemEffect(nullptr) {}
  ~ItemEffect() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ItemEffect(::google::protobuf::internal::ConstantInitialized);

  inline ItemEffect(const ItemEffect& from)
      : ItemEffect(nullptr, from) {}
  ItemEffect(ItemEffect&& from) noexcept
    : ItemEffect() {
    *this = ::std::move(from);
  }

  inline ItemEffect& operator=(const ItemEffect& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemEffect& operator=(ItemEffect&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemEffect& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemEffect* internal_default_instance() {
    return reinterpret_cast<const ItemEffect*>(
               &_ItemEffect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ItemEffect& a, ItemEffect& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemEffect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemEffect* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemEffect* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemEffect>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ItemEffect& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ItemEffect& from) {
    ItemEffect::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ItemEffect* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.ItemEffect";
  }
  protected:
  explicit ItemEffect(::google::protobuf::Arena* arena);
  ItemEffect(::google::protobuf::Arena* arena, const ItemEffect& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEffectTypeFieldNumber = 1,
    kValueFieldNumber = 2,
    kDurationFieldNumber = 3,
    kChanceFieldNumber = 4,
  };
  // string effect_type = 1;
  void clear_effect_type() ;
  const std::string& effect_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_effect_type(Arg_&& arg, Args_... args);
  std::string* mutable_effect_type();
  PROTOBUF_NODISCARD std::string* release_effect_type();
  void set_allocated_effect_type(std::string* value);

  private:
  const std::string& _internal_effect_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_effect_type(
      const std::string& value);
  std::string* _internal_mutable_effect_type();

  public:
  // int32 value = 2;
  void clear_value() ;
  ::int32_t value() const;
  void set_value(::int32_t value);

  private:
  ::int32_t _internal_value() const;
  void _internal_set_value(::int32_t value);

  public:
  // float duration = 3;
  void clear_duration() ;
  float duration() const;
  void set_duration(float value);

  private:
  float _internal_duration() const;
  void _internal_set_duration(float value);

  public:
  // float chance = 4;
  void clear_chance() ;
  float chance() const;
  void set_chance(float value);

  private:
  float _internal_chance() const;
  void _internal_set_chance(float value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.ItemEffect)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      37, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr effect_type_;
    ::int32_t value_;
    float duration_;
    float chance_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};// -------------------------------------------------------------------

class Item_StatsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          Item_StatsEntry_DoNotUse, std::string, ::int32_t,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_INT32> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      Item_StatsEntry_DoNotUse, std::string, ::int32_t,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>;
  Item_StatsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Item_StatsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit Item_StatsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const Item_StatsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const Item_StatsEntry_DoNotUse*>(
        &_Item_StatsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "mmorpg.Item.StatsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class GameActionResponse_ResultsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          GameActionResponse_ResultsEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      GameActionResponse_ResultsEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  GameActionResponse_ResultsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GameActionResponse_ResultsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit GameActionResponse_ResultsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const GameActionResponse_ResultsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const GameActionResponse_ResultsEntry_DoNotUse*>(
        &_GameActionResponse_ResultsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "mmorpg.GameActionResponse.ResultsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "mmorpg.GameActionResponse.ResultsEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class GameActionRequest_ParametersEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          GameActionRequest_ParametersEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      GameActionRequest_ParametersEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  GameActionRequest_ParametersEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GameActionRequest_ParametersEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit GameActionRequest_ParametersEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const GameActionRequest_ParametersEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const GameActionRequest_ParametersEntry_DoNotUse*>(
        &_GameActionRequest_ParametersEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "mmorpg.GameActionRequest.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "mmorpg.GameActionRequest.ParametersEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class CurrencyUpdate_CurrenciesEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          CurrencyUpdate_CurrenciesEntry_DoNotUse, std::string, ::int64_t,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_INT64> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      CurrencyUpdate_CurrenciesEntry_DoNotUse, std::string, ::int64_t,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT64>;
  CurrencyUpdate_CurrenciesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CurrencyUpdate_CurrenciesEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit CurrencyUpdate_CurrenciesEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const CurrencyUpdate_CurrenciesEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const CurrencyUpdate_CurrenciesEntry_DoNotUse*>(
        &_CurrencyUpdate_CurrenciesEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "mmorpg.CurrencyUpdate.CurrenciesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class CombatEffect final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.CombatEffect) */ {
 public:
  inline CombatEffect() : CombatEffect(nullptr) {}
  ~CombatEffect() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CombatEffect(::google::protobuf::internal::ConstantInitialized);

  inline CombatEffect(const CombatEffect& from)
      : CombatEffect(nullptr, from) {}
  CombatEffect(CombatEffect&& from) noexcept
    : CombatEffect() {
    *this = ::std::move(from);
  }

  inline CombatEffect& operator=(const CombatEffect& from) {
    CopyFrom(from);
    return *this;
  }
  inline CombatEffect& operator=(CombatEffect&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CombatEffect& default_instance() {
    return *internal_default_instance();
  }
  static inline const CombatEffect* internal_default_instance() {
    return reinterpret_cast<const CombatEffect*>(
               &_CombatEffect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CombatEffect& a, CombatEffect& b) {
    a.Swap(&b);
  }
  inline void Swap(CombatEffect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CombatEffect* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CombatEffect* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CombatEffect>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CombatEffect& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CombatEffect& from) {
    CombatEffect::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CombatEffect* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.CombatEffect";
  }
  protected:
  explicit CombatEffect(::google::protobuf::Arena* arena);
  CombatEffect(::google::protobuf::Arena* arena, const CombatEffect& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetIdFieldNumber = 1,
    kEffectTypeFieldNumber = 2,
    kValueFieldNumber = 3,
    kIsCriticalFieldNumber = 4,
    kIsBlockedFieldNumber = 5,
    kIsDodgedFieldNumber = 6,
    kIsResistedFieldNumber = 7,
  };
  // string target_id = 1;
  void clear_target_id() ;
  const std::string& target_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_id(Arg_&& arg, Args_... args);
  std::string* mutable_target_id();
  PROTOBUF_NODISCARD std::string* release_target_id();
  void set_allocated_target_id(std::string* value);

  private:
  const std::string& _internal_target_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_id(
      const std::string& value);
  std::string* _internal_mutable_target_id();

  public:
  // .mmorpg.CombatEffectType effect_type = 2;
  void clear_effect_type() ;
  ::mmorpg::CombatEffectType effect_type() const;
  void set_effect_type(::mmorpg::CombatEffectType value);

  private:
  ::mmorpg::CombatEffectType _internal_effect_type() const;
  void _internal_set_effect_type(::mmorpg::CombatEffectType value);

  public:
  // int32 value = 3;
  void clear_value() ;
  ::int32_t value() const;
  void set_value(::int32_t value);

  private:
  ::int32_t _internal_value() const;
  void _internal_set_value(::int32_t value);

  public:
  // bool is_critical = 4;
  void clear_is_critical() ;
  bool is_critical() const;
  void set_is_critical(bool value);

  private:
  bool _internal_is_critical() const;
  void _internal_set_is_critical(bool value);

  public:
  // bool is_blocked = 5;
  void clear_is_blocked() ;
  bool is_blocked() const;
  void set_is_blocked(bool value);

  private:
  bool _internal_is_blocked() const;
  void _internal_set_is_blocked(bool value);

  public:
  // bool is_dodged = 6;
  void clear_is_dodged() ;
  bool is_dodged() const;
  void set_is_dodged(bool value);

  private:
  bool _internal_is_dodged() const;
  void _internal_set_is_dodged(bool value);

  public:
  // bool is_resisted = 7;
  void clear_is_resisted() ;
  bool is_resisted() const;
  void set_is_resisted(bool value);

  private:
  bool _internal_is_resisted() const;
  void _internal_set_is_resisted(bool value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.CombatEffect)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      37, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr target_id_;
    int effect_type_;
    ::int32_t value_;
    bool is_critical_;
    bool is_blocked_;
    bool is_dodged_;
    bool is_resisted_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};// -------------------------------------------------------------------

class TradeOffer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.TradeOffer) */ {
 public:
  inline TradeOffer() : TradeOffer(nullptr) {}
  ~TradeOffer() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TradeOffer(::google::protobuf::internal::ConstantInitialized);

  inline TradeOffer(const TradeOffer& from)
      : TradeOffer(nullptr, from) {}
  TradeOffer(TradeOffer&& from) noexcept
    : TradeOffer() {
    *this = ::std::move(from);
  }

  inline TradeOffer& operator=(const TradeOffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradeOffer& operator=(TradeOffer&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradeOffer& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradeOffer* internal_default_instance() {
    return reinterpret_cast<const TradeOffer*>(
               &_TradeOffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(TradeOffer& a, TradeOffer& b) {
    a.Swap(&b);
  }
  inline void Swap(TradeOffer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradeOffer* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradeOffer* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradeOffer>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TradeOffer& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TradeOffer& from) {
    TradeOffer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TradeOffer* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.TradeOffer";
  }
  protected:
  explicit TradeOffer(::google::protobuf::Arena* arena);
  TradeOffer(::google::protobuf::Arena* arena, const TradeOffer& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
    kGoldFieldNumber = 3,
    kLockedFieldNumber = 4,
    kAcceptedFieldNumber = 5,
  };
  // repeated .mmorpg.TradeItem items = 2;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::mmorpg::TradeItem* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::mmorpg::TradeItem >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::mmorpg::TradeItem>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::mmorpg::TradeItem>* _internal_mutable_items();
  public:
  const ::mmorpg::TradeItem& items(int index) const;
  ::mmorpg::TradeItem* add_items();
  const ::google::protobuf::RepeatedPtrField< ::mmorpg::TradeItem >&
      items() const;
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // int64 gold = 3;
  void clear_gold() ;
  ::int64_t gold() const;
  void set_gold(::int64_t value);

  private:
  ::int64_t _internal_gold() const;
  void _internal_set_gold(::int64_t value);

  public:
  // bool locked = 4;
  void clear_locked() ;
  bool locked() const;
  void set_locked(bool value);

  private:
  bool _internal_locked() const;
  void _internal_set_locked(bool value);

  public:
  // bool accepted = 5;
  void clear_accepted() ;
  bool accepted() const;
  void set_accepted(bool value);

  private:
  bool _internal_accepted() const;
  void _internal_set_accepted(bool value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.TradeOffer)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      35, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::mmorpg::TradeItem > items_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::int64_t gold_;
    bool locked_;
    bool accepted_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};// -------------------------------------------------------------------

class StatsUpdate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.StatsUpdate) */ {
 public:
  inline StatsUpdate() : StatsUpdate(nullptr) {}
  ~StatsUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StatsUpdate(::google::protobuf::internal::ConstantInitialized);

  inline StatsUpdate(const StatsUpdate& from)
      : StatsUpdate(nullptr, from) {}
  StatsUpdate(StatsUpdate&& from) noexcept
    : StatsUpdate() {
    *this = ::std::move(from);
  }

  inline StatsUpdate& operator=(const StatsUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatsUpdate& operator=(StatsUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatsUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatsUpdate* internal_default_instance() {
    return reinterpret_cast<const StatsUpdate*>(
               &_StatsUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StatsUpdate& a, StatsUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(StatsUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatsUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatsUpdate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatsUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StatsUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StatsUpdate& from) {
    StatsUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StatsUpdate* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.StatsUpdate";
  }
  protected:
  explicit StatsUpdate(::google::protobuf::Arena* arena);
  StatsUpdate(::google::protobuf::Arena* arena, const StatsUpdate& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kStatsFieldNumber = 2,
    kAttributesFieldNumber = 3,
    kExperienceFieldNumber = 5,
    kExperienceToNextLevelFieldNumber = 6,
    kLevelFieldNumber = 4,
  };
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // .mmorpg.CharacterStats stats = 2;
  bool has_stats() const;
  void clear_stats() ;
  const ::mmorpg::CharacterStats& stats() const;
  PROTOBUF_NODISCARD ::mmorpg::CharacterStats* release_stats();
  ::mmorpg::CharacterStats* mutable_stats();
  void set_allocated_stats(::mmorpg::CharacterStats* value);
  void unsafe_arena_set_allocated_stats(::mmorpg::CharacterStats* value);
  ::mmorpg::CharacterStats* unsafe_arena_release_stats();

  private:
  const ::mmorpg::CharacterStats& _internal_stats() const;
  ::mmorpg::CharacterStats* _internal_mutable_stats();

  public:
  // .mmorpg.CharacterAttributes attributes = 3;
  bool has_attributes() const;
  void clear_attributes() ;
  const ::mmorpg::CharacterAttributes& attributes() const;
  PROTOBUF_NODISCARD ::mmorpg::CharacterAttributes* release_attributes();
  ::mmorpg::CharacterAttributes* mutable_attributes();
  void set_allocated_attributes(::mmorpg::CharacterAttributes* value);
  void unsafe_arena_set_allocated_attributes(::mmorpg::CharacterAttributes* value);
  ::mmorpg::CharacterAttributes* unsafe_arena_release_attributes();

  private:
  const ::mmorpg::CharacterAttributes& _internal_attributes() const;
  ::mmorpg::CharacterAttributes* _internal_mutable_attributes();

  public:
  // int64 experience = 5;
  void clear_experience() ;
  ::int64_t experience() const;
  void set_experience(::int64_t value);

  private:
  ::int64_t _internal_experience() const;
  void _internal_set_experience(::int64_t value);

  public:
  // int64 experience_to_next_level = 6;
  void clear_experience_to_next_level() ;
  ::int64_t experience_to_next_level() const;
  void set_experience_to_next_level(::int64_t value);

  private:
  ::int64_t _internal_experience_to_next_level() const;
  void _internal_set_experience_to_next_level(::int64_t value);

  public:
  // int32 level = 4;
  void clear_level() ;
  ::int32_t level() const;
  void set_level(::int32_t value);

  private:
  ::int32_t _internal_level() const;
  void _internal_set_level(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.StatsUpdate)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      36, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::mmorpg::CharacterStats* stats_;
    ::mmorpg::CharacterAttributes* attributes_;
    ::int64_t experience_;
    ::int64_t experience_to_next_level_;
    ::int32_t level_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};// -------------------------------------------------------------------

class SkillUseResult final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.SkillUseResult) */ {
 public:
  inline SkillUseResult() : SkillUseResult(nullptr) {}
  ~SkillUseResult() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SkillUseResult(::google::protobuf::internal::ConstantInitialized);

  inline SkillUseResult(const SkillUseResult& from)
      : SkillUseResult(nullptr, from) {}
  SkillUseResult(SkillUseResult&& from) noexcept
    : SkillUseResult() {
    *this = ::std::move(from);
  }

  inline SkillUseResult& operator=(const SkillUseResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SkillUseResult& operator=(SkillUseResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SkillUseResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SkillUseResult* internal_default_instance() {
    return reinterpret_cast<const SkillUseResult*>(
               &_SkillUseResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SkillUseResult& a, SkillUseResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SkillUseResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SkillUseResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SkillUseResult* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SkillUseResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SkillUseResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SkillUseResult& from) {
    SkillUseResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SkillUseResult* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.SkillUseResult";
  }
  protected:
  explicit SkillUseResult(::google::protobuf::Arena* arena);
  SkillUseResult(::google::protobuf::Arena* arena, const SkillUseResult& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEffectsFieldNumber = 5,
    kSkillIdFieldNumber = 2,
    kFailureReasonFieldNumber = 4,
    kSuccessFieldNumber = 1,
    kCooldownFieldNumber = 3,
  };
  // repeated .mmorpg.CombatEffect effects = 5;
  int effects_size() const;
  private:
  int _internal_effects_size() const;

  public:
  void clear_effects() ;
  ::mmorpg::CombatEffect* mutable_effects(int index);
  ::google::protobuf::RepeatedPtrField< ::mmorpg::CombatEffect >*
      mutable_effects();
  private:
  const ::google::protobuf::RepeatedPtrField<::mmorpg::CombatEffect>& _internal_effects() const;
  ::google::protobuf::RepeatedPtrField<::mmorpg::CombatEffect>* _internal_mutable_effects();
  public:
  const ::mmorpg::CombatEffect& effects(int index) const;
  ::mmorpg::CombatEffect* add_effects();
  const ::google::protobuf::RepeatedPtrField< ::mmorpg::CombatEffect >&
      effects() const;
  // string skill_id = 2;
  void clear_skill_id() ;
  const std::string& skill_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_skill_id(Arg_&& arg, Args_... args);
  std::string* mutable_skill_id();
  PROTOBUF_NODISCARD std::string* release_skill_id();
  void set_allocated_skill_id(std::string* value);

  private:
  const std::string& _internal_skill_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_skill_id(
      const std::string& value);
  std::string* _internal_mutable_skill_id();

  public:
  // string failure_reason = 4;
  void clear_failure_reason() ;
  const std::string& failure_reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_failure_reason(Arg_&& arg, Args_... args);
  std::string* mutable_failure_reason();
  PROTOBUF_NODISCARD std::string* release_failure_reason();
  void set_allocated_failure_reason(std::string* value);

  private:
  const std::string& _internal_failure_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failure_reason(
      const std::string& value);
  std::string* _internal_mutable_failure_reason();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // float cooldown = 3;
  void clear_cooldown() ;
  float cooldown() const;
  void set_cooldown(float value);

  private:
  float _internal_cooldown() const;
  void _internal_set_cooldown(float value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.SkillUseResult)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      52, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::mmorpg::CombatEffect > effects_;
    ::google::protobuf::internal::ArenaStringPtr skill_id_;
    ::google::protobuf::internal::ArenaStringPtr failure_reason_;
    bool success_;
    float cooldown_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};// -------------------------------------------------------------------

class SkillUseRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.SkillUseRequest) */ {
 public:
  inline SkillUseRequest() : SkillUseRequest(nullptr) {}
  ~SkillUseRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SkillUseRequest(::google::protobuf::internal::ConstantInitialized);

  inline SkillUseRequest(const SkillUseRequest& from)
      : SkillUseRequest(nullptr, from) {}
  SkillUseRequest(SkillUseRequest&& from) noexcept
    : SkillUseRequest() {
    *this = ::std::move(from);
  }

  inline SkillUseRequest& operator=(const SkillUseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SkillUseRequest& operator=(SkillUseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SkillUseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SkillUseRequest* internal_default_instance() {
    return reinterpret_cast<const SkillUseRequest*>(
               &_SkillUseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SkillUseRequest& a, SkillUseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SkillUseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SkillUseRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SkillUseRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SkillUseRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SkillUseRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SkillUseRequest& from) {
    SkillUseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SkillUseRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.SkillUseRequest";
  }
  protected:
  explicit SkillUseRequest(::google::protobuf::Arena* arena);
  SkillUseRequest(::google::protobuf::Arena* arena, const SkillUseRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kSkillIdFieldNumber = 2,
    kTargetIdFieldNumber = 3,
    kTargetPositionFieldNumber = 4,
  };
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // string skill_id = 2;
  void clear_skill_id() ;
  const std::string& skill_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_skill_id(Arg_&& arg, Args_... args);
  std::string* mutable_skill_id();
  PROTOBUF_NODISCARD std::string* release_skill_id();
  void set_allocated_skill_id(std::string* value);

  private:
  const std::string& _internal_skill_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_skill_id(
      const std::string& value);
  std::string* _internal_mutable_skill_id();

  public:
  // string target_id = 3;
  void clear_target_id() ;
  const std::string& target_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_id(Arg_&& arg, Args_... args);
  std::string* mutable_target_id();
  PROTOBUF_NODISCARD std::string* release_target_id();
  void set_allocated_target_id(std::string* value);

  private:
  const std::string& _internal_target_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_id(
      const std::string& value);
  std::string* _internal_mutable_target_id();

  public:
  // .mmorpg.Vector3 target_position = 4;
  bool has_target_position() const;
  void clear_target_position() ;
  const ::mmorpg::Vector3& target_position() const;
  PROTOBUF_NODISCARD ::mmorpg::Vector3* release_target_position();
  ::mmorpg::Vector3* mutable_target_position();
  void set_allocated_target_position(::mmorpg::Vector3* value);
  void unsafe_arena_set_allocated_target_position(::mmorpg::Vector3* value);
  ::mmorpg::Vector3* unsafe_arena_release_target_position();

  private:
  const ::mmorpg::Vector3& _internal_target_position() const;
  ::mmorpg::Vector3* _internal_mutable_target_position();

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.SkillUseRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      57, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::google::protobuf::internal::ArenaStringPtr skill_id_;
    ::google::protobuf::internal::ArenaStringPtr target_id_;
    ::mmorpg::Vector3* target_position_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};// -------------------------------------------------------------------

class QuestInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.QuestInfo) */ {
 public:
  inline QuestInfo() : QuestInfo(nullptr) {}
  ~QuestInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuestInfo(::google::protobuf::internal::ConstantInitialized);

  inline QuestInfo(const QuestInfo& from)
      : QuestInfo(nullptr, from) {}
  QuestInfo(QuestInfo&& from) noexcept
    : QuestInfo() {
    *this = ::std::move(from);
  }

  inline QuestInfo& operator=(const QuestInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuestInfo& operator=(QuestInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuestInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuestInfo* internal_default_instance() {
    return reinterpret_cast<const QuestInfo*>(
               &_QuestInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(QuestInfo& a, QuestInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(QuestInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuestInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuestInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuestInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QuestInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const QuestInfo& from) {
    QuestInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QuestInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.QuestInfo";
  }
  protected:
  explicit QuestInfo(::google::protobuf::Arena* arena);
  QuestInfo(::google::protobuf::Arena* arena, const QuestInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectivesFieldNumber = 5,
    kRewardsFieldNumber = 6,
    kQuestIdFieldNumber = 1,
    kQuestNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kAcceptedAtFieldNumber = 10,
    kCompletedAtFieldNumber = 11,
    kStatusFieldNumber = 4,
    kRecommendedLevelFieldNumber = 7,
    kIsMainQuestFieldNumber = 8,
    kIsDailyQuestFieldNumber = 9,
  };
  // repeated .mmorpg.QuestObjective objectives = 5;
  int objectives_size() const;
  private:
  int _internal_objectives_size() const;

  public:
  void clear_objectives() ;
  ::mmorpg::QuestObjective* mutable_objectives(int index);
  ::google::protobuf::RepeatedPtrField< ::mmorpg::QuestObjective >*
      mutable_objectives();
  private:
  const ::google::protobuf::RepeatedPtrField<::mmorpg::QuestObjective>& _internal_objectives() const;
  ::google::protobuf::RepeatedPtrField<::mmorpg::QuestObjective>* _internal_mutable_objectives();
  public:
  const ::mmorpg::QuestObjective& objectives(int index) const;
  ::mmorpg::QuestObjective* add_objectives();
  const ::google::protobuf::RepeatedPtrField< ::mmorpg::QuestObjective >&
      objectives() const;
  // repeated .mmorpg.QuestReward rewards = 6;
  int rewards_size() const;
  private:
  int _internal_rewards_size() const;

  public:
  void clear_rewards() ;
  ::mmorpg::QuestReward* mutable_rewards(int index);
  ::google::protobuf::RepeatedPtrField< ::mmorpg::QuestReward >*
      mutable_rewards();
  private:
  const ::google::protobuf::RepeatedPtrField<::mmorpg::QuestReward>& _internal_rewards() const;
  ::google::protobuf::RepeatedPtrField<::mmorpg::QuestReward>* _internal_mutable_rewards();
  public:
  const ::mmorpg::QuestReward& rewards(int index) const;
  ::mmorpg::QuestReward* add_rewards();
  const ::google::protobuf::RepeatedPtrField< ::mmorpg::QuestReward >&
      rewards() const;
  // string quest_id = 1;
  void clear_quest_id() ;
  const std::string& quest_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quest_id(Arg_&& arg, Args_... args);
  std::string* mutable_quest_id();
  PROTOBUF_NODISCARD std::string* release_quest_id();
  void set_allocated_quest_id(std::string* value);

  private:
  const std::string& _internal_quest_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quest_id(
      const std::string& value);
  std::string* _internal_mutable_quest_id();

  public:
  // string quest_name = 2;
  void clear_quest_name() ;
  const std::string& quest_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_quest_name(Arg_&& arg, Args_... args);
  std::string* mutable_quest_name();
  PROTOBUF_NODISCARD std::string* release_quest_name();
  void set_allocated_quest_name(std::string* value);

  private:
  const std::string& _internal_quest_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quest_name(
      const std::string& value);
  std::string* _internal_mutable_quest_name();

  public:
  // string description = 3;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // .google.protobuf.Timestamp accepted_at = 10;
  bool has_accepted_at() const;
  void clear_accepted_at() ;
  const ::google::protobuf::Timestamp& accepted_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_accepted_at();
  ::google::protobuf::Timestamp* mutable_accepted_at();
  void set_allocated_accepted_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_accepted_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_accepted_at();

  private:
  const ::google::protobuf::Timestamp& _internal_accepted_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_accepted_at();

  public:
  // .google.protobuf.Timestamp completed_at = 11;
  bool has_completed_at() const;
  void clear_completed_at() ;
  const ::google::protobuf::Timestamp& completed_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_completed_at();
  ::google::protobuf::Timestamp* mutable_completed_at();
  void set_allocated_completed_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_completed_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_completed_at();

  private:
  const ::google::protobuf::Timestamp& _internal_completed_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_completed_at();

  public:
  // .mmorpg.QuestStatus status = 4;
  void clear_status() ;
  ::mmorpg::QuestStatus status() const;
  void set_status(::mmorpg::QuestStatus value);

  private:
  ::mmorpg::QuestStatus _internal_status() const;
  void _internal_set_status(::mmorpg::QuestStatus value);

  public:
  // int32 recommended_level = 7;
  void clear_recommended_level() ;
  ::int32_t recommended_level() const;
  void set_recommended_level(::int32_t value);

  private:
  ::int32_t _internal_recommended_level() const;
  void _internal_set_recommended_level(::int32_t value);

  public:
  // bool is_main_quest = 8;
  void clear_is_main_quest() ;
  bool is_main_quest() const;
  void set_is_main_quest(bool value);

  private:
  bool _internal_is_main_quest() const;
  void _internal_set_is_main_quest(bool value);

  public:
  // bool is_daily_quest = 9;
  void clear_is_daily_quest() ;
  bool is_daily_quest() const;
  void set_is_daily_quest(bool value);

  private:
  bool _internal_is_daily_quest() const;
  void _internal_set_is_daily_quest(bool value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.QuestInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 4,
      62, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::mmorpg::QuestObjective > objectives_;
    ::google::protobuf::RepeatedPtrField< ::mmorpg::QuestReward > rewards_;
    ::google::protobuf::internal::ArenaStringPtr quest_id_;
    ::google::protobuf::internal::ArenaStringPtr quest_name_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::Timestamp* accepted_at_;
    ::google::protobuf::Timestamp* completed_at_;
    int status_;
    ::int32_t recommended_level_;
    bool is_main_quest_;
    bool is_daily_quest_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};// -------------------------------------------------------------------

class Item final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.Item) */ {
 public:
  inline Item() : Item(nullptr) {}
  ~Item() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Item(::google::protobuf::internal::ConstantInitialized);

  inline Item(const Item& from)
      : Item(nullptr, from) {}
  Item(Item&& from) noexcept
    : Item() {
    *this = ::std::move(from);
  }

  inline Item& operator=(const Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline Item& operator=(Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const Item* internal_default_instance() {
    return reinterpret_cast<const Item*>(
               &_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Item& a, Item& b) {
    a.Swap(&b);
  }
  inline void Swap(Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Item* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Item* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Item>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Item& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Item& from) {
    Item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Item* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.Item";
  }
  protected:
  explicit Item(::google::protobuf::Arena* arena);
  Item(::google::protobuf::Arena* arena, const Item& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kStatsFieldNumber = 13,
    kEffectsFieldNumber = 14,
    kItemIdFieldNumber = 1,
    kItemTypeFieldNumber = 2,
    kNameFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kIconIdFieldNumber = 5,
    kEquipmentSlotFieldNumber = 17,
    kRarityFieldNumber = 6,
    kMaxStackFieldNumber = 7,
    kIsUniqueFieldNumber = 8,
    kIsQuestItemFieldNumber = 9,
    kIsBoundFieldNumber = 10,
    kRequiredLevelFieldNumber = 11,
    kSellPriceFieldNumber = 15,
    kRequiredClassFieldNumber = 12,
    kDurabilityFieldNumber = 18,
    kBuyPriceFieldNumber = 16,
    kMaxDurabilityFieldNumber = 19,
  };
  // map<string, int32> stats = 13;
  int stats_size() const;
  private:
  int _internal_stats_size() const;

  public:
  void clear_stats() ;
  const ::google::protobuf::Map<std::string, ::int32_t>& stats() const;
  ::google::protobuf::Map<std::string, ::int32_t>* mutable_stats();

  private:
  const ::google::protobuf::Map<std::string, ::int32_t>& _internal_stats() const;
  ::google::protobuf::Map<std::string, ::int32_t>* _internal_mutable_stats();

  public:
  // repeated .mmorpg.ItemEffect effects = 14;
  int effects_size() const;
  private:
  int _internal_effects_size() const;

  public:
  void clear_effects() ;
  ::mmorpg::ItemEffect* mutable_effects(int index);
  ::google::protobuf::RepeatedPtrField< ::mmorpg::ItemEffect >*
      mutable_effects();
  private:
  const ::google::protobuf::RepeatedPtrField<::mmorpg::ItemEffect>& _internal_effects() const;
  ::google::protobuf::RepeatedPtrField<::mmorpg::ItemEffect>* _internal_mutable_effects();
  public:
  const ::mmorpg::ItemEffect& effects(int index) const;
  ::mmorpg::ItemEffect* add_effects();
  const ::google::protobuf::RepeatedPtrField< ::mmorpg::ItemEffect >&
      effects() const;
  // string item_id = 1;
  void clear_item_id() ;
  const std::string& item_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_item_id(Arg_&& arg, Args_... args);
  std::string* mutable_item_id();
  PROTOBUF_NODISCARD std::string* release_item_id();
  void set_allocated_item_id(std::string* value);

  private:
  const std::string& _internal_item_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_id(
      const std::string& value);
  std::string* _internal_mutable_item_id();

  public:
  // string item_type = 2;
  void clear_item_type() ;
  const std::string& item_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_item_type(Arg_&& arg, Args_... args);
  std::string* mutable_item_type();
  PROTOBUF_NODISCARD std::string* release_item_type();
  void set_allocated_item_type(std::string* value);

  private:
  const std::string& _internal_item_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_type(
      const std::string& value);
  std::string* _internal_mutable_item_type();

  public:
  // string name = 3;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string description = 4;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // string icon_id = 5;
  void clear_icon_id() ;
  const std::string& icon_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_icon_id(Arg_&& arg, Args_... args);
  std::string* mutable_icon_id();
  PROTOBUF_NODISCARD std::string* release_icon_id();
  void set_allocated_icon_id(std::string* value);

  private:
  const std::string& _internal_icon_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_icon_id(
      const std::string& value);
  std::string* _internal_mutable_icon_id();

  public:
  // string equipment_slot = 17;
  void clear_equipment_slot() ;
  const std::string& equipment_slot() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_equipment_slot(Arg_&& arg, Args_... args);
  std::string* mutable_equipment_slot();
  PROTOBUF_NODISCARD std::string* release_equipment_slot();
  void set_allocated_equipment_slot(std::string* value);

  private:
  const std::string& _internal_equipment_slot() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_equipment_slot(
      const std::string& value);
  std::string* _internal_mutable_equipment_slot();

  public:
  // .mmorpg.ItemRarity rarity = 6;
  void clear_rarity() ;
  ::mmorpg::ItemRarity rarity() const;
  void set_rarity(::mmorpg::ItemRarity value);

  private:
  ::mmorpg::ItemRarity _internal_rarity() const;
  void _internal_set_rarity(::mmorpg::ItemRarity value);

  public:
  // int32 max_stack = 7;
  void clear_max_stack() ;
  ::int32_t max_stack() const;
  void set_max_stack(::int32_t value);

  private:
  ::int32_t _internal_max_stack() const;
  void _internal_set_max_stack(::int32_t value);

  public:
  // bool is_unique = 8;
  void clear_is_unique() ;
  bool is_unique() const;
  void set_is_unique(bool value);

  private:
  bool _internal_is_unique() const;
  void _internal_set_is_unique(bool value);

  public:
  // bool is_quest_item = 9;
  void clear_is_quest_item() ;
  bool is_quest_item() const;
  void set_is_quest_item(bool value);

  private:
  bool _internal_is_quest_item() const;
  void _internal_set_is_quest_item(bool value);

  public:
  // bool is_bound = 10;
  void clear_is_bound() ;
  bool is_bound() const;
  void set_is_bound(bool value);

  private:
  bool _internal_is_bound() const;
  void _internal_set_is_bound(bool value);

  public:
  // int32 required_level = 11;
  void clear_required_level() ;
  ::int32_t required_level() const;
  void set_required_level(::int32_t value);

  private:
  ::int32_t _internal_required_level() const;
  void _internal_set_required_level(::int32_t value);

  public:
  // int64 sell_price = 15;
  void clear_sell_price() ;
  ::int64_t sell_price() const;
  void set_sell_price(::int64_t value);

  private:
  ::int64_t _internal_sell_price() const;
  void _internal_set_sell_price(::int64_t value);

  public:
  // .mmorpg.CharacterClass required_class = 12;
  void clear_required_class() ;
  ::mmorpg::CharacterClass required_class() const;
  void set_required_class(::mmorpg::CharacterClass value);

  private:
  ::mmorpg::CharacterClass _internal_required_class() const;
  void _internal_set_required_class(::mmorpg::CharacterClass value);

  public:
  // int32 durability = 18;
  void clear_durability() ;
  ::int32_t durability() const;
  void set_durability(::int32_t value);

  private:
  ::int32_t _internal_durability() const;
  void _internal_set_durability(::int32_t value);

  public:
  // int64 buy_price = 16;
  void clear_buy_price() ;
  ::int64_t buy_price() const;
  void set_buy_price(::int64_t value);

  private:
  ::int64_t _internal_buy_price() const;
  void _internal_set_buy_price(::int64_t value);

  public:
  // int32 max_durability = 19;
  void clear_max_durability() ;
  ::int32_t max_durability() const;
  void set_max_durability(::int32_t value);

  private:
  ::int32_t _internal_max_durability() const;
  void _internal_set_max_durability(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.Item)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 19, 2,
      93, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::MapField<Item_StatsEntry_DoNotUse, std::string, ::int32_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT32>
        stats_;
    ::google::protobuf::RepeatedPtrField< ::mmorpg::ItemEffect > effects_;
    ::google::protobuf::internal::ArenaStringPtr item_id_;
    ::google::protobuf::internal::ArenaStringPtr item_type_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::internal::ArenaStringPtr icon_id_;
    ::google::protobuf::internal::ArenaStringPtr equipment_slot_;
    int rarity_;
    ::int32_t max_stack_;
    bool is_unique_;
    bool is_quest_item_;
    bool is_bound_;
    ::int32_t required_level_;
    ::int64_t sell_price_;
    int required_class_;
    ::int32_t durability_;
    ::int64_t buy_price_;
    ::int32_t max_durability_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};// -------------------------------------------------------------------

class GameActionResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.GameActionResponse) */ {
 public:
  inline GameActionResponse() : GameActionResponse(nullptr) {}
  ~GameActionResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GameActionResponse(::google::protobuf::internal::ConstantInitialized);

  inline GameActionResponse(const GameActionResponse& from)
      : GameActionResponse(nullptr, from) {}
  GameActionResponse(GameActionResponse&& from) noexcept
    : GameActionResponse() {
    *this = ::std::move(from);
  }

  inline GameActionResponse& operator=(const GameActionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameActionResponse& operator=(GameActionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameActionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameActionResponse* internal_default_instance() {
    return reinterpret_cast<const GameActionResponse*>(
               &_GameActionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GameActionResponse& a, GameActionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GameActionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameActionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameActionResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameActionResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GameActionResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GameActionResponse& from) {
    GameActionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GameActionResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.GameActionResponse";
  }
  protected:
  explicit GameActionResponse(::google::protobuf::Arena* arena);
  GameActionResponse(::google::protobuf::Arena* arena, const GameActionResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 5,
    kActionIdFieldNumber = 2,
    kMessageFieldNumber = 3,
    kSuccessFieldNumber = 1,
    kErrorCodeFieldNumber = 4,
  };
  // map<string, string> results = 5;
  int results_size() const;
  private:
  int _internal_results_size() const;

  public:
  void clear_results() ;
  const ::google::protobuf::Map<std::string, std::string>& results() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_results();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_results() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_results();

  public:
  // string action_id = 2;
  void clear_action_id() ;
  const std::string& action_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_action_id(Arg_&& arg, Args_... args);
  std::string* mutable_action_id();
  PROTOBUF_NODISCARD std::string* release_action_id();
  void set_allocated_action_id(std::string* value);

  private:
  const std::string& _internal_action_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action_id(
      const std::string& value);
  std::string* _internal_mutable_action_id();

  public:
  // string message = 3;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // .mmorpg.ErrorCode error_code = 4;
  void clear_error_code() ;
  ::mmorpg::ErrorCode error_code() const;
  void set_error_code(::mmorpg::ErrorCode value);

  private:
  ::mmorpg::ErrorCode _internal_error_code() const;
  void _internal_set_error_code(::mmorpg::ErrorCode value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.GameActionResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 5, 1,
      57, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::MapField<GameActionResponse_ResultsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        results_;
    ::google::protobuf::internal::ArenaStringPtr action_id_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool success_;
    int error_code_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};// -------------------------------------------------------------------

class GameActionRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.GameActionRequest) */ {
 public:
  inline GameActionRequest() : GameActionRequest(nullptr) {}
  ~GameActionRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GameActionRequest(::google::protobuf::internal::ConstantInitialized);

  inline GameActionRequest(const GameActionRequest& from)
      : GameActionRequest(nullptr, from) {}
  GameActionRequest(GameActionRequest&& from) noexcept
    : GameActionRequest() {
    *this = ::std::move(from);
  }

  inline GameActionRequest& operator=(const GameActionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameActionRequest& operator=(GameActionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameActionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameActionRequest* internal_default_instance() {
    return reinterpret_cast<const GameActionRequest*>(
               &_GameActionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GameActionRequest& a, GameActionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GameActionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameActionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameActionRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameActionRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GameActionRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GameActionRequest& from) {
    GameActionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GameActionRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.GameActionRequest";
  }
  protected:
  explicit GameActionRequest(::google::protobuf::Arena* arena);
  GameActionRequest(::google::protobuf::Arena* arena, const GameActionRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 5,
    kPlayerIdFieldNumber = 1,
    kTargetIdFieldNumber = 3,
    kActionIdFieldNumber = 4,
    kTimestampFieldNumber = 6,
    kActionTypeFieldNumber = 2,
  };
  // map<string, string> parameters = 5;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;

  public:
  void clear_parameters() ;
  const ::google::protobuf::Map<std::string, std::string>& parameters() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_parameters();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_parameters() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_parameters();

  public:
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // string target_id = 3;
  void clear_target_id() ;
  const std::string& target_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_id(Arg_&& arg, Args_... args);
  std::string* mutable_target_id();
  PROTOBUF_NODISCARD std::string* release_target_id();
  void set_allocated_target_id(std::string* value);

  private:
  const std::string& _internal_target_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_id(
      const std::string& value);
  std::string* _internal_mutable_target_id();

  public:
  // string action_id = 4;
  void clear_action_id() ;
  const std::string& action_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_action_id(Arg_&& arg, Args_... args);
  std::string* mutable_action_id();
  PROTOBUF_NODISCARD std::string* release_action_id();
  void set_allocated_action_id(std::string* value);

  private:
  const std::string& _internal_action_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action_id(
      const std::string& value);
  std::string* _internal_mutable_action_id();

  public:
  // .google.protobuf.Timestamp timestamp = 6;
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::google::protobuf::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_timestamp();

  public:
  // .mmorpg.ActionType action_type = 2;
  void clear_action_type() ;
  ::mmorpg::ActionType action_type() const;
  void set_action_type(::mmorpg::ActionType value);

  private:
  ::mmorpg::ActionType _internal_action_type() const;
  void _internal_set_action_type(::mmorpg::ActionType value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.GameActionRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      70, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<GameActionRequest_ParametersEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        parameters_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::google::protobuf::internal::ArenaStringPtr target_id_;
    ::google::protobuf::internal::ArenaStringPtr action_id_;
    ::google::protobuf::Timestamp* timestamp_;
    int action_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};// -------------------------------------------------------------------

class CurrencyUpdate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.CurrencyUpdate) */ {
 public:
  inline CurrencyUpdate() : CurrencyUpdate(nullptr) {}
  ~CurrencyUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CurrencyUpdate(::google::protobuf::internal::ConstantInitialized);

  inline CurrencyUpdate(const CurrencyUpdate& from)
      : CurrencyUpdate(nullptr, from) {}
  CurrencyUpdate(CurrencyUpdate&& from) noexcept
    : CurrencyUpdate() {
    *this = ::std::move(from);
  }

  inline CurrencyUpdate& operator=(const CurrencyUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurrencyUpdate& operator=(CurrencyUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurrencyUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurrencyUpdate* internal_default_instance() {
    return reinterpret_cast<const CurrencyUpdate*>(
               &_CurrencyUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CurrencyUpdate& a, CurrencyUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(CurrencyUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurrencyUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CurrencyUpdate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CurrencyUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CurrencyUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CurrencyUpdate& from) {
    CurrencyUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CurrencyUpdate* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.CurrencyUpdate";
  }
  protected:
  explicit CurrencyUpdate(::google::protobuf::Arena* arena);
  CurrencyUpdate(::google::protobuf::Arena* arena, const CurrencyUpdate& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kCurrenciesFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // map<string, int64> currencies = 2;
  int currencies_size() const;
  private:
  int _internal_currencies_size() const;

  public:
  void clear_currencies() ;
  const ::google::protobuf::Map<std::string, ::int64_t>& currencies() const;
  ::google::protobuf::Map<std::string, ::int64_t>* mutable_currencies();

  private:
  const ::google::protobuf::Map<std::string, ::int64_t>& _internal_currencies() const;
  ::google::protobuf::Map<std::string, ::int64_t>* _internal_mutable_currencies();

  public:
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.CurrencyUpdate)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 1,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::MapField<CurrencyUpdate_CurrenciesEntry_DoNotUse, std::string, ::int64_t,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_INT64>
        currencies_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};// -------------------------------------------------------------------

class CombatResult final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.CombatResult) */ {
 public:
  inline CombatResult() : CombatResult(nullptr) {}
  ~CombatResult() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CombatResult(::google::protobuf::internal::ConstantInitialized);

  inline CombatResult(const CombatResult& from)
      : CombatResult(nullptr, from) {}
  CombatResult(CombatResult&& from) noexcept
    : CombatResult() {
    *this = ::std::move(from);
  }

  inline CombatResult& operator=(const CombatResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline CombatResult& operator=(CombatResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CombatResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const CombatResult* internal_default_instance() {
    return reinterpret_cast<const CombatResult*>(
               &_CombatResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CombatResult& a, CombatResult& b) {
    a.Swap(&b);
  }
  inline void Swap(CombatResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CombatResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CombatResult* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CombatResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CombatResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CombatResult& from) {
    CombatResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CombatResult* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.CombatResult";
  }
  protected:
  explicit CombatResult(::google::protobuf::Arena* arena);
  CombatResult(::google::protobuf::Arena* arena, const CombatResult& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEffectsFieldNumber = 3,
    kActionIdFieldNumber = 1,
    kFailureReasonFieldNumber = 4,
    kSuccessFieldNumber = 2,
  };
  // repeated .mmorpg.CombatEffect effects = 3;
  int effects_size() const;
  private:
  int _internal_effects_size() const;

  public:
  void clear_effects() ;
  ::mmorpg::CombatEffect* mutable_effects(int index);
  ::google::protobuf::RepeatedPtrField< ::mmorpg::CombatEffect >*
      mutable_effects();
  private:
  const ::google::protobuf::RepeatedPtrField<::mmorpg::CombatEffect>& _internal_effects() const;
  ::google::protobuf::RepeatedPtrField<::mmorpg::CombatEffect>* _internal_mutable_effects();
  public:
  const ::mmorpg::CombatEffect& effects(int index) const;
  ::mmorpg::CombatEffect* add_effects();
  const ::google::protobuf::RepeatedPtrField< ::mmorpg::CombatEffect >&
      effects() const;
  // string action_id = 1;
  void clear_action_id() ;
  const std::string& action_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_action_id(Arg_&& arg, Args_... args);
  std::string* mutable_action_id();
  PROTOBUF_NODISCARD std::string* release_action_id();
  void set_allocated_action_id(std::string* value);

  private:
  const std::string& _internal_action_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action_id(
      const std::string& value);
  std::string* _internal_mutable_action_id();

  public:
  // string failure_reason = 4;
  void clear_failure_reason() ;
  const std::string& failure_reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_failure_reason(Arg_&& arg, Args_... args);
  std::string* mutable_failure_reason();
  PROTOBUF_NODISCARD std::string* release_failure_reason();
  void set_allocated_failure_reason(std::string* value);

  private:
  const std::string& _internal_failure_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_failure_reason(
      const std::string& value);
  std::string* _internal_mutable_failure_reason();

  public:
  // bool success = 2;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.CombatResult)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      51, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::mmorpg::CombatEffect > effects_;
    ::google::protobuf::internal::ArenaStringPtr action_id_;
    ::google::protobuf::internal::ArenaStringPtr failure_reason_;
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};// -------------------------------------------------------------------

class CombatAction final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.CombatAction) */ {
 public:
  inline CombatAction() : CombatAction(nullptr) {}
  ~CombatAction() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CombatAction(::google::protobuf::internal::ConstantInitialized);

  inline CombatAction(const CombatAction& from)
      : CombatAction(nullptr, from) {}
  CombatAction(CombatAction&& from) noexcept
    : CombatAction() {
    *this = ::std::move(from);
  }

  inline CombatAction& operator=(const CombatAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline CombatAction& operator=(CombatAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CombatAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const CombatAction* internal_default_instance() {
    return reinterpret_cast<const CombatAction*>(
               &_CombatAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CombatAction& a, CombatAction& b) {
    a.Swap(&b);
  }
  inline void Swap(CombatAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CombatAction* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CombatAction* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CombatAction>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CombatAction& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CombatAction& from) {
    CombatAction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CombatAction* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.CombatAction";
  }
  protected:
  explicit CombatAction(::google::protobuf::Arena* arena);
  CombatAction(::google::protobuf::Arena* arena, const CombatAction& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttackerIdFieldNumber = 1,
    kTargetIdFieldNumber = 2,
    kSkillIdFieldNumber = 3,
    kTimestampFieldNumber = 5,
    kActionTypeFieldNumber = 4,
  };
  // string attacker_id = 1;
  void clear_attacker_id() ;
  const std::string& attacker_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_attacker_id(Arg_&& arg, Args_... args);
  std::string* mutable_attacker_id();
  PROTOBUF_NODISCARD std::string* release_attacker_id();
  void set_allocated_attacker_id(std::string* value);

  private:
  const std::string& _internal_attacker_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attacker_id(
      const std::string& value);
  std::string* _internal_mutable_attacker_id();

  public:
  // string target_id = 2;
  void clear_target_id() ;
  const std::string& target_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_id(Arg_&& arg, Args_... args);
  std::string* mutable_target_id();
  PROTOBUF_NODISCARD std::string* release_target_id();
  void set_allocated_target_id(std::string* value);

  private:
  const std::string& _internal_target_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_id(
      const std::string& value);
  std::string* _internal_mutable_target_id();

  public:
  // string skill_id = 3;
  void clear_skill_id() ;
  const std::string& skill_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_skill_id(Arg_&& arg, Args_... args);
  std::string* mutable_skill_id();
  PROTOBUF_NODISCARD std::string* release_skill_id();
  void set_allocated_skill_id(std::string* value);

  private:
  const std::string& _internal_skill_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_skill_id(
      const std::string& value);
  std::string* _internal_mutable_skill_id();

  public:
  // .google.protobuf.Timestamp timestamp = 5;
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::google::protobuf::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_timestamp();

  public:
  // .mmorpg.CombatActionType action_type = 4;
  void clear_action_type() ;
  ::mmorpg::CombatActionType action_type() const;
  void set_action_type(::mmorpg::CombatActionType value);

  private:
  ::mmorpg::CombatActionType _internal_action_type() const;
  void _internal_set_action_type(::mmorpg::CombatActionType value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.CombatAction)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      56, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr attacker_id_;
    ::google::protobuf::internal::ArenaStringPtr target_id_;
    ::google::protobuf::internal::ArenaStringPtr skill_id_;
    ::google::protobuf::Timestamp* timestamp_;
    int action_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};// -------------------------------------------------------------------

class AchievementUnlocked final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.AchievementUnlocked) */ {
 public:
  inline AchievementUnlocked() : AchievementUnlocked(nullptr) {}
  ~AchievementUnlocked() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AchievementUnlocked(::google::protobuf::internal::ConstantInitialized);

  inline AchievementUnlocked(const AchievementUnlocked& from)
      : AchievementUnlocked(nullptr, from) {}
  AchievementUnlocked(AchievementUnlocked&& from) noexcept
    : AchievementUnlocked() {
    *this = ::std::move(from);
  }

  inline AchievementUnlocked& operator=(const AchievementUnlocked& from) {
    CopyFrom(from);
    return *this;
  }
  inline AchievementUnlocked& operator=(AchievementUnlocked&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AchievementUnlocked& default_instance() {
    return *internal_default_instance();
  }
  static inline const AchievementUnlocked* internal_default_instance() {
    return reinterpret_cast<const AchievementUnlocked*>(
               &_AchievementUnlocked_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(AchievementUnlocked& a, AchievementUnlocked& b) {
    a.Swap(&b);
  }
  inline void Swap(AchievementUnlocked* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AchievementUnlocked* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AchievementUnlocked* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AchievementUnlocked>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AchievementUnlocked& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AchievementUnlocked& from) {
    AchievementUnlocked::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AchievementUnlocked* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.AchievementUnlocked";
  }
  protected:
  explicit AchievementUnlocked(::google::protobuf::Arena* arena);
  AchievementUnlocked(::google::protobuf::Arena* arena, const AchievementUnlocked& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kAchievementIdFieldNumber = 2,
    kAchievementNameFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kUnlockedAtFieldNumber = 6,
    kPointsFieldNumber = 5,
  };
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // string achievement_id = 2;
  void clear_achievement_id() ;
  const std::string& achievement_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_achievement_id(Arg_&& arg, Args_... args);
  std::string* mutable_achievement_id();
  PROTOBUF_NODISCARD std::string* release_achievement_id();
  void set_allocated_achievement_id(std::string* value);

  private:
  const std::string& _internal_achievement_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_achievement_id(
      const std::string& value);
  std::string* _internal_mutable_achievement_id();

  public:
  // string achievement_name = 3;
  void clear_achievement_name() ;
  const std::string& achievement_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_achievement_name(Arg_&& arg, Args_... args);
  std::string* mutable_achievement_name();
  PROTOBUF_NODISCARD std::string* release_achievement_name();
  void set_allocated_achievement_name(std::string* value);

  private:
  const std::string& _internal_achievement_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_achievement_name(
      const std::string& value);
  std::string* _internal_mutable_achievement_name();

  public:
  // string description = 4;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // .google.protobuf.Timestamp unlocked_at = 6;
  bool has_unlocked_at() const;
  void clear_unlocked_at() ;
  const ::google::protobuf::Timestamp& unlocked_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_unlocked_at();
  ::google::protobuf::Timestamp* mutable_unlocked_at();
  void set_allocated_unlocked_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_unlocked_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_unlocked_at();

  private:
  const ::google::protobuf::Timestamp& _internal_unlocked_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_unlocked_at();

  public:
  // int32 points = 5;
  void clear_points() ;
  ::int32_t points() const;
  void set_points(::int32_t value);

  private:
  ::int32_t _internal_points() const;
  void _internal_set_points(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.AchievementUnlocked)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      85, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::google::protobuf::internal::ArenaStringPtr achievement_id_;
    ::google::protobuf::internal::ArenaStringPtr achievement_name_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::Timestamp* unlocked_at_;
    ::int32_t points_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};// -------------------------------------------------------------------

class TradeUpdate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.TradeUpdate) */ {
 public:
  inline TradeUpdate() : TradeUpdate(nullptr) {}
  ~TradeUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TradeUpdate(::google::protobuf::internal::ConstantInitialized);

  inline TradeUpdate(const TradeUpdate& from)
      : TradeUpdate(nullptr, from) {}
  TradeUpdate(TradeUpdate&& from) noexcept
    : TradeUpdate() {
    *this = ::std::move(from);
  }

  inline TradeUpdate& operator=(const TradeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline TradeUpdate& operator=(TradeUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TradeUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const TradeUpdate* internal_default_instance() {
    return reinterpret_cast<const TradeUpdate*>(
               &_TradeUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(TradeUpdate& a, TradeUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(TradeUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TradeUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TradeUpdate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TradeUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TradeUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TradeUpdate& from) {
    TradeUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TradeUpdate* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.TradeUpdate";
  }
  protected:
  explicit TradeUpdate(::google::protobuf::Arena* arena);
  TradeUpdate(::google::protobuf::Arena* arena, const TradeUpdate& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTradeIdFieldNumber = 1,
    kInitiatorOfferFieldNumber = 3,
    kTargetOfferFieldNumber = 4,
    kStateFieldNumber = 2,
  };
  // string trade_id = 1;
  void clear_trade_id() ;
  const std::string& trade_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trade_id(Arg_&& arg, Args_... args);
  std::string* mutable_trade_id();
  PROTOBUF_NODISCARD std::string* release_trade_id();
  void set_allocated_trade_id(std::string* value);

  private:
  const std::string& _internal_trade_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trade_id(
      const std::string& value);
  std::string* _internal_mutable_trade_id();

  public:
  // .mmorpg.TradeOffer initiator_offer = 3;
  bool has_initiator_offer() const;
  void clear_initiator_offer() ;
  const ::mmorpg::TradeOffer& initiator_offer() const;
  PROTOBUF_NODISCARD ::mmorpg::TradeOffer* release_initiator_offer();
  ::mmorpg::TradeOffer* mutable_initiator_offer();
  void set_allocated_initiator_offer(::mmorpg::TradeOffer* value);
  void unsafe_arena_set_allocated_initiator_offer(::mmorpg::TradeOffer* value);
  ::mmorpg::TradeOffer* unsafe_arena_release_initiator_offer();

  private:
  const ::mmorpg::TradeOffer& _internal_initiator_offer() const;
  ::mmorpg::TradeOffer* _internal_mutable_initiator_offer();

  public:
  // .mmorpg.TradeOffer target_offer = 4;
  bool has_target_offer() const;
  void clear_target_offer() ;
  const ::mmorpg::TradeOffer& target_offer() const;
  PROTOBUF_NODISCARD ::mmorpg::TradeOffer* release_target_offer();
  ::mmorpg::TradeOffer* mutable_target_offer();
  void set_allocated_target_offer(::mmorpg::TradeOffer* value);
  void unsafe_arena_set_allocated_target_offer(::mmorpg::TradeOffer* value);
  ::mmorpg::TradeOffer* unsafe_arena_release_target_offer();

  private:
  const ::mmorpg::TradeOffer& _internal_target_offer() const;
  ::mmorpg::TradeOffer* _internal_mutable_target_offer();

  public:
  // .mmorpg.TradeState state = 2;
  void clear_state() ;
  ::mmorpg::TradeState state() const;
  void set_state(::mmorpg::TradeState value);

  private:
  ::mmorpg::TradeState _internal_state() const;
  void _internal_set_state(::mmorpg::TradeState value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.TradeUpdate)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      35, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr trade_id_;
    ::mmorpg::TradeOffer* initiator_offer_;
    ::mmorpg::TradeOffer* target_offer_;
    int state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};// -------------------------------------------------------------------

class QuestUpdate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.QuestUpdate) */ {
 public:
  inline QuestUpdate() : QuestUpdate(nullptr) {}
  ~QuestUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR QuestUpdate(::google::protobuf::internal::ConstantInitialized);

  inline QuestUpdate(const QuestUpdate& from)
      : QuestUpdate(nullptr, from) {}
  QuestUpdate(QuestUpdate&& from) noexcept
    : QuestUpdate() {
    *this = ::std::move(from);
  }

  inline QuestUpdate& operator=(const QuestUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuestUpdate& operator=(QuestUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuestUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuestUpdate* internal_default_instance() {
    return reinterpret_cast<const QuestUpdate*>(
               &_QuestUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(QuestUpdate& a, QuestUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(QuestUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuestUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuestUpdate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuestUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QuestUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const QuestUpdate& from) {
    QuestUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QuestUpdate* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.QuestUpdate";
  }
  protected:
  explicit QuestUpdate(::google::protobuf::Arena* arena);
  QuestUpdate(::google::protobuf::Arena* arena, const QuestUpdate& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActiveQuestsFieldNumber = 2,
    kCompletedQuestsFieldNumber = 3,
    kAvailableQuestIdsFieldNumber = 4,
    kPlayerIdFieldNumber = 1,
  };
  // repeated .mmorpg.QuestInfo active_quests = 2;
  int active_quests_size() const;
  private:
  int _internal_active_quests_size() const;

  public:
  void clear_active_quests() ;
  ::mmorpg::QuestInfo* mutable_active_quests(int index);
  ::google::protobuf::RepeatedPtrField< ::mmorpg::QuestInfo >*
      mutable_active_quests();
  private:
  const ::google::protobuf::RepeatedPtrField<::mmorpg::QuestInfo>& _internal_active_quests() const;
  ::google::protobuf::RepeatedPtrField<::mmorpg::QuestInfo>* _internal_mutable_active_quests();
  public:
  const ::mmorpg::QuestInfo& active_quests(int index) const;
  ::mmorpg::QuestInfo* add_active_quests();
  const ::google::protobuf::RepeatedPtrField< ::mmorpg::QuestInfo >&
      active_quests() const;
  // repeated .mmorpg.QuestInfo completed_quests = 3;
  int completed_quests_size() const;
  private:
  int _internal_completed_quests_size() const;

  public:
  void clear_completed_quests() ;
  ::mmorpg::QuestInfo* mutable_completed_quests(int index);
  ::google::protobuf::RepeatedPtrField< ::mmorpg::QuestInfo >*
      mutable_completed_quests();
  private:
  const ::google::protobuf::RepeatedPtrField<::mmorpg::QuestInfo>& _internal_completed_quests() const;
  ::google::protobuf::RepeatedPtrField<::mmorpg::QuestInfo>* _internal_mutable_completed_quests();
  public:
  const ::mmorpg::QuestInfo& completed_quests(int index) const;
  ::mmorpg::QuestInfo* add_completed_quests();
  const ::google::protobuf::RepeatedPtrField< ::mmorpg::QuestInfo >&
      completed_quests() const;
  // repeated string available_quest_ids = 4;
  int available_quest_ids_size() const;
  private:
  int _internal_available_quest_ids_size() const;

  public:
  void clear_available_quest_ids() ;
  const std::string& available_quest_ids(int index) const;
  std::string* mutable_available_quest_ids(int index);
  void set_available_quest_ids(int index, const std::string& value);
  void set_available_quest_ids(int index, std::string&& value);
  void set_available_quest_ids(int index, const char* value);
  void set_available_quest_ids(int index, const char* value, std::size_t size);
  void set_available_quest_ids(int index, absl::string_view value);
  std::string* add_available_quest_ids();
  void add_available_quest_ids(const std::string& value);
  void add_available_quest_ids(std::string&& value);
  void add_available_quest_ids(const char* value);
  void add_available_quest_ids(const char* value, std::size_t size);
  void add_available_quest_ids(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& available_quest_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_available_quest_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_available_quest_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_available_quest_ids();

  public:
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.QuestUpdate)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      55, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::mmorpg::QuestInfo > active_quests_;
    ::google::protobuf::RepeatedPtrField< ::mmorpg::QuestInfo > completed_quests_;
    ::google::protobuf::RepeatedPtrField<std::string> available_quest_ids_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};// -------------------------------------------------------------------

class LootItem final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.LootItem) */ {
 public:
  inline LootItem() : LootItem(nullptr) {}
  ~LootItem() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LootItem(::google::protobuf::internal::ConstantInitialized);

  inline LootItem(const LootItem& from)
      : LootItem(nullptr, from) {}
  LootItem(LootItem&& from) noexcept
    : LootItem() {
    *this = ::std::move(from);
  }

  inline LootItem& operator=(const LootItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline LootItem& operator=(LootItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LootItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const LootItem* internal_default_instance() {
    return reinterpret_cast<const LootItem*>(
               &_LootItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(LootItem& a, LootItem& b) {
    a.Swap(&b);
  }
  inline void Swap(LootItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LootItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LootItem* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LootItem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LootItem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LootItem& from) {
    LootItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LootItem* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.LootItem";
  }
  protected:
  explicit LootItem(::google::protobuf::Arena* arena);
  LootItem(::google::protobuf::Arena* arena, const LootItem& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
    kQuantityFieldNumber = 2,
  };
  // .mmorpg.Item item = 1;
  bool has_item() const;
  void clear_item() ;
  const ::mmorpg::Item& item() const;
  PROTOBUF_NODISCARD ::mmorpg::Item* release_item();
  ::mmorpg::Item* mutable_item();
  void set_allocated_item(::mmorpg::Item* value);
  void unsafe_arena_set_allocated_item(::mmorpg::Item* value);
  ::mmorpg::Item* unsafe_arena_release_item();

  private:
  const ::mmorpg::Item& _internal_item() const;
  ::mmorpg::Item* _internal_mutable_item();

  public:
  // int32 quantity = 2;
  void clear_quantity() ;
  ::int32_t quantity() const;
  void set_quantity(::int32_t value);

  private:
  ::int32_t _internal_quantity() const;
  void _internal_set_quantity(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.LootItem)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::mmorpg::Item* item_;
    ::int32_t quantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};// -------------------------------------------------------------------

class InventorySlot final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.InventorySlot) */ {
 public:
  inline InventorySlot() : InventorySlot(nullptr) {}
  ~InventorySlot() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InventorySlot(::google::protobuf::internal::ConstantInitialized);

  inline InventorySlot(const InventorySlot& from)
      : InventorySlot(nullptr, from) {}
  InventorySlot(InventorySlot&& from) noexcept
    : InventorySlot() {
    *this = ::std::move(from);
  }

  inline InventorySlot& operator=(const InventorySlot& from) {
    CopyFrom(from);
    return *this;
  }
  inline InventorySlot& operator=(InventorySlot&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InventorySlot& default_instance() {
    return *internal_default_instance();
  }
  static inline const InventorySlot* internal_default_instance() {
    return reinterpret_cast<const InventorySlot*>(
               &_InventorySlot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InventorySlot& a, InventorySlot& b) {
    a.Swap(&b);
  }
  inline void Swap(InventorySlot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InventorySlot* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InventorySlot* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InventorySlot>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InventorySlot& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InventorySlot& from) {
    InventorySlot::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InventorySlot* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.InventorySlot";
  }
  protected:
  explicit InventorySlot(::google::protobuf::Arena* arena);
  InventorySlot(::google::protobuf::Arena* arena, const InventorySlot& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 2,
    kSlotIndexFieldNumber = 1,
    kQuantityFieldNumber = 3,
  };
  // .mmorpg.Item item = 2;
  bool has_item() const;
  void clear_item() ;
  const ::mmorpg::Item& item() const;
  PROTOBUF_NODISCARD ::mmorpg::Item* release_item();
  ::mmorpg::Item* mutable_item();
  void set_allocated_item(::mmorpg::Item* value);
  void unsafe_arena_set_allocated_item(::mmorpg::Item* value);
  ::mmorpg::Item* unsafe_arena_release_item();

  private:
  const ::mmorpg::Item& _internal_item() const;
  ::mmorpg::Item* _internal_mutable_item();

  public:
  // int32 slot_index = 1;
  void clear_slot_index() ;
  ::int32_t slot_index() const;
  void set_slot_index(::int32_t value);

  private:
  ::int32_t _internal_slot_index() const;
  void _internal_set_slot_index(::int32_t value);

  public:
  // int32 quantity = 3;
  void clear_quantity() ;
  ::int32_t quantity() const;
  void set_quantity(::int32_t value);

  private:
  ::int32_t _internal_quantity() const;
  void _internal_set_quantity(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.InventorySlot)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::mmorpg::Item* item_;
    ::int32_t slot_index_;
    ::int32_t quantity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};// -------------------------------------------------------------------

class LootDropped final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.LootDropped) */ {
 public:
  inline LootDropped() : LootDropped(nullptr) {}
  ~LootDropped() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LootDropped(::google::protobuf::internal::ConstantInitialized);

  inline LootDropped(const LootDropped& from)
      : LootDropped(nullptr, from) {}
  LootDropped(LootDropped&& from) noexcept
    : LootDropped() {
    *this = ::std::move(from);
  }

  inline LootDropped& operator=(const LootDropped& from) {
    CopyFrom(from);
    return *this;
  }
  inline LootDropped& operator=(LootDropped&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LootDropped& default_instance() {
    return *internal_default_instance();
  }
  static inline const LootDropped* internal_default_instance() {
    return reinterpret_cast<const LootDropped*>(
               &_LootDropped_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(LootDropped& a, LootDropped& b) {
    a.Swap(&b);
  }
  inline void Swap(LootDropped* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LootDropped* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LootDropped* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LootDropped>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LootDropped& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LootDropped& from) {
    LootDropped::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LootDropped* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.LootDropped";
  }
  protected:
  explicit LootDropped(::google::protobuf::Arena* arena);
  LootDropped(::google::protobuf::Arena* arena, const LootDropped& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 4,
    kAllowedLootersFieldNumber = 5,
    kEntityIdFieldNumber = 1,
    kLootIdFieldNumber = 2,
    kPositionFieldNumber = 3,
    kExpiresAtFieldNumber = 6,
  };
  // repeated .mmorpg.LootItem items = 4;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::mmorpg::LootItem* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::mmorpg::LootItem >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::mmorpg::LootItem>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::mmorpg::LootItem>* _internal_mutable_items();
  public:
  const ::mmorpg::LootItem& items(int index) const;
  ::mmorpg::LootItem* add_items();
  const ::google::protobuf::RepeatedPtrField< ::mmorpg::LootItem >&
      items() const;
  // repeated string allowed_looters = 5;
  int allowed_looters_size() const;
  private:
  int _internal_allowed_looters_size() const;

  public:
  void clear_allowed_looters() ;
  const std::string& allowed_looters(int index) const;
  std::string* mutable_allowed_looters(int index);
  void set_allowed_looters(int index, const std::string& value);
  void set_allowed_looters(int index, std::string&& value);
  void set_allowed_looters(int index, const char* value);
  void set_allowed_looters(int index, const char* value, std::size_t size);
  void set_allowed_looters(int index, absl::string_view value);
  std::string* add_allowed_looters();
  void add_allowed_looters(const std::string& value);
  void add_allowed_looters(std::string&& value);
  void add_allowed_looters(const char* value);
  void add_allowed_looters(const char* value, std::size_t size);
  void add_allowed_looters(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& allowed_looters() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_allowed_looters();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_allowed_looters() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_allowed_looters();

  public:
  // string entity_id = 1;
  void clear_entity_id() ;
  const std::string& entity_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  std::string* mutable_entity_id();
  PROTOBUF_NODISCARD std::string* release_entity_id();
  void set_allocated_entity_id(std::string* value);

  private:
  const std::string& _internal_entity_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(
      const std::string& value);
  std::string* _internal_mutable_entity_id();

  public:
  // string loot_id = 2;
  void clear_loot_id() ;
  const std::string& loot_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_loot_id(Arg_&& arg, Args_... args);
  std::string* mutable_loot_id();
  PROTOBUF_NODISCARD std::string* release_loot_id();
  void set_allocated_loot_id(std::string* value);

  private:
  const std::string& _internal_loot_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_loot_id(
      const std::string& value);
  std::string* _internal_mutable_loot_id();

  public:
  // .mmorpg.Vector3 position = 3;
  bool has_position() const;
  void clear_position() ;
  const ::mmorpg::Vector3& position() const;
  PROTOBUF_NODISCARD ::mmorpg::Vector3* release_position();
  ::mmorpg::Vector3* mutable_position();
  void set_allocated_position(::mmorpg::Vector3* value);
  void unsafe_arena_set_allocated_position(::mmorpg::Vector3* value);
  ::mmorpg::Vector3* unsafe_arena_release_position();

  private:
  const ::mmorpg::Vector3& _internal_position() const;
  ::mmorpg::Vector3* _internal_mutable_position();

  public:
  // .google.protobuf.Timestamp expires_at = 6;
  bool has_expires_at() const;
  void clear_expires_at() ;
  const ::google::protobuf::Timestamp& expires_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_expires_at();
  ::google::protobuf::Timestamp* mutable_expires_at();
  void set_allocated_expires_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_expires_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_expires_at();

  private:
  const ::google::protobuf::Timestamp& _internal_expires_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_expires_at();

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.LootDropped)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      58, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::mmorpg::LootItem > items_;
    ::google::protobuf::RepeatedPtrField<std::string> allowed_looters_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    ::google::protobuf::internal::ArenaStringPtr loot_id_;
    ::mmorpg::Vector3* position_;
    ::google::protobuf::Timestamp* expires_at_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};// -------------------------------------------------------------------

class InventoryUpdate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.InventoryUpdate) */ {
 public:
  inline InventoryUpdate() : InventoryUpdate(nullptr) {}
  ~InventoryUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InventoryUpdate(::google::protobuf::internal::ConstantInitialized);

  inline InventoryUpdate(const InventoryUpdate& from)
      : InventoryUpdate(nullptr, from) {}
  InventoryUpdate(InventoryUpdate&& from) noexcept
    : InventoryUpdate() {
    *this = ::std::move(from);
  }

  inline InventoryUpdate& operator=(const InventoryUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline InventoryUpdate& operator=(InventoryUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InventoryUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const InventoryUpdate* internal_default_instance() {
    return reinterpret_cast<const InventoryUpdate*>(
               &_InventoryUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(InventoryUpdate& a, InventoryUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(InventoryUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InventoryUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InventoryUpdate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InventoryUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InventoryUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InventoryUpdate& from) {
    InventoryUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InventoryUpdate* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.InventoryUpdate";
  }
  protected:
  explicit InventoryUpdate(::google::protobuf::Arena* arena);
  InventoryUpdate(::google::protobuf::Arena* arena, const InventoryUpdate& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotsFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
    kTotalSlotsFieldNumber = 3,
    kUsedSlotsFieldNumber = 4,
  };
  // repeated .mmorpg.InventorySlot slots = 2;
  int slots_size() const;
  private:
  int _internal_slots_size() const;

  public:
  void clear_slots() ;
  ::mmorpg::InventorySlot* mutable_slots(int index);
  ::google::protobuf::RepeatedPtrField< ::mmorpg::InventorySlot >*
      mutable_slots();
  private:
  const ::google::protobuf::RepeatedPtrField<::mmorpg::InventorySlot>& _internal_slots() const;
  ::google::protobuf::RepeatedPtrField<::mmorpg::InventorySlot>* _internal_mutable_slots();
  public:
  const ::mmorpg::InventorySlot& slots(int index) const;
  ::mmorpg::InventorySlot* add_slots();
  const ::google::protobuf::RepeatedPtrField< ::mmorpg::InventorySlot >&
      slots() const;
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // int32 total_slots = 3;
  void clear_total_slots() ;
  ::int32_t total_slots() const;
  void set_total_slots(::int32_t value);

  private:
  ::int32_t _internal_total_slots() const;
  void _internal_set_total_slots(::int32_t value);

  public:
  // int32 used_slots = 4;
  void clear_used_slots() ;
  ::int32_t used_slots() const;
  void set_used_slots(::int32_t value);

  private:
  ::int32_t _internal_used_slots() const;
  void _internal_set_used_slots(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.InventoryUpdate)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::mmorpg::InventorySlot > slots_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::int32_t total_slots_;
    ::int32_t used_slots_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GameActionRequest

// string player_id = 1;
inline void GameActionRequest::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& GameActionRequest::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.GameActionRequest.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GameActionRequest::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.GameActionRequest.player_id)
}
inline std::string* GameActionRequest::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.GameActionRequest.player_id)
  return _s;
}
inline const std::string& GameActionRequest::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void GameActionRequest::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* GameActionRequest::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* GameActionRequest::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.GameActionRequest.player_id)
  return _impl_.player_id_.Release();
}
inline void GameActionRequest::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.GameActionRequest.player_id)
}

// .mmorpg.ActionType action_type = 2;
inline void GameActionRequest::clear_action_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.action_type_ = 0;
}
inline ::mmorpg::ActionType GameActionRequest::action_type() const {
  // @@protoc_insertion_point(field_get:mmorpg.GameActionRequest.action_type)
  return _internal_action_type();
}
inline void GameActionRequest::set_action_type(::mmorpg::ActionType value) {
  _internal_set_action_type(value);
  // @@protoc_insertion_point(field_set:mmorpg.GameActionRequest.action_type)
}
inline ::mmorpg::ActionType GameActionRequest::_internal_action_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::ActionType>(_impl_.action_type_);
}
inline void GameActionRequest::_internal_set_action_type(::mmorpg::ActionType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.action_type_ = value;
}

// string target_id = 3;
inline void GameActionRequest::clear_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_id_.ClearToEmpty();
}
inline const std::string& GameActionRequest::target_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.GameActionRequest.target_id)
  return _internal_target_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GameActionRequest::set_target_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.GameActionRequest.target_id)
}
inline std::string* GameActionRequest::mutable_target_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.GameActionRequest.target_id)
  return _s;
}
inline const std::string& GameActionRequest::_internal_target_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_id_.Get();
}
inline void GameActionRequest::_internal_set_target_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_id_.Set(value, GetArena());
}
inline std::string* GameActionRequest::_internal_mutable_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.target_id_.Mutable( GetArena());
}
inline std::string* GameActionRequest::release_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.GameActionRequest.target_id)
  return _impl_.target_id_.Release();
}
inline void GameActionRequest::set_allocated_target_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_id_.IsDefault()) {
          _impl_.target_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.GameActionRequest.target_id)
}

// string action_id = 4;
inline void GameActionRequest::clear_action_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.action_id_.ClearToEmpty();
}
inline const std::string& GameActionRequest::action_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.GameActionRequest.action_id)
  return _internal_action_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GameActionRequest::set_action_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.action_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.GameActionRequest.action_id)
}
inline std::string* GameActionRequest::mutable_action_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_action_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.GameActionRequest.action_id)
  return _s;
}
inline const std::string& GameActionRequest::_internal_action_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.action_id_.Get();
}
inline void GameActionRequest::_internal_set_action_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.action_id_.Set(value, GetArena());
}
inline std::string* GameActionRequest::_internal_mutable_action_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.action_id_.Mutable( GetArena());
}
inline std::string* GameActionRequest::release_action_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.GameActionRequest.action_id)
  return _impl_.action_id_.Release();
}
inline void GameActionRequest::set_allocated_action_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.action_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.action_id_.IsDefault()) {
          _impl_.action_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.GameActionRequest.action_id)
}

// map<string, string> parameters = 5;
inline int GameActionRequest::_internal_parameters_size() const {
  return _internal_parameters().size();
}
inline int GameActionRequest::parameters_size() const {
  return _internal_parameters_size();
}
inline void GameActionRequest::clear_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parameters_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& GameActionRequest::_internal_parameters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parameters_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& GameActionRequest::parameters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:mmorpg.GameActionRequest.parameters)
  return _internal_parameters();
}
inline ::google::protobuf::Map<std::string, std::string>* GameActionRequest::_internal_mutable_parameters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.parameters_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* GameActionRequest::mutable_parameters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:mmorpg.GameActionRequest.parameters)
  return _internal_mutable_parameters();
}

// .google.protobuf.Timestamp timestamp = 6;
inline bool GameActionRequest::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& GameActionRequest::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& GameActionRequest::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.GameActionRequest.timestamp)
  return _internal_timestamp();
}
inline void GameActionRequest::unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.GameActionRequest.timestamp)
}
inline ::google::protobuf::Timestamp* GameActionRequest::release_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* GameActionRequest::unsafe_arena_release_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.GameActionRequest.timestamp)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* GameActionRequest::_internal_mutable_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::google::protobuf::Timestamp* GameActionRequest::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:mmorpg.GameActionRequest.timestamp)
  return _msg;
}
inline void GameActionRequest::set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.GameActionRequest.timestamp)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GameActionResponse

// bool success = 1;
inline void GameActionResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool GameActionResponse::success() const {
  // @@protoc_insertion_point(field_get:mmorpg.GameActionResponse.success)
  return _internal_success();
}
inline void GameActionResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:mmorpg.GameActionResponse.success)
}
inline bool GameActionResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void GameActionResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string action_id = 2;
inline void GameActionResponse::clear_action_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.action_id_.ClearToEmpty();
}
inline const std::string& GameActionResponse::action_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.GameActionResponse.action_id)
  return _internal_action_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GameActionResponse::set_action_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.action_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.GameActionResponse.action_id)
}
inline std::string* GameActionResponse::mutable_action_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_action_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.GameActionResponse.action_id)
  return _s;
}
inline const std::string& GameActionResponse::_internal_action_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.action_id_.Get();
}
inline void GameActionResponse::_internal_set_action_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.action_id_.Set(value, GetArena());
}
inline std::string* GameActionResponse::_internal_mutable_action_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.action_id_.Mutable( GetArena());
}
inline std::string* GameActionResponse::release_action_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.GameActionResponse.action_id)
  return _impl_.action_id_.Release();
}
inline void GameActionResponse::set_allocated_action_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.action_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.action_id_.IsDefault()) {
          _impl_.action_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.GameActionResponse.action_id)
}

// string message = 3;
inline void GameActionResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& GameActionResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.GameActionResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GameActionResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.GameActionResponse.message)
}
inline std::string* GameActionResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:mmorpg.GameActionResponse.message)
  return _s;
}
inline const std::string& GameActionResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void GameActionResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* GameActionResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* GameActionResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.GameActionResponse.message)
  return _impl_.message_.Release();
}
inline void GameActionResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.GameActionResponse.message)
}

// .mmorpg.ErrorCode error_code = 4;
inline void GameActionResponse::clear_error_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_code_ = 0;
}
inline ::mmorpg::ErrorCode GameActionResponse::error_code() const {
  // @@protoc_insertion_point(field_get:mmorpg.GameActionResponse.error_code)
  return _internal_error_code();
}
inline void GameActionResponse::set_error_code(::mmorpg::ErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:mmorpg.GameActionResponse.error_code)
}
inline ::mmorpg::ErrorCode GameActionResponse::_internal_error_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::ErrorCode>(_impl_.error_code_);
}
inline void GameActionResponse::_internal_set_error_code(::mmorpg::ErrorCode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_code_ = value;
}

// map<string, string> results = 5;
inline int GameActionResponse::_internal_results_size() const {
  return _internal_results().size();
}
inline int GameActionResponse::results_size() const {
  return _internal_results_size();
}
inline void GameActionResponse::clear_results() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.results_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& GameActionResponse::_internal_results() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.results_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& GameActionResponse::results() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:mmorpg.GameActionResponse.results)
  return _internal_results();
}
inline ::google::protobuf::Map<std::string, std::string>* GameActionResponse::_internal_mutable_results() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.results_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* GameActionResponse::mutable_results() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:mmorpg.GameActionResponse.results)
  return _internal_mutable_results();
}

// -------------------------------------------------------------------

// InventoryUpdate

// string player_id = 1;
inline void InventoryUpdate::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& InventoryUpdate::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.InventoryUpdate.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InventoryUpdate::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.InventoryUpdate.player_id)
}
inline std::string* InventoryUpdate::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.InventoryUpdate.player_id)
  return _s;
}
inline const std::string& InventoryUpdate::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void InventoryUpdate::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* InventoryUpdate::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* InventoryUpdate::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.InventoryUpdate.player_id)
  return _impl_.player_id_.Release();
}
inline void InventoryUpdate::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.InventoryUpdate.player_id)
}

// repeated .mmorpg.InventorySlot slots = 2;
inline int InventoryUpdate::_internal_slots_size() const {
  return _internal_slots().size();
}
inline int InventoryUpdate::slots_size() const {
  return _internal_slots_size();
}
inline void InventoryUpdate::clear_slots() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.slots_.Clear();
}
inline ::mmorpg::InventorySlot* InventoryUpdate::mutable_slots(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.InventoryUpdate.slots)
  return _internal_mutable_slots()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::InventorySlot>* InventoryUpdate::mutable_slots()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.InventoryUpdate.slots)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_slots();
}
inline const ::mmorpg::InventorySlot& InventoryUpdate::slots(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.InventoryUpdate.slots)
  return _internal_slots().Get(index);
}
inline ::mmorpg::InventorySlot* InventoryUpdate::add_slots() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::mmorpg::InventorySlot* _add = _internal_mutable_slots()->Add();
  // @@protoc_insertion_point(field_add:mmorpg.InventoryUpdate.slots)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::InventorySlot>& InventoryUpdate::slots() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.InventoryUpdate.slots)
  return _internal_slots();
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::InventorySlot>&
InventoryUpdate::_internal_slots() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slots_;
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::InventorySlot>*
InventoryUpdate::_internal_mutable_slots() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.slots_;
}

// int32 total_slots = 3;
inline void InventoryUpdate::clear_total_slots() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_slots_ = 0;
}
inline ::int32_t InventoryUpdate::total_slots() const {
  // @@protoc_insertion_point(field_get:mmorpg.InventoryUpdate.total_slots)
  return _internal_total_slots();
}
inline void InventoryUpdate::set_total_slots(::int32_t value) {
  _internal_set_total_slots(value);
  // @@protoc_insertion_point(field_set:mmorpg.InventoryUpdate.total_slots)
}
inline ::int32_t InventoryUpdate::_internal_total_slots() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_slots_;
}
inline void InventoryUpdate::_internal_set_total_slots(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_slots_ = value;
}

// int32 used_slots = 4;
inline void InventoryUpdate::clear_used_slots() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.used_slots_ = 0;
}
inline ::int32_t InventoryUpdate::used_slots() const {
  // @@protoc_insertion_point(field_get:mmorpg.InventoryUpdate.used_slots)
  return _internal_used_slots();
}
inline void InventoryUpdate::set_used_slots(::int32_t value) {
  _internal_set_used_slots(value);
  // @@protoc_insertion_point(field_set:mmorpg.InventoryUpdate.used_slots)
}
inline ::int32_t InventoryUpdate::_internal_used_slots() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.used_slots_;
}
inline void InventoryUpdate::_internal_set_used_slots(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.used_slots_ = value;
}

// -------------------------------------------------------------------

// InventorySlot

// int32 slot_index = 1;
inline void InventorySlot::clear_slot_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.slot_index_ = 0;
}
inline ::int32_t InventorySlot::slot_index() const {
  // @@protoc_insertion_point(field_get:mmorpg.InventorySlot.slot_index)
  return _internal_slot_index();
}
inline void InventorySlot::set_slot_index(::int32_t value) {
  _internal_set_slot_index(value);
  // @@protoc_insertion_point(field_set:mmorpg.InventorySlot.slot_index)
}
inline ::int32_t InventorySlot::_internal_slot_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slot_index_;
}
inline void InventorySlot::_internal_set_slot_index(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.slot_index_ = value;
}

// .mmorpg.Item item = 2;
inline bool InventorySlot::has_item() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.item_ != nullptr);
  return value;
}
inline void InventorySlot::clear_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.item_ != nullptr) _impl_.item_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mmorpg::Item& InventorySlot::_internal_item() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::mmorpg::Item* p = _impl_.item_;
  return p != nullptr ? *p : reinterpret_cast<const ::mmorpg::Item&>(::mmorpg::_Item_default_instance_);
}
inline const ::mmorpg::Item& InventorySlot::item() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.InventorySlot.item)
  return _internal_item();
}
inline void InventorySlot::unsafe_arena_set_allocated_item(::mmorpg::Item* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.item_);
  }
  _impl_.item_ = reinterpret_cast<::mmorpg::Item*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.InventorySlot.item)
}
inline ::mmorpg::Item* InventorySlot::release_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Item* released = _impl_.item_;
  _impl_.item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::mmorpg::Item* InventorySlot::unsafe_arena_release_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.InventorySlot.item)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Item* temp = _impl_.item_;
  _impl_.item_ = nullptr;
  return temp;
}
inline ::mmorpg::Item* InventorySlot::_internal_mutable_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.item_ == nullptr) {
    auto* p = CreateMaybeMessage<::mmorpg::Item>(GetArena());
    _impl_.item_ = reinterpret_cast<::mmorpg::Item*>(p);
  }
  return _impl_.item_;
}
inline ::mmorpg::Item* InventorySlot::mutable_item() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::Item* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:mmorpg.InventorySlot.item)
  return _msg;
}
inline void InventorySlot::set_allocated_item(::mmorpg::Item* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::mmorpg::Item*>(_impl_.item_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::mmorpg::Item*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.item_ = reinterpret_cast<::mmorpg::Item*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.InventorySlot.item)
}

// int32 quantity = 3;
inline void InventorySlot::clear_quantity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.quantity_ = 0;
}
inline ::int32_t InventorySlot::quantity() const {
  // @@protoc_insertion_point(field_get:mmorpg.InventorySlot.quantity)
  return _internal_quantity();
}
inline void InventorySlot::set_quantity(::int32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:mmorpg.InventorySlot.quantity)
}
inline ::int32_t InventorySlot::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void InventorySlot::_internal_set_quantity(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.quantity_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Item

// string item_id = 1;
inline void Item::clear_item_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_id_.ClearToEmpty();
}
inline const std::string& Item::item_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.Item.item_id)
  return _internal_item_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Item::set_item_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.Item.item_id)
}
inline std::string* Item::mutable_item_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.Item.item_id)
  return _s;
}
inline const std::string& Item::_internal_item_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_id_.Get();
}
inline void Item::_internal_set_item_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_id_.Set(value, GetArena());
}
inline std::string* Item::_internal_mutable_item_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.item_id_.Mutable( GetArena());
}
inline std::string* Item::release_item_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.Item.item_id)
  return _impl_.item_id_.Release();
}
inline void Item::set_allocated_item_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.item_id_.IsDefault()) {
          _impl_.item_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.Item.item_id)
}

// string item_type = 2;
inline void Item::clear_item_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_type_.ClearToEmpty();
}
inline const std::string& Item::item_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.Item.item_type)
  return _internal_item_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Item::set_item_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.Item.item_type)
}
inline std::string* Item::mutable_item_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_item_type();
  // @@protoc_insertion_point(field_mutable:mmorpg.Item.item_type)
  return _s;
}
inline const std::string& Item::_internal_item_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_type_.Get();
}
inline void Item::_internal_set_item_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_type_.Set(value, GetArena());
}
inline std::string* Item::_internal_mutable_item_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.item_type_.Mutable( GetArena());
}
inline std::string* Item::release_item_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.Item.item_type)
  return _impl_.item_type_.Release();
}
inline void Item::set_allocated_item_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.item_type_.IsDefault()) {
          _impl_.item_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.Item.item_type)
}

// string name = 3;
inline void Item::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Item::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.Item.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Item::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.Item.name)
}
inline std::string* Item::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:mmorpg.Item.name)
  return _s;
}
inline const std::string& Item::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Item::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Item::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Item::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.Item.name)
  return _impl_.name_.Release();
}
inline void Item::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.Item.name)
}

// string description = 4;
inline void Item::clear_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& Item::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.Item.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Item::set_description(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.Item.description)
}
inline std::string* Item::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:mmorpg.Item.description)
  return _s;
}
inline const std::string& Item::_internal_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_.Get();
}
inline void Item::_internal_set_description(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(value, GetArena());
}
inline std::string* Item::_internal_mutable_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* Item::release_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.Item.description)
  return _impl_.description_.Release();
}
inline void Item::set_allocated_description(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.Item.description)
}

// string icon_id = 5;
inline void Item::clear_icon_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.icon_id_.ClearToEmpty();
}
inline const std::string& Item::icon_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.Item.icon_id)
  return _internal_icon_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Item::set_icon_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.icon_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.Item.icon_id)
}
inline std::string* Item::mutable_icon_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_icon_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.Item.icon_id)
  return _s;
}
inline const std::string& Item::_internal_icon_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.icon_id_.Get();
}
inline void Item::_internal_set_icon_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.icon_id_.Set(value, GetArena());
}
inline std::string* Item::_internal_mutable_icon_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.icon_id_.Mutable( GetArena());
}
inline std::string* Item::release_icon_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.Item.icon_id)
  return _impl_.icon_id_.Release();
}
inline void Item::set_allocated_icon_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.icon_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.icon_id_.IsDefault()) {
          _impl_.icon_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.Item.icon_id)
}

// .mmorpg.ItemRarity rarity = 6;
inline void Item::clear_rarity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rarity_ = 0;
}
inline ::mmorpg::ItemRarity Item::rarity() const {
  // @@protoc_insertion_point(field_get:mmorpg.Item.rarity)
  return _internal_rarity();
}
inline void Item::set_rarity(::mmorpg::ItemRarity value) {
  _internal_set_rarity(value);
  // @@protoc_insertion_point(field_set:mmorpg.Item.rarity)
}
inline ::mmorpg::ItemRarity Item::_internal_rarity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::ItemRarity>(_impl_.rarity_);
}
inline void Item::_internal_set_rarity(::mmorpg::ItemRarity value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rarity_ = value;
}

// int32 max_stack = 7;
inline void Item::clear_max_stack() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_stack_ = 0;
}
inline ::int32_t Item::max_stack() const {
  // @@protoc_insertion_point(field_get:mmorpg.Item.max_stack)
  return _internal_max_stack();
}
inline void Item::set_max_stack(::int32_t value) {
  _internal_set_max_stack(value);
  // @@protoc_insertion_point(field_set:mmorpg.Item.max_stack)
}
inline ::int32_t Item::_internal_max_stack() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_stack_;
}
inline void Item::_internal_set_max_stack(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_stack_ = value;
}

// bool is_unique = 8;
inline void Item::clear_is_unique() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_unique_ = false;
}
inline bool Item::is_unique() const {
  // @@protoc_insertion_point(field_get:mmorpg.Item.is_unique)
  return _internal_is_unique();
}
inline void Item::set_is_unique(bool value) {
  _internal_set_is_unique(value);
  // @@protoc_insertion_point(field_set:mmorpg.Item.is_unique)
}
inline bool Item::_internal_is_unique() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_unique_;
}
inline void Item::_internal_set_is_unique(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_unique_ = value;
}

// bool is_quest_item = 9;
inline void Item::clear_is_quest_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_quest_item_ = false;
}
inline bool Item::is_quest_item() const {
  // @@protoc_insertion_point(field_get:mmorpg.Item.is_quest_item)
  return _internal_is_quest_item();
}
inline void Item::set_is_quest_item(bool value) {
  _internal_set_is_quest_item(value);
  // @@protoc_insertion_point(field_set:mmorpg.Item.is_quest_item)
}
inline bool Item::_internal_is_quest_item() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_quest_item_;
}
inline void Item::_internal_set_is_quest_item(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_quest_item_ = value;
}

// bool is_bound = 10;
inline void Item::clear_is_bound() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_bound_ = false;
}
inline bool Item::is_bound() const {
  // @@protoc_insertion_point(field_get:mmorpg.Item.is_bound)
  return _internal_is_bound();
}
inline void Item::set_is_bound(bool value) {
  _internal_set_is_bound(value);
  // @@protoc_insertion_point(field_set:mmorpg.Item.is_bound)
}
inline bool Item::_internal_is_bound() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_bound_;
}
inline void Item::_internal_set_is_bound(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_bound_ = value;
}

// int32 required_level = 11;
inline void Item::clear_required_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.required_level_ = 0;
}
inline ::int32_t Item::required_level() const {
  // @@protoc_insertion_point(field_get:mmorpg.Item.required_level)
  return _internal_required_level();
}
inline void Item::set_required_level(::int32_t value) {
  _internal_set_required_level(value);
  // @@protoc_insertion_point(field_set:mmorpg.Item.required_level)
}
inline ::int32_t Item::_internal_required_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.required_level_;
}
inline void Item::_internal_set_required_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.required_level_ = value;
}

// .mmorpg.CharacterClass required_class = 12;
inline void Item::clear_required_class() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.required_class_ = 0;
}
inline ::mmorpg::CharacterClass Item::required_class() const {
  // @@protoc_insertion_point(field_get:mmorpg.Item.required_class)
  return _internal_required_class();
}
inline void Item::set_required_class(::mmorpg::CharacterClass value) {
  _internal_set_required_class(value);
  // @@protoc_insertion_point(field_set:mmorpg.Item.required_class)
}
inline ::mmorpg::CharacterClass Item::_internal_required_class() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::CharacterClass>(_impl_.required_class_);
}
inline void Item::_internal_set_required_class(::mmorpg::CharacterClass value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.required_class_ = value;
}

// map<string, int32> stats = 13;
inline int Item::_internal_stats_size() const {
  return _internal_stats().size();
}
inline int Item::stats_size() const {
  return _internal_stats_size();
}
inline void Item::clear_stats() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stats_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& Item::_internal_stats() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stats_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::int32_t>& Item::stats() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:mmorpg.Item.stats)
  return _internal_stats();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* Item::_internal_mutable_stats() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.stats_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::int32_t>* Item::mutable_stats() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:mmorpg.Item.stats)
  return _internal_mutable_stats();
}

// repeated .mmorpg.ItemEffect effects = 14;
inline int Item::_internal_effects_size() const {
  return _internal_effects().size();
}
inline int Item::effects_size() const {
  return _internal_effects_size();
}
inline void Item::clear_effects() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effects_.Clear();
}
inline ::mmorpg::ItemEffect* Item::mutable_effects(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.Item.effects)
  return _internal_mutable_effects()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::ItemEffect>* Item::mutable_effects()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.Item.effects)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_effects();
}
inline const ::mmorpg::ItemEffect& Item::effects(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.Item.effects)
  return _internal_effects().Get(index);
}
inline ::mmorpg::ItemEffect* Item::add_effects() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::mmorpg::ItemEffect* _add = _internal_mutable_effects()->Add();
  // @@protoc_insertion_point(field_add:mmorpg.Item.effects)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::ItemEffect>& Item::effects() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.Item.effects)
  return _internal_effects();
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::ItemEffect>&
Item::_internal_effects() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effects_;
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::ItemEffect>*
Item::_internal_mutable_effects() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.effects_;
}

// int64 sell_price = 15;
inline void Item::clear_sell_price() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sell_price_ = ::int64_t{0};
}
inline ::int64_t Item::sell_price() const {
  // @@protoc_insertion_point(field_get:mmorpg.Item.sell_price)
  return _internal_sell_price();
}
inline void Item::set_sell_price(::int64_t value) {
  _internal_set_sell_price(value);
  // @@protoc_insertion_point(field_set:mmorpg.Item.sell_price)
}
inline ::int64_t Item::_internal_sell_price() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sell_price_;
}
inline void Item::_internal_set_sell_price(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sell_price_ = value;
}

// int64 buy_price = 16;
inline void Item::clear_buy_price() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.buy_price_ = ::int64_t{0};
}
inline ::int64_t Item::buy_price() const {
  // @@protoc_insertion_point(field_get:mmorpg.Item.buy_price)
  return _internal_buy_price();
}
inline void Item::set_buy_price(::int64_t value) {
  _internal_set_buy_price(value);
  // @@protoc_insertion_point(field_set:mmorpg.Item.buy_price)
}
inline ::int64_t Item::_internal_buy_price() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.buy_price_;
}
inline void Item::_internal_set_buy_price(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.buy_price_ = value;
}

// string equipment_slot = 17;
inline void Item::clear_equipment_slot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.equipment_slot_.ClearToEmpty();
}
inline const std::string& Item::equipment_slot() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.Item.equipment_slot)
  return _internal_equipment_slot();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Item::set_equipment_slot(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.equipment_slot_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.Item.equipment_slot)
}
inline std::string* Item::mutable_equipment_slot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_equipment_slot();
  // @@protoc_insertion_point(field_mutable:mmorpg.Item.equipment_slot)
  return _s;
}
inline const std::string& Item::_internal_equipment_slot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.equipment_slot_.Get();
}
inline void Item::_internal_set_equipment_slot(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.equipment_slot_.Set(value, GetArena());
}
inline std::string* Item::_internal_mutable_equipment_slot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.equipment_slot_.Mutable( GetArena());
}
inline std::string* Item::release_equipment_slot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.Item.equipment_slot)
  return _impl_.equipment_slot_.Release();
}
inline void Item::set_allocated_equipment_slot(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.equipment_slot_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.equipment_slot_.IsDefault()) {
          _impl_.equipment_slot_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.Item.equipment_slot)
}

// int32 durability = 18;
inline void Item::clear_durability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.durability_ = 0;
}
inline ::int32_t Item::durability() const {
  // @@protoc_insertion_point(field_get:mmorpg.Item.durability)
  return _internal_durability();
}
inline void Item::set_durability(::int32_t value) {
  _internal_set_durability(value);
  // @@protoc_insertion_point(field_set:mmorpg.Item.durability)
}
inline ::int32_t Item::_internal_durability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.durability_;
}
inline void Item::_internal_set_durability(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.durability_ = value;
}

// int32 max_durability = 19;
inline void Item::clear_max_durability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_durability_ = 0;
}
inline ::int32_t Item::max_durability() const {
  // @@protoc_insertion_point(field_get:mmorpg.Item.max_durability)
  return _internal_max_durability();
}
inline void Item::set_max_durability(::int32_t value) {
  _internal_set_max_durability(value);
  // @@protoc_insertion_point(field_set:mmorpg.Item.max_durability)
}
inline ::int32_t Item::_internal_max_durability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_durability_;
}
inline void Item::_internal_set_max_durability(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_durability_ = value;
}

// -------------------------------------------------------------------

// ItemEffect

// string effect_type = 1;
inline void ItemEffect::clear_effect_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effect_type_.ClearToEmpty();
}
inline const std::string& ItemEffect::effect_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ItemEffect.effect_type)
  return _internal_effect_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ItemEffect::set_effect_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.effect_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ItemEffect.effect_type)
}
inline std::string* ItemEffect::mutable_effect_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_effect_type();
  // @@protoc_insertion_point(field_mutable:mmorpg.ItemEffect.effect_type)
  return _s;
}
inline const std::string& ItemEffect::_internal_effect_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effect_type_.Get();
}
inline void ItemEffect::_internal_set_effect_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.effect_type_.Set(value, GetArena());
}
inline std::string* ItemEffect::_internal_mutable_effect_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.effect_type_.Mutable( GetArena());
}
inline std::string* ItemEffect::release_effect_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ItemEffect.effect_type)
  return _impl_.effect_type_.Release();
}
inline void ItemEffect::set_allocated_effect_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effect_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.effect_type_.IsDefault()) {
          _impl_.effect_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ItemEffect.effect_type)
}

// int32 value = 2;
inline void ItemEffect::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0;
}
inline ::int32_t ItemEffect::value() const {
  // @@protoc_insertion_point(field_get:mmorpg.ItemEffect.value)
  return _internal_value();
}
inline void ItemEffect::set_value(::int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:mmorpg.ItemEffect.value)
}
inline ::int32_t ItemEffect::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void ItemEffect::_internal_set_value(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// float duration = 3;
inline void ItemEffect::clear_duration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.duration_ = 0;
}
inline float ItemEffect::duration() const {
  // @@protoc_insertion_point(field_get:mmorpg.ItemEffect.duration)
  return _internal_duration();
}
inline void ItemEffect::set_duration(float value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:mmorpg.ItemEffect.duration)
}
inline float ItemEffect::_internal_duration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.duration_;
}
inline void ItemEffect::_internal_set_duration(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.duration_ = value;
}

// float chance = 4;
inline void ItemEffect::clear_chance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.chance_ = 0;
}
inline float ItemEffect::chance() const {
  // @@protoc_insertion_point(field_get:mmorpg.ItemEffect.chance)
  return _internal_chance();
}
inline void ItemEffect::set_chance(float value) {
  _internal_set_chance(value);
  // @@protoc_insertion_point(field_set:mmorpg.ItemEffect.chance)
}
inline float ItemEffect::_internal_chance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.chance_;
}
inline void ItemEffect::_internal_set_chance(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.chance_ = value;
}

// -------------------------------------------------------------------

// StatsUpdate

// string player_id = 1;
inline void StatsUpdate::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& StatsUpdate::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.StatsUpdate.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StatsUpdate::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.StatsUpdate.player_id)
}
inline std::string* StatsUpdate::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.StatsUpdate.player_id)
  return _s;
}
inline const std::string& StatsUpdate::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void StatsUpdate::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* StatsUpdate::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* StatsUpdate::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.StatsUpdate.player_id)
  return _impl_.player_id_.Release();
}
inline void StatsUpdate::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.StatsUpdate.player_id)
}

// .mmorpg.CharacterStats stats = 2;
inline bool StatsUpdate::has_stats() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stats_ != nullptr);
  return value;
}
inline const ::mmorpg::CharacterStats& StatsUpdate::_internal_stats() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::mmorpg::CharacterStats* p = _impl_.stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::mmorpg::CharacterStats&>(::mmorpg::_CharacterStats_default_instance_);
}
inline const ::mmorpg::CharacterStats& StatsUpdate::stats() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.StatsUpdate.stats)
  return _internal_stats();
}
inline void StatsUpdate::unsafe_arena_set_allocated_stats(::mmorpg::CharacterStats* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stats_);
  }
  _impl_.stats_ = reinterpret_cast<::mmorpg::CharacterStats*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.StatsUpdate.stats)
}
inline ::mmorpg::CharacterStats* StatsUpdate::release_stats() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::CharacterStats* released = _impl_.stats_;
  _impl_.stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::mmorpg::CharacterStats* StatsUpdate::unsafe_arena_release_stats() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.StatsUpdate.stats)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::CharacterStats* temp = _impl_.stats_;
  _impl_.stats_ = nullptr;
  return temp;
}
inline ::mmorpg::CharacterStats* StatsUpdate::_internal_mutable_stats() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::mmorpg::CharacterStats>(GetArena());
    _impl_.stats_ = reinterpret_cast<::mmorpg::CharacterStats*>(p);
  }
  return _impl_.stats_;
}
inline ::mmorpg::CharacterStats* StatsUpdate::mutable_stats() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::CharacterStats* _msg = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:mmorpg.StatsUpdate.stats)
  return _msg;
}
inline void StatsUpdate::set_allocated_stats(::mmorpg::CharacterStats* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stats_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.stats_ = reinterpret_cast<::mmorpg::CharacterStats*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.StatsUpdate.stats)
}

// .mmorpg.CharacterAttributes attributes = 3;
inline bool StatsUpdate::has_attributes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.attributes_ != nullptr);
  return value;
}
inline const ::mmorpg::CharacterAttributes& StatsUpdate::_internal_attributes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::mmorpg::CharacterAttributes* p = _impl_.attributes_;
  return p != nullptr ? *p : reinterpret_cast<const ::mmorpg::CharacterAttributes&>(::mmorpg::_CharacterAttributes_default_instance_);
}
inline const ::mmorpg::CharacterAttributes& StatsUpdate::attributes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.StatsUpdate.attributes)
  return _internal_attributes();
}
inline void StatsUpdate::unsafe_arena_set_allocated_attributes(::mmorpg::CharacterAttributes* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.attributes_);
  }
  _impl_.attributes_ = reinterpret_cast<::mmorpg::CharacterAttributes*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.StatsUpdate.attributes)
}
inline ::mmorpg::CharacterAttributes* StatsUpdate::release_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::mmorpg::CharacterAttributes* released = _impl_.attributes_;
  _impl_.attributes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::mmorpg::CharacterAttributes* StatsUpdate::unsafe_arena_release_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.StatsUpdate.attributes)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::mmorpg::CharacterAttributes* temp = _impl_.attributes_;
  _impl_.attributes_ = nullptr;
  return temp;
}
inline ::mmorpg::CharacterAttributes* StatsUpdate::_internal_mutable_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.attributes_ == nullptr) {
    auto* p = CreateMaybeMessage<::mmorpg::CharacterAttributes>(GetArena());
    _impl_.attributes_ = reinterpret_cast<::mmorpg::CharacterAttributes*>(p);
  }
  return _impl_.attributes_;
}
inline ::mmorpg::CharacterAttributes* StatsUpdate::mutable_attributes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::CharacterAttributes* _msg = _internal_mutable_attributes();
  // @@protoc_insertion_point(field_mutable:mmorpg.StatsUpdate.attributes)
  return _msg;
}
inline void StatsUpdate::set_allocated_attributes(::mmorpg::CharacterAttributes* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.attributes_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.attributes_ = reinterpret_cast<::mmorpg::CharacterAttributes*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.StatsUpdate.attributes)
}

// int32 level = 4;
inline void StatsUpdate::clear_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = 0;
}
inline ::int32_t StatsUpdate::level() const {
  // @@protoc_insertion_point(field_get:mmorpg.StatsUpdate.level)
  return _internal_level();
}
inline void StatsUpdate::set_level(::int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:mmorpg.StatsUpdate.level)
}
inline ::int32_t StatsUpdate::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.level_;
}
inline void StatsUpdate::_internal_set_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.level_ = value;
}

// int64 experience = 5;
inline void StatsUpdate::clear_experience() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.experience_ = ::int64_t{0};
}
inline ::int64_t StatsUpdate::experience() const {
  // @@protoc_insertion_point(field_get:mmorpg.StatsUpdate.experience)
  return _internal_experience();
}
inline void StatsUpdate::set_experience(::int64_t value) {
  _internal_set_experience(value);
  // @@protoc_insertion_point(field_set:mmorpg.StatsUpdate.experience)
}
inline ::int64_t StatsUpdate::_internal_experience() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.experience_;
}
inline void StatsUpdate::_internal_set_experience(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.experience_ = value;
}

// int64 experience_to_next_level = 6;
inline void StatsUpdate::clear_experience_to_next_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.experience_to_next_level_ = ::int64_t{0};
}
inline ::int64_t StatsUpdate::experience_to_next_level() const {
  // @@protoc_insertion_point(field_get:mmorpg.StatsUpdate.experience_to_next_level)
  return _internal_experience_to_next_level();
}
inline void StatsUpdate::set_experience_to_next_level(::int64_t value) {
  _internal_set_experience_to_next_level(value);
  // @@protoc_insertion_point(field_set:mmorpg.StatsUpdate.experience_to_next_level)
}
inline ::int64_t StatsUpdate::_internal_experience_to_next_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.experience_to_next_level_;
}
inline void StatsUpdate::_internal_set_experience_to_next_level(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.experience_to_next_level_ = value;
}

// -------------------------------------------------------------------

// QuestUpdate

// string player_id = 1;
inline void QuestUpdate::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& QuestUpdate::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.QuestUpdate.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuestUpdate::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.QuestUpdate.player_id)
}
inline std::string* QuestUpdate::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.QuestUpdate.player_id)
  return _s;
}
inline const std::string& QuestUpdate::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void QuestUpdate::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* QuestUpdate::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* QuestUpdate::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.QuestUpdate.player_id)
  return _impl_.player_id_.Release();
}
inline void QuestUpdate::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.QuestUpdate.player_id)
}

// repeated .mmorpg.QuestInfo active_quests = 2;
inline int QuestUpdate::_internal_active_quests_size() const {
  return _internal_active_quests().size();
}
inline int QuestUpdate::active_quests_size() const {
  return _internal_active_quests_size();
}
inline void QuestUpdate::clear_active_quests() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.active_quests_.Clear();
}
inline ::mmorpg::QuestInfo* QuestUpdate::mutable_active_quests(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.QuestUpdate.active_quests)
  return _internal_mutable_active_quests()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::QuestInfo>* QuestUpdate::mutable_active_quests()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.QuestUpdate.active_quests)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_active_quests();
}
inline const ::mmorpg::QuestInfo& QuestUpdate::active_quests(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.QuestUpdate.active_quests)
  return _internal_active_quests().Get(index);
}
inline ::mmorpg::QuestInfo* QuestUpdate::add_active_quests() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::mmorpg::QuestInfo* _add = _internal_mutable_active_quests()->Add();
  // @@protoc_insertion_point(field_add:mmorpg.QuestUpdate.active_quests)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::QuestInfo>& QuestUpdate::active_quests() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.QuestUpdate.active_quests)
  return _internal_active_quests();
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::QuestInfo>&
QuestUpdate::_internal_active_quests() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.active_quests_;
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::QuestInfo>*
QuestUpdate::_internal_mutable_active_quests() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.active_quests_;
}

// repeated .mmorpg.QuestInfo completed_quests = 3;
inline int QuestUpdate::_internal_completed_quests_size() const {
  return _internal_completed_quests().size();
}
inline int QuestUpdate::completed_quests_size() const {
  return _internal_completed_quests_size();
}
inline void QuestUpdate::clear_completed_quests() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.completed_quests_.Clear();
}
inline ::mmorpg::QuestInfo* QuestUpdate::mutable_completed_quests(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.QuestUpdate.completed_quests)
  return _internal_mutable_completed_quests()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::QuestInfo>* QuestUpdate::mutable_completed_quests()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.QuestUpdate.completed_quests)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_completed_quests();
}
inline const ::mmorpg::QuestInfo& QuestUpdate::completed_quests(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.QuestUpdate.completed_quests)
  return _internal_completed_quests().Get(index);
}
inline ::mmorpg::QuestInfo* QuestUpdate::add_completed_quests() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::mmorpg::QuestInfo* _add = _internal_mutable_completed_quests()->Add();
  // @@protoc_insertion_point(field_add:mmorpg.QuestUpdate.completed_quests)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::QuestInfo>& QuestUpdate::completed_quests() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.QuestUpdate.completed_quests)
  return _internal_completed_quests();
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::QuestInfo>&
QuestUpdate::_internal_completed_quests() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.completed_quests_;
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::QuestInfo>*
QuestUpdate::_internal_mutable_completed_quests() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.completed_quests_;
}

// repeated string available_quest_ids = 4;
inline int QuestUpdate::_internal_available_quest_ids_size() const {
  return _internal_available_quest_ids().size();
}
inline int QuestUpdate::available_quest_ids_size() const {
  return _internal_available_quest_ids_size();
}
inline void QuestUpdate::clear_available_quest_ids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.available_quest_ids_.Clear();
}
inline std::string* QuestUpdate::add_available_quest_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_available_quest_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:mmorpg.QuestUpdate.available_quest_ids)
  return _s;
}
inline const std::string& QuestUpdate::available_quest_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.QuestUpdate.available_quest_ids)
  return _internal_available_quest_ids().Get(index);
}
inline std::string* QuestUpdate::mutable_available_quest_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.QuestUpdate.available_quest_ids)
  return _internal_mutable_available_quest_ids()->Mutable(index);
}
inline void QuestUpdate::set_available_quest_ids(int index, const std::string& value) {
  _internal_mutable_available_quest_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:mmorpg.QuestUpdate.available_quest_ids)
}
inline void QuestUpdate::set_available_quest_ids(int index, std::string&& value) {
  _internal_mutable_available_quest_ids()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:mmorpg.QuestUpdate.available_quest_ids)
}
inline void QuestUpdate::set_available_quest_ids(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_available_quest_ids()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mmorpg.QuestUpdate.available_quest_ids)
}
inline void QuestUpdate::set_available_quest_ids(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_available_quest_ids()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mmorpg.QuestUpdate.available_quest_ids)
}
inline void QuestUpdate::set_available_quest_ids(int index, absl::string_view value) {
  _internal_mutable_available_quest_ids()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:mmorpg.QuestUpdate.available_quest_ids)
}
inline void QuestUpdate::add_available_quest_ids(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_available_quest_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:mmorpg.QuestUpdate.available_quest_ids)
}
inline void QuestUpdate::add_available_quest_ids(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_available_quest_ids()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:mmorpg.QuestUpdate.available_quest_ids)
}
inline void QuestUpdate::add_available_quest_ids(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_available_quest_ids()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mmorpg.QuestUpdate.available_quest_ids)
}
inline void QuestUpdate::add_available_quest_ids(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_available_quest_ids()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mmorpg.QuestUpdate.available_quest_ids)
}
inline void QuestUpdate::add_available_quest_ids(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_available_quest_ids()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:mmorpg.QuestUpdate.available_quest_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
QuestUpdate::available_quest_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.QuestUpdate.available_quest_ids)
  return _internal_available_quest_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
QuestUpdate::mutable_available_quest_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.QuestUpdate.available_quest_ids)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_available_quest_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
QuestUpdate::_internal_available_quest_ids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.available_quest_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
QuestUpdate::_internal_mutable_available_quest_ids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.available_quest_ids_;
}

// -------------------------------------------------------------------

// QuestInfo

// string quest_id = 1;
inline void QuestInfo::clear_quest_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.quest_id_.ClearToEmpty();
}
inline const std::string& QuestInfo::quest_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.QuestInfo.quest_id)
  return _internal_quest_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuestInfo::set_quest_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.quest_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.QuestInfo.quest_id)
}
inline std::string* QuestInfo::mutable_quest_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_quest_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.QuestInfo.quest_id)
  return _s;
}
inline const std::string& QuestInfo::_internal_quest_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quest_id_.Get();
}
inline void QuestInfo::_internal_set_quest_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.quest_id_.Set(value, GetArena());
}
inline std::string* QuestInfo::_internal_mutable_quest_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.quest_id_.Mutable( GetArena());
}
inline std::string* QuestInfo::release_quest_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.QuestInfo.quest_id)
  return _impl_.quest_id_.Release();
}
inline void QuestInfo::set_allocated_quest_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.quest_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quest_id_.IsDefault()) {
          _impl_.quest_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.QuestInfo.quest_id)
}

// string quest_name = 2;
inline void QuestInfo::clear_quest_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.quest_name_.ClearToEmpty();
}
inline const std::string& QuestInfo::quest_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.QuestInfo.quest_name)
  return _internal_quest_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuestInfo::set_quest_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.quest_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.QuestInfo.quest_name)
}
inline std::string* QuestInfo::mutable_quest_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_quest_name();
  // @@protoc_insertion_point(field_mutable:mmorpg.QuestInfo.quest_name)
  return _s;
}
inline const std::string& QuestInfo::_internal_quest_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quest_name_.Get();
}
inline void QuestInfo::_internal_set_quest_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.quest_name_.Set(value, GetArena());
}
inline std::string* QuestInfo::_internal_mutable_quest_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.quest_name_.Mutable( GetArena());
}
inline std::string* QuestInfo::release_quest_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.QuestInfo.quest_name)
  return _impl_.quest_name_.Release();
}
inline void QuestInfo::set_allocated_quest_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.quest_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.quest_name_.IsDefault()) {
          _impl_.quest_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.QuestInfo.quest_name)
}

// string description = 3;
inline void QuestInfo::clear_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& QuestInfo::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.QuestInfo.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuestInfo::set_description(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.QuestInfo.description)
}
inline std::string* QuestInfo::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:mmorpg.QuestInfo.description)
  return _s;
}
inline const std::string& QuestInfo::_internal_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_.Get();
}
inline void QuestInfo::_internal_set_description(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(value, GetArena());
}
inline std::string* QuestInfo::_internal_mutable_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* QuestInfo::release_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.QuestInfo.description)
  return _impl_.description_.Release();
}
inline void QuestInfo::set_allocated_description(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.QuestInfo.description)
}

// .mmorpg.QuestStatus status = 4;
inline void QuestInfo::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = 0;
}
inline ::mmorpg::QuestStatus QuestInfo::status() const {
  // @@protoc_insertion_point(field_get:mmorpg.QuestInfo.status)
  return _internal_status();
}
inline void QuestInfo::set_status(::mmorpg::QuestStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:mmorpg.QuestInfo.status)
}
inline ::mmorpg::QuestStatus QuestInfo::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::QuestStatus>(_impl_.status_);
}
inline void QuestInfo::_internal_set_status(::mmorpg::QuestStatus value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_ = value;
}

// repeated .mmorpg.QuestObjective objectives = 5;
inline int QuestInfo::_internal_objectives_size() const {
  return _internal_objectives().size();
}
inline int QuestInfo::objectives_size() const {
  return _internal_objectives_size();
}
inline void QuestInfo::clear_objectives() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objectives_.Clear();
}
inline ::mmorpg::QuestObjective* QuestInfo::mutable_objectives(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.QuestInfo.objectives)
  return _internal_mutable_objectives()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::QuestObjective>* QuestInfo::mutable_objectives()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.QuestInfo.objectives)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_objectives();
}
inline const ::mmorpg::QuestObjective& QuestInfo::objectives(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.QuestInfo.objectives)
  return _internal_objectives().Get(index);
}
inline ::mmorpg::QuestObjective* QuestInfo::add_objectives() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::mmorpg::QuestObjective* _add = _internal_mutable_objectives()->Add();
  // @@protoc_insertion_point(field_add:mmorpg.QuestInfo.objectives)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::QuestObjective>& QuestInfo::objectives() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.QuestInfo.objectives)
  return _internal_objectives();
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::QuestObjective>&
QuestInfo::_internal_objectives() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objectives_;
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::QuestObjective>*
QuestInfo::_internal_mutable_objectives() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.objectives_;
}

// repeated .mmorpg.QuestReward rewards = 6;
inline int QuestInfo::_internal_rewards_size() const {
  return _internal_rewards().size();
}
inline int QuestInfo::rewards_size() const {
  return _internal_rewards_size();
}
inline void QuestInfo::clear_rewards() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rewards_.Clear();
}
inline ::mmorpg::QuestReward* QuestInfo::mutable_rewards(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.QuestInfo.rewards)
  return _internal_mutable_rewards()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::QuestReward>* QuestInfo::mutable_rewards()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.QuestInfo.rewards)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_rewards();
}
inline const ::mmorpg::QuestReward& QuestInfo::rewards(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.QuestInfo.rewards)
  return _internal_rewards().Get(index);
}
inline ::mmorpg::QuestReward* QuestInfo::add_rewards() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::mmorpg::QuestReward* _add = _internal_mutable_rewards()->Add();
  // @@protoc_insertion_point(field_add:mmorpg.QuestInfo.rewards)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::QuestReward>& QuestInfo::rewards() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.QuestInfo.rewards)
  return _internal_rewards();
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::QuestReward>&
QuestInfo::_internal_rewards() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rewards_;
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::QuestReward>*
QuestInfo::_internal_mutable_rewards() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.rewards_;
}

// int32 recommended_level = 7;
inline void QuestInfo::clear_recommended_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.recommended_level_ = 0;
}
inline ::int32_t QuestInfo::recommended_level() const {
  // @@protoc_insertion_point(field_get:mmorpg.QuestInfo.recommended_level)
  return _internal_recommended_level();
}
inline void QuestInfo::set_recommended_level(::int32_t value) {
  _internal_set_recommended_level(value);
  // @@protoc_insertion_point(field_set:mmorpg.QuestInfo.recommended_level)
}
inline ::int32_t QuestInfo::_internal_recommended_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.recommended_level_;
}
inline void QuestInfo::_internal_set_recommended_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.recommended_level_ = value;
}

// bool is_main_quest = 8;
inline void QuestInfo::clear_is_main_quest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_main_quest_ = false;
}
inline bool QuestInfo::is_main_quest() const {
  // @@protoc_insertion_point(field_get:mmorpg.QuestInfo.is_main_quest)
  return _internal_is_main_quest();
}
inline void QuestInfo::set_is_main_quest(bool value) {
  _internal_set_is_main_quest(value);
  // @@protoc_insertion_point(field_set:mmorpg.QuestInfo.is_main_quest)
}
inline bool QuestInfo::_internal_is_main_quest() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_main_quest_;
}
inline void QuestInfo::_internal_set_is_main_quest(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_main_quest_ = value;
}

// bool is_daily_quest = 9;
inline void QuestInfo::clear_is_daily_quest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_daily_quest_ = false;
}
inline bool QuestInfo::is_daily_quest() const {
  // @@protoc_insertion_point(field_get:mmorpg.QuestInfo.is_daily_quest)
  return _internal_is_daily_quest();
}
inline void QuestInfo::set_is_daily_quest(bool value) {
  _internal_set_is_daily_quest(value);
  // @@protoc_insertion_point(field_set:mmorpg.QuestInfo.is_daily_quest)
}
inline bool QuestInfo::_internal_is_daily_quest() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_daily_quest_;
}
inline void QuestInfo::_internal_set_is_daily_quest(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_daily_quest_ = value;
}

// .google.protobuf.Timestamp accepted_at = 10;
inline bool QuestInfo::has_accepted_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.accepted_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& QuestInfo::_internal_accepted_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.accepted_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& QuestInfo::accepted_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.QuestInfo.accepted_at)
  return _internal_accepted_at();
}
inline void QuestInfo::unsafe_arena_set_allocated_accepted_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.accepted_at_);
  }
  _impl_.accepted_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.QuestInfo.accepted_at)
}
inline ::google::protobuf::Timestamp* QuestInfo::release_accepted_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.accepted_at_;
  _impl_.accepted_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* QuestInfo::unsafe_arena_release_accepted_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.QuestInfo.accepted_at)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.accepted_at_;
  _impl_.accepted_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* QuestInfo::_internal_mutable_accepted_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.accepted_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.accepted_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.accepted_at_;
}
inline ::google::protobuf::Timestamp* QuestInfo::mutable_accepted_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_accepted_at();
  // @@protoc_insertion_point(field_mutable:mmorpg.QuestInfo.accepted_at)
  return _msg;
}
inline void QuestInfo::set_allocated_accepted_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.accepted_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.accepted_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.QuestInfo.accepted_at)
}

// .google.protobuf.Timestamp completed_at = 11;
inline bool QuestInfo::has_completed_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.completed_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& QuestInfo::_internal_completed_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.completed_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& QuestInfo::completed_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.QuestInfo.completed_at)
  return _internal_completed_at();
}
inline void QuestInfo::unsafe_arena_set_allocated_completed_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.completed_at_);
  }
  _impl_.completed_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.QuestInfo.completed_at)
}
inline ::google::protobuf::Timestamp* QuestInfo::release_completed_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.completed_at_;
  _impl_.completed_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* QuestInfo::unsafe_arena_release_completed_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.QuestInfo.completed_at)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.completed_at_;
  _impl_.completed_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* QuestInfo::_internal_mutable_completed_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.completed_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.completed_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.completed_at_;
}
inline ::google::protobuf::Timestamp* QuestInfo::mutable_completed_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_completed_at();
  // @@protoc_insertion_point(field_mutable:mmorpg.QuestInfo.completed_at)
  return _msg;
}
inline void QuestInfo::set_allocated_completed_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.completed_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.completed_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.QuestInfo.completed_at)
}

// -------------------------------------------------------------------

// QuestObjective

// string objective_id = 1;
inline void QuestObjective::clear_objective_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objective_id_.ClearToEmpty();
}
inline const std::string& QuestObjective::objective_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.QuestObjective.objective_id)
  return _internal_objective_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuestObjective::set_objective_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.objective_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.QuestObjective.objective_id)
}
inline std::string* QuestObjective::mutable_objective_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_objective_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.QuestObjective.objective_id)
  return _s;
}
inline const std::string& QuestObjective::_internal_objective_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objective_id_.Get();
}
inline void QuestObjective::_internal_set_objective_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.objective_id_.Set(value, GetArena());
}
inline std::string* QuestObjective::_internal_mutable_objective_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.objective_id_.Mutable( GetArena());
}
inline std::string* QuestObjective::release_objective_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.QuestObjective.objective_id)
  return _impl_.objective_id_.Release();
}
inline void QuestObjective::set_allocated_objective_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objective_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.objective_id_.IsDefault()) {
          _impl_.objective_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.QuestObjective.objective_id)
}

// string description = 2;
inline void QuestObjective::clear_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& QuestObjective::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.QuestObjective.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuestObjective::set_description(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.QuestObjective.description)
}
inline std::string* QuestObjective::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:mmorpg.QuestObjective.description)
  return _s;
}
inline const std::string& QuestObjective::_internal_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_.Get();
}
inline void QuestObjective::_internal_set_description(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(value, GetArena());
}
inline std::string* QuestObjective::_internal_mutable_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* QuestObjective::release_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.QuestObjective.description)
  return _impl_.description_.Release();
}
inline void QuestObjective::set_allocated_description(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.QuestObjective.description)
}

// .mmorpg.ObjectiveType type = 3;
inline void QuestObjective::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::mmorpg::ObjectiveType QuestObjective::type() const {
  // @@protoc_insertion_point(field_get:mmorpg.QuestObjective.type)
  return _internal_type();
}
inline void QuestObjective::set_type(::mmorpg::ObjectiveType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:mmorpg.QuestObjective.type)
}
inline ::mmorpg::ObjectiveType QuestObjective::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::ObjectiveType>(_impl_.type_);
}
inline void QuestObjective::_internal_set_type(::mmorpg::ObjectiveType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// string target_id = 4;
inline void QuestObjective::clear_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_id_.ClearToEmpty();
}
inline const std::string& QuestObjective::target_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.QuestObjective.target_id)
  return _internal_target_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuestObjective::set_target_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.QuestObjective.target_id)
}
inline std::string* QuestObjective::mutable_target_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.QuestObjective.target_id)
  return _s;
}
inline const std::string& QuestObjective::_internal_target_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_id_.Get();
}
inline void QuestObjective::_internal_set_target_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_id_.Set(value, GetArena());
}
inline std::string* QuestObjective::_internal_mutable_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.target_id_.Mutable( GetArena());
}
inline std::string* QuestObjective::release_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.QuestObjective.target_id)
  return _impl_.target_id_.Release();
}
inline void QuestObjective::set_allocated_target_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_id_.IsDefault()) {
          _impl_.target_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.QuestObjective.target_id)
}

// int32 current_progress = 5;
inline void QuestObjective::clear_current_progress() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.current_progress_ = 0;
}
inline ::int32_t QuestObjective::current_progress() const {
  // @@protoc_insertion_point(field_get:mmorpg.QuestObjective.current_progress)
  return _internal_current_progress();
}
inline void QuestObjective::set_current_progress(::int32_t value) {
  _internal_set_current_progress(value);
  // @@protoc_insertion_point(field_set:mmorpg.QuestObjective.current_progress)
}
inline ::int32_t QuestObjective::_internal_current_progress() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.current_progress_;
}
inline void QuestObjective::_internal_set_current_progress(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.current_progress_ = value;
}

// int32 required_progress = 6;
inline void QuestObjective::clear_required_progress() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.required_progress_ = 0;
}
inline ::int32_t QuestObjective::required_progress() const {
  // @@protoc_insertion_point(field_get:mmorpg.QuestObjective.required_progress)
  return _internal_required_progress();
}
inline void QuestObjective::set_required_progress(::int32_t value) {
  _internal_set_required_progress(value);
  // @@protoc_insertion_point(field_set:mmorpg.QuestObjective.required_progress)
}
inline ::int32_t QuestObjective::_internal_required_progress() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.required_progress_;
}
inline void QuestObjective::_internal_set_required_progress(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.required_progress_ = value;
}

// bool is_completed = 7;
inline void QuestObjective::clear_is_completed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_completed_ = false;
}
inline bool QuestObjective::is_completed() const {
  // @@protoc_insertion_point(field_get:mmorpg.QuestObjective.is_completed)
  return _internal_is_completed();
}
inline void QuestObjective::set_is_completed(bool value) {
  _internal_set_is_completed(value);
  // @@protoc_insertion_point(field_set:mmorpg.QuestObjective.is_completed)
}
inline bool QuestObjective::_internal_is_completed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_completed_;
}
inline void QuestObjective::_internal_set_is_completed(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_completed_ = value;
}

// bool is_optional = 8;
inline void QuestObjective::clear_is_optional() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_optional_ = false;
}
inline bool QuestObjective::is_optional() const {
  // @@protoc_insertion_point(field_get:mmorpg.QuestObjective.is_optional)
  return _internal_is_optional();
}
inline void QuestObjective::set_is_optional(bool value) {
  _internal_set_is_optional(value);
  // @@protoc_insertion_point(field_set:mmorpg.QuestObjective.is_optional)
}
inline bool QuestObjective::_internal_is_optional() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_optional_;
}
inline void QuestObjective::_internal_set_is_optional(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_optional_ = value;
}

// -------------------------------------------------------------------

// QuestReward

// .mmorpg.RewardType type = 1;
inline void QuestReward::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::mmorpg::RewardType QuestReward::type() const {
  // @@protoc_insertion_point(field_get:mmorpg.QuestReward.type)
  return _internal_type();
}
inline void QuestReward::set_type(::mmorpg::RewardType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:mmorpg.QuestReward.type)
}
inline ::mmorpg::RewardType QuestReward::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::RewardType>(_impl_.type_);
}
inline void QuestReward::_internal_set_type(::mmorpg::RewardType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// string reward_id = 2;
inline void QuestReward::clear_reward_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reward_id_.ClearToEmpty();
}
inline const std::string& QuestReward::reward_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.QuestReward.reward_id)
  return _internal_reward_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QuestReward::set_reward_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reward_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.QuestReward.reward_id)
}
inline std::string* QuestReward::mutable_reward_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reward_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.QuestReward.reward_id)
  return _s;
}
inline const std::string& QuestReward::_internal_reward_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reward_id_.Get();
}
inline void QuestReward::_internal_set_reward_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reward_id_.Set(value, GetArena());
}
inline std::string* QuestReward::_internal_mutable_reward_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.reward_id_.Mutable( GetArena());
}
inline std::string* QuestReward::release_reward_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.QuestReward.reward_id)
  return _impl_.reward_id_.Release();
}
inline void QuestReward::set_allocated_reward_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reward_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reward_id_.IsDefault()) {
          _impl_.reward_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.QuestReward.reward_id)
}

// int32 quantity = 3;
inline void QuestReward::clear_quantity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.quantity_ = 0;
}
inline ::int32_t QuestReward::quantity() const {
  // @@protoc_insertion_point(field_get:mmorpg.QuestReward.quantity)
  return _internal_quantity();
}
inline void QuestReward::set_quantity(::int32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:mmorpg.QuestReward.quantity)
}
inline ::int32_t QuestReward::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void QuestReward::_internal_set_quantity(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.quantity_ = value;
}

// -------------------------------------------------------------------

// CombatAction

// string attacker_id = 1;
inline void CombatAction::clear_attacker_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.attacker_id_.ClearToEmpty();
}
inline const std::string& CombatAction::attacker_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.CombatAction.attacker_id)
  return _internal_attacker_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CombatAction::set_attacker_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.attacker_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.CombatAction.attacker_id)
}
inline std::string* CombatAction::mutable_attacker_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_attacker_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.CombatAction.attacker_id)
  return _s;
}
inline const std::string& CombatAction::_internal_attacker_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attacker_id_.Get();
}
inline void CombatAction::_internal_set_attacker_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.attacker_id_.Set(value, GetArena());
}
inline std::string* CombatAction::_internal_mutable_attacker_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.attacker_id_.Mutable( GetArena());
}
inline std::string* CombatAction::release_attacker_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.CombatAction.attacker_id)
  return _impl_.attacker_id_.Release();
}
inline void CombatAction::set_allocated_attacker_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.attacker_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.attacker_id_.IsDefault()) {
          _impl_.attacker_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.CombatAction.attacker_id)
}

// string target_id = 2;
inline void CombatAction::clear_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_id_.ClearToEmpty();
}
inline const std::string& CombatAction::target_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.CombatAction.target_id)
  return _internal_target_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CombatAction::set_target_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.CombatAction.target_id)
}
inline std::string* CombatAction::mutable_target_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.CombatAction.target_id)
  return _s;
}
inline const std::string& CombatAction::_internal_target_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_id_.Get();
}
inline void CombatAction::_internal_set_target_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_id_.Set(value, GetArena());
}
inline std::string* CombatAction::_internal_mutable_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.target_id_.Mutable( GetArena());
}
inline std::string* CombatAction::release_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.CombatAction.target_id)
  return _impl_.target_id_.Release();
}
inline void CombatAction::set_allocated_target_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_id_.IsDefault()) {
          _impl_.target_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.CombatAction.target_id)
}

// string skill_id = 3;
inline void CombatAction::clear_skill_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skill_id_.ClearToEmpty();
}
inline const std::string& CombatAction::skill_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.CombatAction.skill_id)
  return _internal_skill_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CombatAction::set_skill_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.skill_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.CombatAction.skill_id)
}
inline std::string* CombatAction::mutable_skill_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_skill_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.CombatAction.skill_id)
  return _s;
}
inline const std::string& CombatAction::_internal_skill_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skill_id_.Get();
}
inline void CombatAction::_internal_set_skill_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.skill_id_.Set(value, GetArena());
}
inline std::string* CombatAction::_internal_mutable_skill_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.skill_id_.Mutable( GetArena());
}
inline std::string* CombatAction::release_skill_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.CombatAction.skill_id)
  return _impl_.skill_id_.Release();
}
inline void CombatAction::set_allocated_skill_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skill_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.skill_id_.IsDefault()) {
          _impl_.skill_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.CombatAction.skill_id)
}

// .mmorpg.CombatActionType action_type = 4;
inline void CombatAction::clear_action_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.action_type_ = 0;
}
inline ::mmorpg::CombatActionType CombatAction::action_type() const {
  // @@protoc_insertion_point(field_get:mmorpg.CombatAction.action_type)
  return _internal_action_type();
}
inline void CombatAction::set_action_type(::mmorpg::CombatActionType value) {
  _internal_set_action_type(value);
  // @@protoc_insertion_point(field_set:mmorpg.CombatAction.action_type)
}
inline ::mmorpg::CombatActionType CombatAction::_internal_action_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::CombatActionType>(_impl_.action_type_);
}
inline void CombatAction::_internal_set_action_type(::mmorpg::CombatActionType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.action_type_ = value;
}

// .google.protobuf.Timestamp timestamp = 5;
inline bool CombatAction::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& CombatAction::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& CombatAction::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.CombatAction.timestamp)
  return _internal_timestamp();
}
inline void CombatAction::unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.CombatAction.timestamp)
}
inline ::google::protobuf::Timestamp* CombatAction::release_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* CombatAction::unsafe_arena_release_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.CombatAction.timestamp)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* CombatAction::_internal_mutable_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::google::protobuf::Timestamp* CombatAction::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:mmorpg.CombatAction.timestamp)
  return _msg;
}
inline void CombatAction::set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.CombatAction.timestamp)
}

// -------------------------------------------------------------------

// CombatResult

// string action_id = 1;
inline void CombatResult::clear_action_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.action_id_.ClearToEmpty();
}
inline const std::string& CombatResult::action_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.CombatResult.action_id)
  return _internal_action_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CombatResult::set_action_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.action_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.CombatResult.action_id)
}
inline std::string* CombatResult::mutable_action_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_action_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.CombatResult.action_id)
  return _s;
}
inline const std::string& CombatResult::_internal_action_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.action_id_.Get();
}
inline void CombatResult::_internal_set_action_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.action_id_.Set(value, GetArena());
}
inline std::string* CombatResult::_internal_mutable_action_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.action_id_.Mutable( GetArena());
}
inline std::string* CombatResult::release_action_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.CombatResult.action_id)
  return _impl_.action_id_.Release();
}
inline void CombatResult::set_allocated_action_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.action_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.action_id_.IsDefault()) {
          _impl_.action_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.CombatResult.action_id)
}

// bool success = 2;
inline void CombatResult::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool CombatResult::success() const {
  // @@protoc_insertion_point(field_get:mmorpg.CombatResult.success)
  return _internal_success();
}
inline void CombatResult::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:mmorpg.CombatResult.success)
}
inline bool CombatResult::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void CombatResult::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// repeated .mmorpg.CombatEffect effects = 3;
inline int CombatResult::_internal_effects_size() const {
  return _internal_effects().size();
}
inline int CombatResult::effects_size() const {
  return _internal_effects_size();
}
inline void CombatResult::clear_effects() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effects_.Clear();
}
inline ::mmorpg::CombatEffect* CombatResult::mutable_effects(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.CombatResult.effects)
  return _internal_mutable_effects()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::CombatEffect>* CombatResult::mutable_effects()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.CombatResult.effects)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_effects();
}
inline const ::mmorpg::CombatEffect& CombatResult::effects(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.CombatResult.effects)
  return _internal_effects().Get(index);
}
inline ::mmorpg::CombatEffect* CombatResult::add_effects() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::mmorpg::CombatEffect* _add = _internal_mutable_effects()->Add();
  // @@protoc_insertion_point(field_add:mmorpg.CombatResult.effects)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::CombatEffect>& CombatResult::effects() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.CombatResult.effects)
  return _internal_effects();
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::CombatEffect>&
CombatResult::_internal_effects() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effects_;
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::CombatEffect>*
CombatResult::_internal_mutable_effects() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.effects_;
}

// string failure_reason = 4;
inline void CombatResult::clear_failure_reason() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.failure_reason_.ClearToEmpty();
}
inline const std::string& CombatResult::failure_reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.CombatResult.failure_reason)
  return _internal_failure_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CombatResult::set_failure_reason(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.failure_reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.CombatResult.failure_reason)
}
inline std::string* CombatResult::mutable_failure_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_failure_reason();
  // @@protoc_insertion_point(field_mutable:mmorpg.CombatResult.failure_reason)
  return _s;
}
inline const std::string& CombatResult::_internal_failure_reason() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.failure_reason_.Get();
}
inline void CombatResult::_internal_set_failure_reason(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.failure_reason_.Set(value, GetArena());
}
inline std::string* CombatResult::_internal_mutable_failure_reason() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.failure_reason_.Mutable( GetArena());
}
inline std::string* CombatResult::release_failure_reason() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.CombatResult.failure_reason)
  return _impl_.failure_reason_.Release();
}
inline void CombatResult::set_allocated_failure_reason(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.failure_reason_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.failure_reason_.IsDefault()) {
          _impl_.failure_reason_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.CombatResult.failure_reason)
}

// -------------------------------------------------------------------

// CombatEffect

// string target_id = 1;
inline void CombatEffect::clear_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_id_.ClearToEmpty();
}
inline const std::string& CombatEffect::target_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.CombatEffect.target_id)
  return _internal_target_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CombatEffect::set_target_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.CombatEffect.target_id)
}
inline std::string* CombatEffect::mutable_target_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.CombatEffect.target_id)
  return _s;
}
inline const std::string& CombatEffect::_internal_target_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_id_.Get();
}
inline void CombatEffect::_internal_set_target_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_id_.Set(value, GetArena());
}
inline std::string* CombatEffect::_internal_mutable_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.target_id_.Mutable( GetArena());
}
inline std::string* CombatEffect::release_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.CombatEffect.target_id)
  return _impl_.target_id_.Release();
}
inline void CombatEffect::set_allocated_target_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_id_.IsDefault()) {
          _impl_.target_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.CombatEffect.target_id)
}

// .mmorpg.CombatEffectType effect_type = 2;
inline void CombatEffect::clear_effect_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effect_type_ = 0;
}
inline ::mmorpg::CombatEffectType CombatEffect::effect_type() const {
  // @@protoc_insertion_point(field_get:mmorpg.CombatEffect.effect_type)
  return _internal_effect_type();
}
inline void CombatEffect::set_effect_type(::mmorpg::CombatEffectType value) {
  _internal_set_effect_type(value);
  // @@protoc_insertion_point(field_set:mmorpg.CombatEffect.effect_type)
}
inline ::mmorpg::CombatEffectType CombatEffect::_internal_effect_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::CombatEffectType>(_impl_.effect_type_);
}
inline void CombatEffect::_internal_set_effect_type(::mmorpg::CombatEffectType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.effect_type_ = value;
}

// int32 value = 3;
inline void CombatEffect::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0;
}
inline ::int32_t CombatEffect::value() const {
  // @@protoc_insertion_point(field_get:mmorpg.CombatEffect.value)
  return _internal_value();
}
inline void CombatEffect::set_value(::int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:mmorpg.CombatEffect.value)
}
inline ::int32_t CombatEffect::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void CombatEffect::_internal_set_value(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// bool is_critical = 4;
inline void CombatEffect::clear_is_critical() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_critical_ = false;
}
inline bool CombatEffect::is_critical() const {
  // @@protoc_insertion_point(field_get:mmorpg.CombatEffect.is_critical)
  return _internal_is_critical();
}
inline void CombatEffect::set_is_critical(bool value) {
  _internal_set_is_critical(value);
  // @@protoc_insertion_point(field_set:mmorpg.CombatEffect.is_critical)
}
inline bool CombatEffect::_internal_is_critical() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_critical_;
}
inline void CombatEffect::_internal_set_is_critical(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_critical_ = value;
}

// bool is_blocked = 5;
inline void CombatEffect::clear_is_blocked() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_blocked_ = false;
}
inline bool CombatEffect::is_blocked() const {
  // @@protoc_insertion_point(field_get:mmorpg.CombatEffect.is_blocked)
  return _internal_is_blocked();
}
inline void CombatEffect::set_is_blocked(bool value) {
  _internal_set_is_blocked(value);
  // @@protoc_insertion_point(field_set:mmorpg.CombatEffect.is_blocked)
}
inline bool CombatEffect::_internal_is_blocked() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_blocked_;
}
inline void CombatEffect::_internal_set_is_blocked(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_blocked_ = value;
}

// bool is_dodged = 6;
inline void CombatEffect::clear_is_dodged() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_dodged_ = false;
}
inline bool CombatEffect::is_dodged() const {
  // @@protoc_insertion_point(field_get:mmorpg.CombatEffect.is_dodged)
  return _internal_is_dodged();
}
inline void CombatEffect::set_is_dodged(bool value) {
  _internal_set_is_dodged(value);
  // @@protoc_insertion_point(field_set:mmorpg.CombatEffect.is_dodged)
}
inline bool CombatEffect::_internal_is_dodged() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_dodged_;
}
inline void CombatEffect::_internal_set_is_dodged(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_dodged_ = value;
}

// bool is_resisted = 7;
inline void CombatEffect::clear_is_resisted() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_resisted_ = false;
}
inline bool CombatEffect::is_resisted() const {
  // @@protoc_insertion_point(field_get:mmorpg.CombatEffect.is_resisted)
  return _internal_is_resisted();
}
inline void CombatEffect::set_is_resisted(bool value) {
  _internal_set_is_resisted(value);
  // @@protoc_insertion_point(field_set:mmorpg.CombatEffect.is_resisted)
}
inline bool CombatEffect::_internal_is_resisted() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_resisted_;
}
inline void CombatEffect::_internal_set_is_resisted(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_resisted_ = value;
}

// -------------------------------------------------------------------

// TradeRequest

// string initiator_id = 1;
inline void TradeRequest::clear_initiator_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.initiator_id_.ClearToEmpty();
}
inline const std::string& TradeRequest::initiator_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.TradeRequest.initiator_id)
  return _internal_initiator_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradeRequest::set_initiator_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.initiator_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.TradeRequest.initiator_id)
}
inline std::string* TradeRequest::mutable_initiator_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_initiator_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.TradeRequest.initiator_id)
  return _s;
}
inline const std::string& TradeRequest::_internal_initiator_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.initiator_id_.Get();
}
inline void TradeRequest::_internal_set_initiator_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.initiator_id_.Set(value, GetArena());
}
inline std::string* TradeRequest::_internal_mutable_initiator_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.initiator_id_.Mutable( GetArena());
}
inline std::string* TradeRequest::release_initiator_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.TradeRequest.initiator_id)
  return _impl_.initiator_id_.Release();
}
inline void TradeRequest::set_allocated_initiator_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.initiator_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.initiator_id_.IsDefault()) {
          _impl_.initiator_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.TradeRequest.initiator_id)
}

// string target_player_id = 2;
inline void TradeRequest::clear_target_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_player_id_.ClearToEmpty();
}
inline const std::string& TradeRequest::target_player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.TradeRequest.target_player_id)
  return _internal_target_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradeRequest::set_target_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.TradeRequest.target_player_id)
}
inline std::string* TradeRequest::mutable_target_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_player_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.TradeRequest.target_player_id)
  return _s;
}
inline const std::string& TradeRequest::_internal_target_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_player_id_.Get();
}
inline void TradeRequest::_internal_set_target_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_player_id_.Set(value, GetArena());
}
inline std::string* TradeRequest::_internal_mutable_target_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.target_player_id_.Mutable( GetArena());
}
inline std::string* TradeRequest::release_target_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.TradeRequest.target_player_id)
  return _impl_.target_player_id_.Release();
}
inline void TradeRequest::set_allocated_target_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_player_id_.IsDefault()) {
          _impl_.target_player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.TradeRequest.target_player_id)
}

// -------------------------------------------------------------------

// TradeUpdate

// string trade_id = 1;
inline void TradeUpdate::clear_trade_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.trade_id_.ClearToEmpty();
}
inline const std::string& TradeUpdate::trade_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.TradeUpdate.trade_id)
  return _internal_trade_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradeUpdate::set_trade_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.trade_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.TradeUpdate.trade_id)
}
inline std::string* TradeUpdate::mutable_trade_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_trade_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.TradeUpdate.trade_id)
  return _s;
}
inline const std::string& TradeUpdate::_internal_trade_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.trade_id_.Get();
}
inline void TradeUpdate::_internal_set_trade_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.trade_id_.Set(value, GetArena());
}
inline std::string* TradeUpdate::_internal_mutable_trade_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.trade_id_.Mutable( GetArena());
}
inline std::string* TradeUpdate::release_trade_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.TradeUpdate.trade_id)
  return _impl_.trade_id_.Release();
}
inline void TradeUpdate::set_allocated_trade_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.trade_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.trade_id_.IsDefault()) {
          _impl_.trade_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.TradeUpdate.trade_id)
}

// .mmorpg.TradeState state = 2;
inline void TradeUpdate::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
}
inline ::mmorpg::TradeState TradeUpdate::state() const {
  // @@protoc_insertion_point(field_get:mmorpg.TradeUpdate.state)
  return _internal_state();
}
inline void TradeUpdate::set_state(::mmorpg::TradeState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:mmorpg.TradeUpdate.state)
}
inline ::mmorpg::TradeState TradeUpdate::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::TradeState>(_impl_.state_);
}
inline void TradeUpdate::_internal_set_state(::mmorpg::TradeState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.state_ = value;
}

// .mmorpg.TradeOffer initiator_offer = 3;
inline bool TradeUpdate::has_initiator_offer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.initiator_offer_ != nullptr);
  return value;
}
inline void TradeUpdate::clear_initiator_offer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.initiator_offer_ != nullptr) _impl_.initiator_offer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mmorpg::TradeOffer& TradeUpdate::_internal_initiator_offer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::mmorpg::TradeOffer* p = _impl_.initiator_offer_;
  return p != nullptr ? *p : reinterpret_cast<const ::mmorpg::TradeOffer&>(::mmorpg::_TradeOffer_default_instance_);
}
inline const ::mmorpg::TradeOffer& TradeUpdate::initiator_offer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.TradeUpdate.initiator_offer)
  return _internal_initiator_offer();
}
inline void TradeUpdate::unsafe_arena_set_allocated_initiator_offer(::mmorpg::TradeOffer* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.initiator_offer_);
  }
  _impl_.initiator_offer_ = reinterpret_cast<::mmorpg::TradeOffer*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.TradeUpdate.initiator_offer)
}
inline ::mmorpg::TradeOffer* TradeUpdate::release_initiator_offer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::TradeOffer* released = _impl_.initiator_offer_;
  _impl_.initiator_offer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::mmorpg::TradeOffer* TradeUpdate::unsafe_arena_release_initiator_offer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.TradeUpdate.initiator_offer)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::TradeOffer* temp = _impl_.initiator_offer_;
  _impl_.initiator_offer_ = nullptr;
  return temp;
}
inline ::mmorpg::TradeOffer* TradeUpdate::_internal_mutable_initiator_offer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.initiator_offer_ == nullptr) {
    auto* p = CreateMaybeMessage<::mmorpg::TradeOffer>(GetArena());
    _impl_.initiator_offer_ = reinterpret_cast<::mmorpg::TradeOffer*>(p);
  }
  return _impl_.initiator_offer_;
}
inline ::mmorpg::TradeOffer* TradeUpdate::mutable_initiator_offer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::TradeOffer* _msg = _internal_mutable_initiator_offer();
  // @@protoc_insertion_point(field_mutable:mmorpg.TradeUpdate.initiator_offer)
  return _msg;
}
inline void TradeUpdate::set_allocated_initiator_offer(::mmorpg::TradeOffer* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::mmorpg::TradeOffer*>(_impl_.initiator_offer_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::mmorpg::TradeOffer*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.initiator_offer_ = reinterpret_cast<::mmorpg::TradeOffer*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.TradeUpdate.initiator_offer)
}

// .mmorpg.TradeOffer target_offer = 4;
inline bool TradeUpdate::has_target_offer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_offer_ != nullptr);
  return value;
}
inline void TradeUpdate::clear_target_offer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.target_offer_ != nullptr) _impl_.target_offer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::mmorpg::TradeOffer& TradeUpdate::_internal_target_offer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::mmorpg::TradeOffer* p = _impl_.target_offer_;
  return p != nullptr ? *p : reinterpret_cast<const ::mmorpg::TradeOffer&>(::mmorpg::_TradeOffer_default_instance_);
}
inline const ::mmorpg::TradeOffer& TradeUpdate::target_offer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.TradeUpdate.target_offer)
  return _internal_target_offer();
}
inline void TradeUpdate::unsafe_arena_set_allocated_target_offer(::mmorpg::TradeOffer* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_offer_);
  }
  _impl_.target_offer_ = reinterpret_cast<::mmorpg::TradeOffer*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.TradeUpdate.target_offer)
}
inline ::mmorpg::TradeOffer* TradeUpdate::release_target_offer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::mmorpg::TradeOffer* released = _impl_.target_offer_;
  _impl_.target_offer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::mmorpg::TradeOffer* TradeUpdate::unsafe_arena_release_target_offer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.TradeUpdate.target_offer)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::mmorpg::TradeOffer* temp = _impl_.target_offer_;
  _impl_.target_offer_ = nullptr;
  return temp;
}
inline ::mmorpg::TradeOffer* TradeUpdate::_internal_mutable_target_offer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.target_offer_ == nullptr) {
    auto* p = CreateMaybeMessage<::mmorpg::TradeOffer>(GetArena());
    _impl_.target_offer_ = reinterpret_cast<::mmorpg::TradeOffer*>(p);
  }
  return _impl_.target_offer_;
}
inline ::mmorpg::TradeOffer* TradeUpdate::mutable_target_offer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::TradeOffer* _msg = _internal_mutable_target_offer();
  // @@protoc_insertion_point(field_mutable:mmorpg.TradeUpdate.target_offer)
  return _msg;
}
inline void TradeUpdate::set_allocated_target_offer(::mmorpg::TradeOffer* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::mmorpg::TradeOffer*>(_impl_.target_offer_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::mmorpg::TradeOffer*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.target_offer_ = reinterpret_cast<::mmorpg::TradeOffer*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.TradeUpdate.target_offer)
}

// -------------------------------------------------------------------

// TradeOffer

// string player_id = 1;
inline void TradeOffer::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& TradeOffer::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.TradeOffer.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradeOffer::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.TradeOffer.player_id)
}
inline std::string* TradeOffer::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.TradeOffer.player_id)
  return _s;
}
inline const std::string& TradeOffer::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void TradeOffer::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* TradeOffer::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* TradeOffer::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.TradeOffer.player_id)
  return _impl_.player_id_.Release();
}
inline void TradeOffer::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.TradeOffer.player_id)
}

// repeated .mmorpg.TradeItem items = 2;
inline int TradeOffer::_internal_items_size() const {
  return _internal_items().size();
}
inline int TradeOffer::items_size() const {
  return _internal_items_size();
}
inline void TradeOffer::clear_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.items_.Clear();
}
inline ::mmorpg::TradeItem* TradeOffer::mutable_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.TradeOffer.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::TradeItem>* TradeOffer::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.TradeOffer.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::mmorpg::TradeItem& TradeOffer::items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.TradeOffer.items)
  return _internal_items().Get(index);
}
inline ::mmorpg::TradeItem* TradeOffer::add_items() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::mmorpg::TradeItem* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:mmorpg.TradeOffer.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::TradeItem>& TradeOffer::items() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.TradeOffer.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::TradeItem>&
TradeOffer::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::TradeItem>*
TradeOffer::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// int64 gold = 3;
inline void TradeOffer::clear_gold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gold_ = ::int64_t{0};
}
inline ::int64_t TradeOffer::gold() const {
  // @@protoc_insertion_point(field_get:mmorpg.TradeOffer.gold)
  return _internal_gold();
}
inline void TradeOffer::set_gold(::int64_t value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:mmorpg.TradeOffer.gold)
}
inline ::int64_t TradeOffer::_internal_gold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gold_;
}
inline void TradeOffer::_internal_set_gold(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.gold_ = value;
}

// bool locked = 4;
inline void TradeOffer::clear_locked() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.locked_ = false;
}
inline bool TradeOffer::locked() const {
  // @@protoc_insertion_point(field_get:mmorpg.TradeOffer.locked)
  return _internal_locked();
}
inline void TradeOffer::set_locked(bool value) {
  _internal_set_locked(value);
  // @@protoc_insertion_point(field_set:mmorpg.TradeOffer.locked)
}
inline bool TradeOffer::_internal_locked() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.locked_;
}
inline void TradeOffer::_internal_set_locked(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.locked_ = value;
}

// bool accepted = 5;
inline void TradeOffer::clear_accepted() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.accepted_ = false;
}
inline bool TradeOffer::accepted() const {
  // @@protoc_insertion_point(field_get:mmorpg.TradeOffer.accepted)
  return _internal_accepted();
}
inline void TradeOffer::set_accepted(bool value) {
  _internal_set_accepted(value);
  // @@protoc_insertion_point(field_set:mmorpg.TradeOffer.accepted)
}
inline bool TradeOffer::_internal_accepted() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.accepted_;
}
inline void TradeOffer::_internal_set_accepted(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.accepted_ = value;
}

// -------------------------------------------------------------------

// TradeItem

// string item_id = 1;
inline void TradeItem::clear_item_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_id_.ClearToEmpty();
}
inline const std::string& TradeItem::item_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.TradeItem.item_id)
  return _internal_item_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TradeItem::set_item_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.TradeItem.item_id)
}
inline std::string* TradeItem::mutable_item_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_item_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.TradeItem.item_id)
  return _s;
}
inline const std::string& TradeItem::_internal_item_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_id_.Get();
}
inline void TradeItem::_internal_set_item_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.item_id_.Set(value, GetArena());
}
inline std::string* TradeItem::_internal_mutable_item_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.item_id_.Mutable( GetArena());
}
inline std::string* TradeItem::release_item_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.TradeItem.item_id)
  return _impl_.item_id_.Release();
}
inline void TradeItem::set_allocated_item_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.item_id_.IsDefault()) {
          _impl_.item_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.TradeItem.item_id)
}

// int32 quantity = 2;
inline void TradeItem::clear_quantity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.quantity_ = 0;
}
inline ::int32_t TradeItem::quantity() const {
  // @@protoc_insertion_point(field_get:mmorpg.TradeItem.quantity)
  return _internal_quantity();
}
inline void TradeItem::set_quantity(::int32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:mmorpg.TradeItem.quantity)
}
inline ::int32_t TradeItem::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void TradeItem::_internal_set_quantity(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.quantity_ = value;
}

// int32 inventory_slot = 3;
inline void TradeItem::clear_inventory_slot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.inventory_slot_ = 0;
}
inline ::int32_t TradeItem::inventory_slot() const {
  // @@protoc_insertion_point(field_get:mmorpg.TradeItem.inventory_slot)
  return _internal_inventory_slot();
}
inline void TradeItem::set_inventory_slot(::int32_t value) {
  _internal_set_inventory_slot(value);
  // @@protoc_insertion_point(field_set:mmorpg.TradeItem.inventory_slot)
}
inline ::int32_t TradeItem::_internal_inventory_slot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.inventory_slot_;
}
inline void TradeItem::_internal_set_inventory_slot(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.inventory_slot_ = value;
}

// -------------------------------------------------------------------

// SkillUseRequest

// string player_id = 1;
inline void SkillUseRequest::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& SkillUseRequest::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.SkillUseRequest.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SkillUseRequest::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.SkillUseRequest.player_id)
}
inline std::string* SkillUseRequest::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.SkillUseRequest.player_id)
  return _s;
}
inline const std::string& SkillUseRequest::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void SkillUseRequest::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* SkillUseRequest::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* SkillUseRequest::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.SkillUseRequest.player_id)
  return _impl_.player_id_.Release();
}
inline void SkillUseRequest::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.SkillUseRequest.player_id)
}

// string skill_id = 2;
inline void SkillUseRequest::clear_skill_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skill_id_.ClearToEmpty();
}
inline const std::string& SkillUseRequest::skill_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.SkillUseRequest.skill_id)
  return _internal_skill_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SkillUseRequest::set_skill_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.skill_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.SkillUseRequest.skill_id)
}
inline std::string* SkillUseRequest::mutable_skill_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_skill_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.SkillUseRequest.skill_id)
  return _s;
}
inline const std::string& SkillUseRequest::_internal_skill_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skill_id_.Get();
}
inline void SkillUseRequest::_internal_set_skill_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.skill_id_.Set(value, GetArena());
}
inline std::string* SkillUseRequest::_internal_mutable_skill_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.skill_id_.Mutable( GetArena());
}
inline std::string* SkillUseRequest::release_skill_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.SkillUseRequest.skill_id)
  return _impl_.skill_id_.Release();
}
inline void SkillUseRequest::set_allocated_skill_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skill_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.skill_id_.IsDefault()) {
          _impl_.skill_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.SkillUseRequest.skill_id)
}

// string target_id = 3;
inline void SkillUseRequest::clear_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_id_.ClearToEmpty();
}
inline const std::string& SkillUseRequest::target_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.SkillUseRequest.target_id)
  return _internal_target_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SkillUseRequest::set_target_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.SkillUseRequest.target_id)
}
inline std::string* SkillUseRequest::mutable_target_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.SkillUseRequest.target_id)
  return _s;
}
inline const std::string& SkillUseRequest::_internal_target_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_id_.Get();
}
inline void SkillUseRequest::_internal_set_target_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_id_.Set(value, GetArena());
}
inline std::string* SkillUseRequest::_internal_mutable_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.target_id_.Mutable( GetArena());
}
inline std::string* SkillUseRequest::release_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.SkillUseRequest.target_id)
  return _impl_.target_id_.Release();
}
inline void SkillUseRequest::set_allocated_target_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_id_.IsDefault()) {
          _impl_.target_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.SkillUseRequest.target_id)
}

// .mmorpg.Vector3 target_position = 4;
inline bool SkillUseRequest::has_target_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_position_ != nullptr);
  return value;
}
inline const ::mmorpg::Vector3& SkillUseRequest::_internal_target_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::mmorpg::Vector3* p = _impl_.target_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::mmorpg::Vector3&>(::mmorpg::_Vector3_default_instance_);
}
inline const ::mmorpg::Vector3& SkillUseRequest::target_position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.SkillUseRequest.target_position)
  return _internal_target_position();
}
inline void SkillUseRequest::unsafe_arena_set_allocated_target_position(::mmorpg::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_position_);
  }
  _impl_.target_position_ = reinterpret_cast<::mmorpg::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.SkillUseRequest.target_position)
}
inline ::mmorpg::Vector3* SkillUseRequest::release_target_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Vector3* released = _impl_.target_position_;
  _impl_.target_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::mmorpg::Vector3* SkillUseRequest::unsafe_arena_release_target_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.SkillUseRequest.target_position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Vector3* temp = _impl_.target_position_;
  _impl_.target_position_ = nullptr;
  return temp;
}
inline ::mmorpg::Vector3* SkillUseRequest::_internal_mutable_target_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::mmorpg::Vector3>(GetArena());
    _impl_.target_position_ = reinterpret_cast<::mmorpg::Vector3*>(p);
  }
  return _impl_.target_position_;
}
inline ::mmorpg::Vector3* SkillUseRequest::mutable_target_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::Vector3* _msg = _internal_mutable_target_position();
  // @@protoc_insertion_point(field_mutable:mmorpg.SkillUseRequest.target_position)
  return _msg;
}
inline void SkillUseRequest::set_allocated_target_position(::mmorpg::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.target_position_ = reinterpret_cast<::mmorpg::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.SkillUseRequest.target_position)
}

// -------------------------------------------------------------------

// SkillUseResult

// bool success = 1;
inline void SkillUseResult::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool SkillUseResult::success() const {
  // @@protoc_insertion_point(field_get:mmorpg.SkillUseResult.success)
  return _internal_success();
}
inline void SkillUseResult::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:mmorpg.SkillUseResult.success)
}
inline bool SkillUseResult::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void SkillUseResult::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string skill_id = 2;
inline void SkillUseResult::clear_skill_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skill_id_.ClearToEmpty();
}
inline const std::string& SkillUseResult::skill_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.SkillUseResult.skill_id)
  return _internal_skill_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SkillUseResult::set_skill_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.skill_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.SkillUseResult.skill_id)
}
inline std::string* SkillUseResult::mutable_skill_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_skill_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.SkillUseResult.skill_id)
  return _s;
}
inline const std::string& SkillUseResult::_internal_skill_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skill_id_.Get();
}
inline void SkillUseResult::_internal_set_skill_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.skill_id_.Set(value, GetArena());
}
inline std::string* SkillUseResult::_internal_mutable_skill_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.skill_id_.Mutable( GetArena());
}
inline std::string* SkillUseResult::release_skill_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.SkillUseResult.skill_id)
  return _impl_.skill_id_.Release();
}
inline void SkillUseResult::set_allocated_skill_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skill_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.skill_id_.IsDefault()) {
          _impl_.skill_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.SkillUseResult.skill_id)
}

// float cooldown = 3;
inline void SkillUseResult::clear_cooldown() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cooldown_ = 0;
}
inline float SkillUseResult::cooldown() const {
  // @@protoc_insertion_point(field_get:mmorpg.SkillUseResult.cooldown)
  return _internal_cooldown();
}
inline void SkillUseResult::set_cooldown(float value) {
  _internal_set_cooldown(value);
  // @@protoc_insertion_point(field_set:mmorpg.SkillUseResult.cooldown)
}
inline float SkillUseResult::_internal_cooldown() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cooldown_;
}
inline void SkillUseResult::_internal_set_cooldown(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cooldown_ = value;
}

// string failure_reason = 4;
inline void SkillUseResult::clear_failure_reason() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.failure_reason_.ClearToEmpty();
}
inline const std::string& SkillUseResult::failure_reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.SkillUseResult.failure_reason)
  return _internal_failure_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SkillUseResult::set_failure_reason(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.failure_reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.SkillUseResult.failure_reason)
}
inline std::string* SkillUseResult::mutable_failure_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_failure_reason();
  // @@protoc_insertion_point(field_mutable:mmorpg.SkillUseResult.failure_reason)
  return _s;
}
inline const std::string& SkillUseResult::_internal_failure_reason() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.failure_reason_.Get();
}
inline void SkillUseResult::_internal_set_failure_reason(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.failure_reason_.Set(value, GetArena());
}
inline std::string* SkillUseResult::_internal_mutable_failure_reason() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.failure_reason_.Mutable( GetArena());
}
inline std::string* SkillUseResult::release_failure_reason() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.SkillUseResult.failure_reason)
  return _impl_.failure_reason_.Release();
}
inline void SkillUseResult::set_allocated_failure_reason(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.failure_reason_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.failure_reason_.IsDefault()) {
          _impl_.failure_reason_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.SkillUseResult.failure_reason)
}

// repeated .mmorpg.CombatEffect effects = 5;
inline int SkillUseResult::_internal_effects_size() const {
  return _internal_effects().size();
}
inline int SkillUseResult::effects_size() const {
  return _internal_effects_size();
}
inline void SkillUseResult::clear_effects() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effects_.Clear();
}
inline ::mmorpg::CombatEffect* SkillUseResult::mutable_effects(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.SkillUseResult.effects)
  return _internal_mutable_effects()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::CombatEffect>* SkillUseResult::mutable_effects()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.SkillUseResult.effects)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_effects();
}
inline const ::mmorpg::CombatEffect& SkillUseResult::effects(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.SkillUseResult.effects)
  return _internal_effects().Get(index);
}
inline ::mmorpg::CombatEffect* SkillUseResult::add_effects() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::mmorpg::CombatEffect* _add = _internal_mutable_effects()->Add();
  // @@protoc_insertion_point(field_add:mmorpg.SkillUseResult.effects)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::CombatEffect>& SkillUseResult::effects() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.SkillUseResult.effects)
  return _internal_effects();
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::CombatEffect>&
SkillUseResult::_internal_effects() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effects_;
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::CombatEffect>*
SkillUseResult::_internal_mutable_effects() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.effects_;
}

// -------------------------------------------------------------------

// LootDropped

// string entity_id = 1;
inline void LootDropped::clear_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entity_id_.ClearToEmpty();
}
inline const std::string& LootDropped::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.LootDropped.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LootDropped::set_entity_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.LootDropped.entity_id)
}
inline std::string* LootDropped::mutable_entity_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.LootDropped.entity_id)
  return _s;
}
inline const std::string& LootDropped::_internal_entity_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.entity_id_.Get();
}
inline void LootDropped::_internal_set_entity_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.entity_id_.Set(value, GetArena());
}
inline std::string* LootDropped::_internal_mutable_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.entity_id_.Mutable( GetArena());
}
inline std::string* LootDropped::release_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.LootDropped.entity_id)
  return _impl_.entity_id_.Release();
}
inline void LootDropped::set_allocated_entity_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entity_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.entity_id_.IsDefault()) {
          _impl_.entity_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.LootDropped.entity_id)
}

// string loot_id = 2;
inline void LootDropped::clear_loot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.loot_id_.ClearToEmpty();
}
inline const std::string& LootDropped::loot_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.LootDropped.loot_id)
  return _internal_loot_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LootDropped::set_loot_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.loot_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.LootDropped.loot_id)
}
inline std::string* LootDropped::mutable_loot_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_loot_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.LootDropped.loot_id)
  return _s;
}
inline const std::string& LootDropped::_internal_loot_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.loot_id_.Get();
}
inline void LootDropped::_internal_set_loot_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.loot_id_.Set(value, GetArena());
}
inline std::string* LootDropped::_internal_mutable_loot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.loot_id_.Mutable( GetArena());
}
inline std::string* LootDropped::release_loot_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.LootDropped.loot_id)
  return _impl_.loot_id_.Release();
}
inline void LootDropped::set_allocated_loot_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.loot_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.loot_id_.IsDefault()) {
          _impl_.loot_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.LootDropped.loot_id)
}

// .mmorpg.Vector3 position = 3;
inline bool LootDropped::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline const ::mmorpg::Vector3& LootDropped::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::mmorpg::Vector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::mmorpg::Vector3&>(::mmorpg::_Vector3_default_instance_);
}
inline const ::mmorpg::Vector3& LootDropped::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.LootDropped.position)
  return _internal_position();
}
inline void LootDropped::unsafe_arena_set_allocated_position(::mmorpg::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::mmorpg::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.LootDropped.position)
}
inline ::mmorpg::Vector3* LootDropped::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Vector3* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::mmorpg::Vector3* LootDropped::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.LootDropped.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::mmorpg::Vector3* LootDropped::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::mmorpg::Vector3>(GetArena());
    _impl_.position_ = reinterpret_cast<::mmorpg::Vector3*>(p);
  }
  return _impl_.position_;
}
inline ::mmorpg::Vector3* LootDropped::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::Vector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:mmorpg.LootDropped.position)
  return _msg;
}
inline void LootDropped::set_allocated_position(::mmorpg::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::mmorpg::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.LootDropped.position)
}

// repeated .mmorpg.LootItem items = 4;
inline int LootDropped::_internal_items_size() const {
  return _internal_items().size();
}
inline int LootDropped::items_size() const {
  return _internal_items_size();
}
inline void LootDropped::clear_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.items_.Clear();
}
inline ::mmorpg::LootItem* LootDropped::mutable_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.LootDropped.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::LootItem>* LootDropped::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.LootDropped.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::mmorpg::LootItem& LootDropped::items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.LootDropped.items)
  return _internal_items().Get(index);
}
inline ::mmorpg::LootItem* LootDropped::add_items() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::mmorpg::LootItem* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:mmorpg.LootDropped.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::LootItem>& LootDropped::items() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.LootDropped.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::LootItem>&
LootDropped::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::LootItem>*
LootDropped::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// repeated string allowed_looters = 5;
inline int LootDropped::_internal_allowed_looters_size() const {
  return _internal_allowed_looters().size();
}
inline int LootDropped::allowed_looters_size() const {
  return _internal_allowed_looters_size();
}
inline void LootDropped::clear_allowed_looters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.allowed_looters_.Clear();
}
inline std::string* LootDropped::add_allowed_looters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_allowed_looters()->Add();
  // @@protoc_insertion_point(field_add_mutable:mmorpg.LootDropped.allowed_looters)
  return _s;
}
inline const std::string& LootDropped::allowed_looters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.LootDropped.allowed_looters)
  return _internal_allowed_looters().Get(index);
}
inline std::string* LootDropped::mutable_allowed_looters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.LootDropped.allowed_looters)
  return _internal_mutable_allowed_looters()->Mutable(index);
}
inline void LootDropped::set_allowed_looters(int index, const std::string& value) {
  _internal_mutable_allowed_looters()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:mmorpg.LootDropped.allowed_looters)
}
inline void LootDropped::set_allowed_looters(int index, std::string&& value) {
  _internal_mutable_allowed_looters()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:mmorpg.LootDropped.allowed_looters)
}
inline void LootDropped::set_allowed_looters(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_allowed_looters()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mmorpg.LootDropped.allowed_looters)
}
inline void LootDropped::set_allowed_looters(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_allowed_looters()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mmorpg.LootDropped.allowed_looters)
}
inline void LootDropped::set_allowed_looters(int index, absl::string_view value) {
  _internal_mutable_allowed_looters()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:mmorpg.LootDropped.allowed_looters)
}
inline void LootDropped::add_allowed_looters(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_allowed_looters()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:mmorpg.LootDropped.allowed_looters)
}
inline void LootDropped::add_allowed_looters(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_allowed_looters()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:mmorpg.LootDropped.allowed_looters)
}
inline void LootDropped::add_allowed_looters(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_allowed_looters()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mmorpg.LootDropped.allowed_looters)
}
inline void LootDropped::add_allowed_looters(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_allowed_looters()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mmorpg.LootDropped.allowed_looters)
}
inline void LootDropped::add_allowed_looters(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_allowed_looters()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:mmorpg.LootDropped.allowed_looters)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
LootDropped::allowed_looters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.LootDropped.allowed_looters)
  return _internal_allowed_looters();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
LootDropped::mutable_allowed_looters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.LootDropped.allowed_looters)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_allowed_looters();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
LootDropped::_internal_allowed_looters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.allowed_looters_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
LootDropped::_internal_mutable_allowed_looters() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.allowed_looters_;
}

// .google.protobuf.Timestamp expires_at = 6;
inline bool LootDropped::has_expires_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expires_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& LootDropped::_internal_expires_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.expires_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& LootDropped::expires_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.LootDropped.expires_at)
  return _internal_expires_at();
}
inline void LootDropped::unsafe_arena_set_allocated_expires_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expires_at_);
  }
  _impl_.expires_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.LootDropped.expires_at)
}
inline ::google::protobuf::Timestamp* LootDropped::release_expires_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.expires_at_;
  _impl_.expires_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* LootDropped::unsafe_arena_release_expires_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.LootDropped.expires_at)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.expires_at_;
  _impl_.expires_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* LootDropped::_internal_mutable_expires_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.expires_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.expires_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.expires_at_;
}
inline ::google::protobuf::Timestamp* LootDropped::mutable_expires_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_expires_at();
  // @@protoc_insertion_point(field_mutable:mmorpg.LootDropped.expires_at)
  return _msg;
}
inline void LootDropped::set_allocated_expires_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expires_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.expires_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.LootDropped.expires_at)
}

// -------------------------------------------------------------------

// LootItem

// .mmorpg.Item item = 1;
inline bool LootItem::has_item() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.item_ != nullptr);
  return value;
}
inline void LootItem::clear_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.item_ != nullptr) _impl_.item_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mmorpg::Item& LootItem::_internal_item() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::mmorpg::Item* p = _impl_.item_;
  return p != nullptr ? *p : reinterpret_cast<const ::mmorpg::Item&>(::mmorpg::_Item_default_instance_);
}
inline const ::mmorpg::Item& LootItem::item() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.LootItem.item)
  return _internal_item();
}
inline void LootItem::unsafe_arena_set_allocated_item(::mmorpg::Item* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.item_);
  }
  _impl_.item_ = reinterpret_cast<::mmorpg::Item*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.LootItem.item)
}
inline ::mmorpg::Item* LootItem::release_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Item* released = _impl_.item_;
  _impl_.item_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::mmorpg::Item* LootItem::unsafe_arena_release_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.LootItem.item)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Item* temp = _impl_.item_;
  _impl_.item_ = nullptr;
  return temp;
}
inline ::mmorpg::Item* LootItem::_internal_mutable_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.item_ == nullptr) {
    auto* p = CreateMaybeMessage<::mmorpg::Item>(GetArena());
    _impl_.item_ = reinterpret_cast<::mmorpg::Item*>(p);
  }
  return _impl_.item_;
}
inline ::mmorpg::Item* LootItem::mutable_item() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::Item* _msg = _internal_mutable_item();
  // @@protoc_insertion_point(field_mutable:mmorpg.LootItem.item)
  return _msg;
}
inline void LootItem::set_allocated_item(::mmorpg::Item* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::mmorpg::Item*>(_impl_.item_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::mmorpg::Item*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.item_ = reinterpret_cast<::mmorpg::Item*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.LootItem.item)
}

// int32 quantity = 2;
inline void LootItem::clear_quantity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.quantity_ = 0;
}
inline ::int32_t LootItem::quantity() const {
  // @@protoc_insertion_point(field_get:mmorpg.LootItem.quantity)
  return _internal_quantity();
}
inline void LootItem::set_quantity(::int32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:mmorpg.LootItem.quantity)
}
inline ::int32_t LootItem::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void LootItem::_internal_set_quantity(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.quantity_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CurrencyUpdate

// string player_id = 1;
inline void CurrencyUpdate::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& CurrencyUpdate::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.CurrencyUpdate.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CurrencyUpdate::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.CurrencyUpdate.player_id)
}
inline std::string* CurrencyUpdate::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.CurrencyUpdate.player_id)
  return _s;
}
inline const std::string& CurrencyUpdate::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void CurrencyUpdate::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* CurrencyUpdate::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* CurrencyUpdate::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.CurrencyUpdate.player_id)
  return _impl_.player_id_.Release();
}
inline void CurrencyUpdate::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.CurrencyUpdate.player_id)
}

// map<string, int64> currencies = 2;
inline int CurrencyUpdate::_internal_currencies_size() const {
  return _internal_currencies().size();
}
inline int CurrencyUpdate::currencies_size() const {
  return _internal_currencies_size();
}
inline void CurrencyUpdate::clear_currencies() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.currencies_.Clear();
}
inline const ::google::protobuf::Map<std::string, ::int64_t>& CurrencyUpdate::_internal_currencies() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.currencies_.GetMap();
}
inline const ::google::protobuf::Map<std::string, ::int64_t>& CurrencyUpdate::currencies() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:mmorpg.CurrencyUpdate.currencies)
  return _internal_currencies();
}
inline ::google::protobuf::Map<std::string, ::int64_t>* CurrencyUpdate::_internal_mutable_currencies() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.currencies_.MutableMap();
}
inline ::google::protobuf::Map<std::string, ::int64_t>* CurrencyUpdate::mutable_currencies() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:mmorpg.CurrencyUpdate.currencies)
  return _internal_mutable_currencies();
}

// -------------------------------------------------------------------

// AchievementUnlocked

// string player_id = 1;
inline void AchievementUnlocked::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& AchievementUnlocked::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.AchievementUnlocked.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AchievementUnlocked::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.AchievementUnlocked.player_id)
}
inline std::string* AchievementUnlocked::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.AchievementUnlocked.player_id)
  return _s;
}
inline const std::string& AchievementUnlocked::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void AchievementUnlocked::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* AchievementUnlocked::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* AchievementUnlocked::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.AchievementUnlocked.player_id)
  return _impl_.player_id_.Release();
}
inline void AchievementUnlocked::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.AchievementUnlocked.player_id)
}

// string achievement_id = 2;
inline void AchievementUnlocked::clear_achievement_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.achievement_id_.ClearToEmpty();
}
inline const std::string& AchievementUnlocked::achievement_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.AchievementUnlocked.achievement_id)
  return _internal_achievement_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AchievementUnlocked::set_achievement_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.achievement_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.AchievementUnlocked.achievement_id)
}
inline std::string* AchievementUnlocked::mutable_achievement_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_achievement_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.AchievementUnlocked.achievement_id)
  return _s;
}
inline const std::string& AchievementUnlocked::_internal_achievement_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.achievement_id_.Get();
}
inline void AchievementUnlocked::_internal_set_achievement_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.achievement_id_.Set(value, GetArena());
}
inline std::string* AchievementUnlocked::_internal_mutable_achievement_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.achievement_id_.Mutable( GetArena());
}
inline std::string* AchievementUnlocked::release_achievement_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.AchievementUnlocked.achievement_id)
  return _impl_.achievement_id_.Release();
}
inline void AchievementUnlocked::set_allocated_achievement_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.achievement_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.achievement_id_.IsDefault()) {
          _impl_.achievement_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.AchievementUnlocked.achievement_id)
}

// string achievement_name = 3;
inline void AchievementUnlocked::clear_achievement_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.achievement_name_.ClearToEmpty();
}
inline const std::string& AchievementUnlocked::achievement_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.AchievementUnlocked.achievement_name)
  return _internal_achievement_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AchievementUnlocked::set_achievement_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.achievement_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.AchievementUnlocked.achievement_name)
}
inline std::string* AchievementUnlocked::mutable_achievement_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_achievement_name();
  // @@protoc_insertion_point(field_mutable:mmorpg.AchievementUnlocked.achievement_name)
  return _s;
}
inline const std::string& AchievementUnlocked::_internal_achievement_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.achievement_name_.Get();
}
inline void AchievementUnlocked::_internal_set_achievement_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.achievement_name_.Set(value, GetArena());
}
inline std::string* AchievementUnlocked::_internal_mutable_achievement_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.achievement_name_.Mutable( GetArena());
}
inline std::string* AchievementUnlocked::release_achievement_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.AchievementUnlocked.achievement_name)
  return _impl_.achievement_name_.Release();
}
inline void AchievementUnlocked::set_allocated_achievement_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.achievement_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.achievement_name_.IsDefault()) {
          _impl_.achievement_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.AchievementUnlocked.achievement_name)
}

// string description = 4;
inline void AchievementUnlocked::clear_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& AchievementUnlocked::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.AchievementUnlocked.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AchievementUnlocked::set_description(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.AchievementUnlocked.description)
}
inline std::string* AchievementUnlocked::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:mmorpg.AchievementUnlocked.description)
  return _s;
}
inline const std::string& AchievementUnlocked::_internal_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_.Get();
}
inline void AchievementUnlocked::_internal_set_description(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.description_.Set(value, GetArena());
}
inline std::string* AchievementUnlocked::_internal_mutable_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* AchievementUnlocked::release_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.AchievementUnlocked.description)
  return _impl_.description_.Release();
}
inline void AchievementUnlocked::set_allocated_description(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.AchievementUnlocked.description)
}

// int32 points = 5;
inline void AchievementUnlocked::clear_points() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.points_ = 0;
}
inline ::int32_t AchievementUnlocked::points() const {
  // @@protoc_insertion_point(field_get:mmorpg.AchievementUnlocked.points)
  return _internal_points();
}
inline void AchievementUnlocked::set_points(::int32_t value) {
  _internal_set_points(value);
  // @@protoc_insertion_point(field_set:mmorpg.AchievementUnlocked.points)
}
inline ::int32_t AchievementUnlocked::_internal_points() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.points_;
}
inline void AchievementUnlocked::_internal_set_points(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.points_ = value;
}

// .google.protobuf.Timestamp unlocked_at = 6;
inline bool AchievementUnlocked::has_unlocked_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.unlocked_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& AchievementUnlocked::_internal_unlocked_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.unlocked_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& AchievementUnlocked::unlocked_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.AchievementUnlocked.unlocked_at)
  return _internal_unlocked_at();
}
inline void AchievementUnlocked::unsafe_arena_set_allocated_unlocked_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.unlocked_at_);
  }
  _impl_.unlocked_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.AchievementUnlocked.unlocked_at)
}
inline ::google::protobuf::Timestamp* AchievementUnlocked::release_unlocked_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.unlocked_at_;
  _impl_.unlocked_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* AchievementUnlocked::unsafe_arena_release_unlocked_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.AchievementUnlocked.unlocked_at)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.unlocked_at_;
  _impl_.unlocked_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* AchievementUnlocked::_internal_mutable_unlocked_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.unlocked_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.unlocked_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.unlocked_at_;
}
inline ::google::protobuf::Timestamp* AchievementUnlocked::mutable_unlocked_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_unlocked_at();
  // @@protoc_insertion_point(field_mutable:mmorpg.AchievementUnlocked.unlocked_at)
  return _msg;
}
inline void AchievementUnlocked::set_allocated_unlocked_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.unlocked_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.unlocked_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.AchievementUnlocked.unlocked_at)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace mmorpg


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::mmorpg::ActionType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mmorpg::ActionType>() {
  return ::mmorpg::ActionType_descriptor();
}
template <>
struct is_proto_enum<::mmorpg::ItemRarity> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mmorpg::ItemRarity>() {
  return ::mmorpg::ItemRarity_descriptor();
}
template <>
struct is_proto_enum<::mmorpg::QuestStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mmorpg::QuestStatus>() {
  return ::mmorpg::QuestStatus_descriptor();
}
template <>
struct is_proto_enum<::mmorpg::ObjectiveType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mmorpg::ObjectiveType>() {
  return ::mmorpg::ObjectiveType_descriptor();
}
template <>
struct is_proto_enum<::mmorpg::RewardType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mmorpg::RewardType>() {
  return ::mmorpg::RewardType_descriptor();
}
template <>
struct is_proto_enum<::mmorpg::CombatActionType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mmorpg::CombatActionType>() {
  return ::mmorpg::CombatActionType_descriptor();
}
template <>
struct is_proto_enum<::mmorpg::CombatEffectType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mmorpg::CombatEffectType>() {
  return ::mmorpg::CombatEffectType_descriptor();
}
template <>
struct is_proto_enum<::mmorpg::TradeState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mmorpg::TradeState>() {
  return ::mmorpg::TradeState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_game_2eproto_2epb_2eh
