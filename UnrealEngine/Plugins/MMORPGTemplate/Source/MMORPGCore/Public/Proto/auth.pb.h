// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: auth.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_auth_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_auth_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
#include "base.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_auth_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_auth_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_auth_2eproto;
namespace mmorpg {
class ChangePasswordRequest;
struct ChangePasswordRequestDefaultTypeInternal;
extern ChangePasswordRequestDefaultTypeInternal _ChangePasswordRequest_default_instance_;
class ChangePasswordResponse;
struct ChangePasswordResponseDefaultTypeInternal;
extern ChangePasswordResponseDefaultTypeInternal _ChangePasswordResponse_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
struct LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class LogoutRequest;
struct LogoutRequestDefaultTypeInternal;
extern LogoutRequestDefaultTypeInternal _LogoutRequest_default_instance_;
class LogoutResponse;
struct LogoutResponseDefaultTypeInternal;
extern LogoutResponseDefaultTypeInternal _LogoutResponse_default_instance_;
class PasswordResetRequest;
struct PasswordResetRequestDefaultTypeInternal;
extern PasswordResetRequestDefaultTypeInternal _PasswordResetRequest_default_instance_;
class PasswordResetResponse;
struct PasswordResetResponseDefaultTypeInternal;
extern PasswordResetResponseDefaultTypeInternal _PasswordResetResponse_default_instance_;
class RefreshTokenRequest;
struct RefreshTokenRequestDefaultTypeInternal;
extern RefreshTokenRequestDefaultTypeInternal _RefreshTokenRequest_default_instance_;
class RefreshTokenResponse;
struct RefreshTokenResponseDefaultTypeInternal;
extern RefreshTokenResponseDefaultTypeInternal _RefreshTokenResponse_default_instance_;
class RegisterRequest;
struct RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class RegisterResponse;
struct RegisterResponseDefaultTypeInternal;
extern RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
class RegisterResponse_FieldErrorsEntry_DoNotUse;
struct RegisterResponse_FieldErrorsEntry_DoNotUseDefaultTypeInternal;
extern RegisterResponse_FieldErrorsEntry_DoNotUseDefaultTypeInternal _RegisterResponse_FieldErrorsEntry_DoNotUse_default_instance_;
class SessionInfo;
struct SessionInfoDefaultTypeInternal;
extern SessionInfoDefaultTypeInternal _SessionInfo_default_instance_;
class UserInfo;
struct UserInfoDefaultTypeInternal;
extern UserInfoDefaultTypeInternal _UserInfo_default_instance_;
}  // namespace mmorpg
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace mmorpg {
enum AccountStatus : int {
  ACCOUNT_STATUS_UNSPECIFIED = 0,
  ACCOUNT_STATUS_ACTIVE = 1,
  ACCOUNT_STATUS_SUSPENDED = 2,
  ACCOUNT_STATUS_BANNED = 3,
  ACCOUNT_STATUS_PENDING_VERIFICATION = 4,
  ACCOUNT_STATUS_DELETED = 5,
  AccountStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AccountStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AccountStatus_IsValid(int value);
extern const uint32_t AccountStatus_internal_data_[];
constexpr AccountStatus AccountStatus_MIN = static_cast<AccountStatus>(0);
constexpr AccountStatus AccountStatus_MAX = static_cast<AccountStatus>(5);
constexpr int AccountStatus_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
AccountStatus_descriptor();
template <typename T>
const std::string& AccountStatus_Name(T value) {
  static_assert(std::is_same<T, AccountStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AccountStatus_Name().");
  return AccountStatus_Name(static_cast<AccountStatus>(value));
}
template <>
inline const std::string& AccountStatus_Name(AccountStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AccountStatus_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool AccountStatus_Parse(absl::string_view name, AccountStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccountStatus>(
      AccountStatus_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class RegisterResponse_FieldErrorsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          RegisterResponse_FieldErrorsEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      RegisterResponse_FieldErrorsEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  RegisterResponse_FieldErrorsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterResponse_FieldErrorsEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit RegisterResponse_FieldErrorsEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const RegisterResponse_FieldErrorsEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const RegisterResponse_FieldErrorsEntry_DoNotUse*>(
        &_RegisterResponse_FieldErrorsEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "mmorpg.RegisterResponse.FieldErrorsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "mmorpg.RegisterResponse.FieldErrorsEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_auth_2eproto;
};
// -------------------------------------------------------------------

class RegisterRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.RegisterRequest) */ {
 public:
  inline RegisterRequest() : RegisterRequest(nullptr) {}
  ~RegisterRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterRequest(::google::protobuf::internal::ConstantInitialized);

  inline RegisterRequest(const RegisterRequest& from)
      : RegisterRequest(nullptr, from) {}
  RegisterRequest(RegisterRequest&& from) noexcept
    : RegisterRequest() {
    *this = ::std::move(from);
  }

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
               &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RegisterRequest& a, RegisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RegisterRequest& from) {
    RegisterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RegisterRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.RegisterRequest";
  }
  protected:
  explicit RegisterRequest(::google::protobuf::Arena* arena);
  RegisterRequest(::google::protobuf::Arena* arena, const RegisterRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kUsernameFieldNumber = 3,
    kClientVersionFieldNumber = 4,
    kReferralCodeFieldNumber = 6,
    kAcceptTermsFieldNumber = 5,
  };
  // string email = 1;
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* value);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // string password = 2;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* value);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // string username = 3;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // string client_version = 4;
  void clear_client_version() ;
  const std::string& client_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_version(Arg_&& arg, Args_... args);
  std::string* mutable_client_version();
  PROTOBUF_NODISCARD std::string* release_client_version();
  void set_allocated_client_version(std::string* value);

  private:
  const std::string& _internal_client_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_version(
      const std::string& value);
  std::string* _internal_mutable_client_version();

  public:
  // optional string referral_code = 6;
  bool has_referral_code() const;
  void clear_referral_code() ;
  const std::string& referral_code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_referral_code(Arg_&& arg, Args_... args);
  std::string* mutable_referral_code();
  PROTOBUF_NODISCARD std::string* release_referral_code();
  void set_allocated_referral_code(std::string* value);

  private:
  const std::string& _internal_referral_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_referral_code(
      const std::string& value);
  std::string* _internal_mutable_referral_code();

  public:
  // bool accept_terms = 5;
  void clear_accept_terms() ;
  bool accept_terms() const;
  void set_accept_terms(bool value);

  private:
  bool _internal_accept_terms() const;
  void _internal_set_accept_terms(bool value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.RegisterRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      79, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr client_version_;
    ::google::protobuf::internal::ArenaStringPtr referral_code_;
    bool accept_terms_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};// -------------------------------------------------------------------

class RefreshTokenResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.RefreshTokenResponse) */ {
 public:
  inline RefreshTokenResponse() : RefreshTokenResponse(nullptr) {}
  ~RefreshTokenResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RefreshTokenResponse(::google::protobuf::internal::ConstantInitialized);

  inline RefreshTokenResponse(const RefreshTokenResponse& from)
      : RefreshTokenResponse(nullptr, from) {}
  RefreshTokenResponse(RefreshTokenResponse&& from) noexcept
    : RefreshTokenResponse() {
    *this = ::std::move(from);
  }

  inline RefreshTokenResponse& operator=(const RefreshTokenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshTokenResponse& operator=(RefreshTokenResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshTokenResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshTokenResponse* internal_default_instance() {
    return reinterpret_cast<const RefreshTokenResponse*>(
               &_RefreshTokenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RefreshTokenResponse& a, RefreshTokenResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshTokenResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshTokenResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshTokenResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshTokenResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RefreshTokenResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RefreshTokenResponse& from) {
    RefreshTokenResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RefreshTokenResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.RefreshTokenResponse";
  }
  protected:
  explicit RefreshTokenResponse(::google::protobuf::Arena* arena);
  RefreshTokenResponse(::google::protobuf::Arena* arena, const RefreshTokenResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccessTokenFieldNumber = 2,
    kRefreshTokenFieldNumber = 3,
    kErrorMessageFieldNumber = 5,
    kSuccessFieldNumber = 1,
    kExpiresInFieldNumber = 4,
    kErrorCodeFieldNumber = 6,
  };
  // string access_token = 2;
  void clear_access_token() ;
  const std::string& access_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_access_token(Arg_&& arg, Args_... args);
  std::string* mutable_access_token();
  PROTOBUF_NODISCARD std::string* release_access_token();
  void set_allocated_access_token(std::string* value);

  private:
  const std::string& _internal_access_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access_token(
      const std::string& value);
  std::string* _internal_mutable_access_token();

  public:
  // string refresh_token = 3;
  void clear_refresh_token() ;
  const std::string& refresh_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_refresh_token(Arg_&& arg, Args_... args);
  std::string* mutable_refresh_token();
  PROTOBUF_NODISCARD std::string* release_refresh_token();
  void set_allocated_refresh_token(std::string* value);

  private:
  const std::string& _internal_refresh_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_refresh_token(
      const std::string& value);
  std::string* _internal_mutable_refresh_token();

  public:
  // string error_message = 5;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // int32 expires_in = 4;
  void clear_expires_in() ;
  ::int32_t expires_in() const;
  void set_expires_in(::int32_t value);

  private:
  ::int32_t _internal_expires_in() const;
  void _internal_set_expires_in(::int32_t value);

  public:
  // .mmorpg.ErrorCode error_code = 6;
  void clear_error_code() ;
  ::mmorpg::ErrorCode error_code() const;
  void set_error_code(::mmorpg::ErrorCode value);

  private:
  ::mmorpg::ErrorCode _internal_error_code() const;
  void _internal_set_error_code(::mmorpg::ErrorCode value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.RefreshTokenResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      74, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr access_token_;
    ::google::protobuf::internal::ArenaStringPtr refresh_token_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    bool success_;
    ::int32_t expires_in_;
    int error_code_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};// -------------------------------------------------------------------

class RefreshTokenRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.RefreshTokenRequest) */ {
 public:
  inline RefreshTokenRequest() : RefreshTokenRequest(nullptr) {}
  ~RefreshTokenRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RefreshTokenRequest(::google::protobuf::internal::ConstantInitialized);

  inline RefreshTokenRequest(const RefreshTokenRequest& from)
      : RefreshTokenRequest(nullptr, from) {}
  RefreshTokenRequest(RefreshTokenRequest&& from) noexcept
    : RefreshTokenRequest() {
    *this = ::std::move(from);
  }

  inline RefreshTokenRequest& operator=(const RefreshTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshTokenRequest& operator=(RefreshTokenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshTokenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshTokenRequest* internal_default_instance() {
    return reinterpret_cast<const RefreshTokenRequest*>(
               &_RefreshTokenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RefreshTokenRequest& a, RefreshTokenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshTokenRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshTokenRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshTokenRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshTokenRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RefreshTokenRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RefreshTokenRequest& from) {
    RefreshTokenRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RefreshTokenRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.RefreshTokenRequest";
  }
  protected:
  explicit RefreshTokenRequest(::google::protobuf::Arena* arena);
  RefreshTokenRequest(::google::protobuf::Arena* arena, const RefreshTokenRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRefreshTokenFieldNumber = 1,
  };
  // string refresh_token = 1;
  void clear_refresh_token() ;
  const std::string& refresh_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_refresh_token(Arg_&& arg, Args_... args);
  std::string* mutable_refresh_token();
  PROTOBUF_NODISCARD std::string* release_refresh_token();
  void set_allocated_refresh_token(std::string* value);

  private:
  const std::string& _internal_refresh_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_refresh_token(
      const std::string& value);
  std::string* _internal_mutable_refresh_token();

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.RefreshTokenRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr refresh_token_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};// -------------------------------------------------------------------

class PasswordResetResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.PasswordResetResponse) */ {
 public:
  inline PasswordResetResponse() : PasswordResetResponse(nullptr) {}
  ~PasswordResetResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PasswordResetResponse(::google::protobuf::internal::ConstantInitialized);

  inline PasswordResetResponse(const PasswordResetResponse& from)
      : PasswordResetResponse(nullptr, from) {}
  PasswordResetResponse(PasswordResetResponse&& from) noexcept
    : PasswordResetResponse() {
    *this = ::std::move(from);
  }

  inline PasswordResetResponse& operator=(const PasswordResetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PasswordResetResponse& operator=(PasswordResetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PasswordResetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PasswordResetResponse* internal_default_instance() {
    return reinterpret_cast<const PasswordResetResponse*>(
               &_PasswordResetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PasswordResetResponse& a, PasswordResetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PasswordResetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PasswordResetResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PasswordResetResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PasswordResetResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PasswordResetResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PasswordResetResponse& from) {
    PasswordResetResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PasswordResetResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.PasswordResetResponse";
  }
  protected:
  explicit PasswordResetResponse(::google::protobuf::Arena* arena);
  PasswordResetResponse(::google::protobuf::Arena* arena, const PasswordResetResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.PasswordResetResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};// -------------------------------------------------------------------

class PasswordResetRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.PasswordResetRequest) */ {
 public:
  inline PasswordResetRequest() : PasswordResetRequest(nullptr) {}
  ~PasswordResetRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PasswordResetRequest(::google::protobuf::internal::ConstantInitialized);

  inline PasswordResetRequest(const PasswordResetRequest& from)
      : PasswordResetRequest(nullptr, from) {}
  PasswordResetRequest(PasswordResetRequest&& from) noexcept
    : PasswordResetRequest() {
    *this = ::std::move(from);
  }

  inline PasswordResetRequest& operator=(const PasswordResetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PasswordResetRequest& operator=(PasswordResetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PasswordResetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PasswordResetRequest* internal_default_instance() {
    return reinterpret_cast<const PasswordResetRequest*>(
               &_PasswordResetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PasswordResetRequest& a, PasswordResetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PasswordResetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PasswordResetRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PasswordResetRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PasswordResetRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PasswordResetRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PasswordResetRequest& from) {
    PasswordResetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PasswordResetRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.PasswordResetRequest";
  }
  protected:
  explicit PasswordResetRequest(::google::protobuf::Arena* arena);
  PasswordResetRequest(::google::protobuf::Arena* arena, const PasswordResetRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 1,
  };
  // string email = 1;
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* value);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.PasswordResetRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr email_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};// -------------------------------------------------------------------

class LogoutResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.LogoutResponse) */ {
 public:
  inline LogoutResponse() : LogoutResponse(nullptr) {}
  ~LogoutResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LogoutResponse(::google::protobuf::internal::ConstantInitialized);

  inline LogoutResponse(const LogoutResponse& from)
      : LogoutResponse(nullptr, from) {}
  LogoutResponse(LogoutResponse&& from) noexcept
    : LogoutResponse() {
    *this = ::std::move(from);
  }

  inline LogoutResponse& operator=(const LogoutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutResponse& operator=(LogoutResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogoutResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutResponse* internal_default_instance() {
    return reinterpret_cast<const LogoutResponse*>(
               &_LogoutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LogoutResponse& a, LogoutResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LogoutResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LogoutResponse& from) {
    LogoutResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LogoutResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.LogoutResponse";
  }
  protected:
  explicit LogoutResponse(::google::protobuf::Arena* arena);
  LogoutResponse(::google::protobuf::Arena* arena, const LogoutResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.LogoutResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      37, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};// -------------------------------------------------------------------

class LogoutRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.LogoutRequest) */ {
 public:
  inline LogoutRequest() : LogoutRequest(nullptr) {}
  ~LogoutRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LogoutRequest(::google::protobuf::internal::ConstantInitialized);

  inline LogoutRequest(const LogoutRequest& from)
      : LogoutRequest(nullptr, from) {}
  LogoutRequest(LogoutRequest&& from) noexcept
    : LogoutRequest() {
    *this = ::std::move(from);
  }

  inline LogoutRequest& operator=(const LogoutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutRequest& operator=(LogoutRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogoutRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutRequest* internal_default_instance() {
    return reinterpret_cast<const LogoutRequest*>(
               &_LogoutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LogoutRequest& a, LogoutRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LogoutRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LogoutRequest& from) {
    LogoutRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LogoutRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.LogoutRequest";
  }
  protected:
  explicit LogoutRequest(::google::protobuf::Arena* arena);
  LogoutRequest(::google::protobuf::Arena* arena, const LogoutRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kLogoutAllDevicesFieldNumber = 2,
  };
  // string session_id = 1;
  void clear_session_id() ;
  const std::string& session_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* value);

  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(
      const std::string& value);
  std::string* _internal_mutable_session_id();

  public:
  // bool logout_all_devices = 2;
  void clear_logout_all_devices() ;
  bool logout_all_devices() const;
  void set_logout_all_devices(bool value);

  private:
  bool _internal_logout_all_devices() const;
  void _internal_set_logout_all_devices(bool value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.LogoutRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      39, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    bool logout_all_devices_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};// -------------------------------------------------------------------

class LoginRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LoginRequest(::google::protobuf::internal::ConstantInitialized);

  inline LoginRequest(const LoginRequest& from)
      : LoginRequest(nullptr, from) {}
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LoginRequest& from) {
    LoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LoginRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.LoginRequest";
  }
  protected:
  explicit LoginRequest(::google::protobuf::Arena* arena);
  LoginRequest(::google::protobuf::Arena* arena, const LoginRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kClientVersionFieldNumber = 3,
    kDeviceIdFieldNumber = 4,
    kPlatformFieldNumber = 5,
  };
  // string email = 1;
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* value);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // string password = 2;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* value);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // string client_version = 3;
  void clear_client_version() ;
  const std::string& client_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_client_version(Arg_&& arg, Args_... args);
  std::string* mutable_client_version();
  PROTOBUF_NODISCARD std::string* release_client_version();
  void set_allocated_client_version(std::string* value);

  private:
  const std::string& _internal_client_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_version(
      const std::string& value);
  std::string* _internal_mutable_client_version();

  public:
  // string device_id = 4;
  void clear_device_id() ;
  const std::string& device_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device_id(Arg_&& arg, Args_... args);
  std::string* mutable_device_id();
  PROTOBUF_NODISCARD std::string* release_device_id();
  void set_allocated_device_id(std::string* value);

  private:
  const std::string& _internal_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_id(
      const std::string& value);
  std::string* _internal_mutable_device_id();

  public:
  // string platform = 5;
  void clear_platform() ;
  const std::string& platform() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_platform(Arg_&& arg, Args_... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* value);

  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(
      const std::string& value);
  std::string* _internal_mutable_platform();

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.LoginRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      72, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    ::google::protobuf::internal::ArenaStringPtr client_version_;
    ::google::protobuf::internal::ArenaStringPtr device_id_;
    ::google::protobuf::internal::ArenaStringPtr platform_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};// -------------------------------------------------------------------

class ChangePasswordResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.ChangePasswordResponse) */ {
 public:
  inline ChangePasswordResponse() : ChangePasswordResponse(nullptr) {}
  ~ChangePasswordResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChangePasswordResponse(::google::protobuf::internal::ConstantInitialized);

  inline ChangePasswordResponse(const ChangePasswordResponse& from)
      : ChangePasswordResponse(nullptr, from) {}
  ChangePasswordResponse(ChangePasswordResponse&& from) noexcept
    : ChangePasswordResponse() {
    *this = ::std::move(from);
  }

  inline ChangePasswordResponse& operator=(const ChangePasswordResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangePasswordResponse& operator=(ChangePasswordResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangePasswordResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangePasswordResponse* internal_default_instance() {
    return reinterpret_cast<const ChangePasswordResponse*>(
               &_ChangePasswordResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ChangePasswordResponse& a, ChangePasswordResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangePasswordResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangePasswordResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangePasswordResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangePasswordResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChangePasswordResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChangePasswordResponse& from) {
    ChangePasswordResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChangePasswordResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.ChangePasswordResponse";
  }
  protected:
  explicit ChangePasswordResponse(::google::protobuf::Arena* arena);
  ChangePasswordResponse(::google::protobuf::Arena* arena, const ChangePasswordResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
    kErrorCodeFieldNumber = 3,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // .mmorpg.ErrorCode error_code = 3;
  void clear_error_code() ;
  ::mmorpg::ErrorCode error_code() const;
  void set_error_code(::mmorpg::ErrorCode value);

  private:
  ::mmorpg::ErrorCode _internal_error_code() const;
  void _internal_set_error_code(::mmorpg::ErrorCode value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.ChangePasswordResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool success_;
    int error_code_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};// -------------------------------------------------------------------

class ChangePasswordRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.ChangePasswordRequest) */ {
 public:
  inline ChangePasswordRequest() : ChangePasswordRequest(nullptr) {}
  ~ChangePasswordRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChangePasswordRequest(::google::protobuf::internal::ConstantInitialized);

  inline ChangePasswordRequest(const ChangePasswordRequest& from)
      : ChangePasswordRequest(nullptr, from) {}
  ChangePasswordRequest(ChangePasswordRequest&& from) noexcept
    : ChangePasswordRequest() {
    *this = ::std::move(from);
  }

  inline ChangePasswordRequest& operator=(const ChangePasswordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangePasswordRequest& operator=(ChangePasswordRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangePasswordRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangePasswordRequest* internal_default_instance() {
    return reinterpret_cast<const ChangePasswordRequest*>(
               &_ChangePasswordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ChangePasswordRequest& a, ChangePasswordRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangePasswordRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangePasswordRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangePasswordRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangePasswordRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChangePasswordRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChangePasswordRequest& from) {
    ChangePasswordRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChangePasswordRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.ChangePasswordRequest";
  }
  protected:
  explicit ChangePasswordRequest(::google::protobuf::Arena* arena);
  ChangePasswordRequest(::google::protobuf::Arena* arena, const ChangePasswordRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentPasswordFieldNumber = 1,
    kNewPasswordFieldNumber = 2,
    kSessionIdFieldNumber = 3,
  };
  // string current_password = 1;
  void clear_current_password() ;
  const std::string& current_password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_current_password(Arg_&& arg, Args_... args);
  std::string* mutable_current_password();
  PROTOBUF_NODISCARD std::string* release_current_password();
  void set_allocated_current_password(std::string* value);

  private:
  const std::string& _internal_current_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_password(
      const std::string& value);
  std::string* _internal_mutable_current_password();

  public:
  // string new_password = 2;
  void clear_new_password() ;
  const std::string& new_password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_new_password(Arg_&& arg, Args_... args);
  std::string* mutable_new_password();
  PROTOBUF_NODISCARD std::string* release_new_password();
  void set_allocated_new_password(std::string* value);

  private:
  const std::string& _internal_new_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_password(
      const std::string& value);
  std::string* _internal_mutable_new_password();

  public:
  // string session_id = 3;
  void clear_session_id() ;
  const std::string& session_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* value);

  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(
      const std::string& value);
  std::string* _internal_mutable_session_id();

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.ChangePasswordRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      75, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr current_password_;
    ::google::protobuf::internal::ArenaStringPtr new_password_;
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};// -------------------------------------------------------------------

class UserInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.UserInfo) */ {
 public:
  inline UserInfo() : UserInfo(nullptr) {}
  ~UserInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserInfo(::google::protobuf::internal::ConstantInitialized);

  inline UserInfo(const UserInfo& from)
      : UserInfo(nullptr, from) {}
  UserInfo(UserInfo&& from) noexcept
    : UserInfo() {
    *this = ::std::move(from);
  }

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserInfo& operator=(UserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserInfo* internal_default_instance() {
    return reinterpret_cast<const UserInfo*>(
               &_UserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UserInfo& a, UserInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UserInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserInfo& from) {
    UserInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.UserInfo";
  }
  protected:
  explicit UserInfo(::google::protobuf::Arena* arena);
  UserInfo(::google::protobuf::Arena* arena, const UserInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRolesFieldNumber = 8,
    kUserIdFieldNumber = 1,
    kEmailFieldNumber = 2,
    kUsernameFieldNumber = 3,
    kCreatedAtFieldNumber = 4,
    kLastLoginFieldNumber = 5,
    kPremiumExpiresFieldNumber = 12,
    kAccountStatusFieldNumber = 7,
    kEmailVerifiedFieldNumber = 6,
    kIsPremiumFieldNumber = 11,
    kMaxCharactersFieldNumber = 9,
    kCharacterCountFieldNumber = 10,
  };
  // repeated string roles = 8;
  int roles_size() const;
  private:
  int _internal_roles_size() const;

  public:
  void clear_roles() ;
  const std::string& roles(int index) const;
  std::string* mutable_roles(int index);
  void set_roles(int index, const std::string& value);
  void set_roles(int index, std::string&& value);
  void set_roles(int index, const char* value);
  void set_roles(int index, const char* value, std::size_t size);
  void set_roles(int index, absl::string_view value);
  std::string* add_roles();
  void add_roles(const std::string& value);
  void add_roles(std::string&& value);
  void add_roles(const char* value);
  void add_roles(const char* value, std::size_t size);
  void add_roles(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& roles() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_roles();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_roles() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_roles();

  public:
  // string user_id = 1;
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* value);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // string email = 2;
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* value);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // string username = 3;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // .google.protobuf.Timestamp created_at = 4;
  bool has_created_at() const;
  void clear_created_at() ;
  const ::google::protobuf::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_created_at();
  ::google::protobuf::Timestamp* mutable_created_at();
  void set_allocated_created_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_created_at();

  private:
  const ::google::protobuf::Timestamp& _internal_created_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_created_at();

  public:
  // .google.protobuf.Timestamp last_login = 5;
  bool has_last_login() const;
  void clear_last_login() ;
  const ::google::protobuf::Timestamp& last_login() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_last_login();
  ::google::protobuf::Timestamp* mutable_last_login();
  void set_allocated_last_login(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_last_login(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_last_login();

  private:
  const ::google::protobuf::Timestamp& _internal_last_login() const;
  ::google::protobuf::Timestamp* _internal_mutable_last_login();

  public:
  // .google.protobuf.Timestamp premium_expires = 12;
  bool has_premium_expires() const;
  void clear_premium_expires() ;
  const ::google::protobuf::Timestamp& premium_expires() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_premium_expires();
  ::google::protobuf::Timestamp* mutable_premium_expires();
  void set_allocated_premium_expires(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_premium_expires(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_premium_expires();

  private:
  const ::google::protobuf::Timestamp& _internal_premium_expires() const;
  ::google::protobuf::Timestamp* _internal_mutable_premium_expires();

  public:
  // .mmorpg.AccountStatus account_status = 7;
  void clear_account_status() ;
  ::mmorpg::AccountStatus account_status() const;
  void set_account_status(::mmorpg::AccountStatus value);

  private:
  ::mmorpg::AccountStatus _internal_account_status() const;
  void _internal_set_account_status(::mmorpg::AccountStatus value);

  public:
  // bool email_verified = 6;
  void clear_email_verified() ;
  bool email_verified() const;
  void set_email_verified(bool value);

  private:
  bool _internal_email_verified() const;
  void _internal_set_email_verified(bool value);

  public:
  // bool is_premium = 11;
  void clear_is_premium() ;
  bool is_premium() const;
  void set_is_premium(bool value);

  private:
  bool _internal_is_premium() const;
  void _internal_set_is_premium(bool value);

  public:
  // int32 max_characters = 9;
  void clear_max_characters() ;
  ::int32_t max_characters() const;
  void set_max_characters(::int32_t value);

  private:
  ::int32_t _internal_max_characters() const;
  void _internal_set_max_characters(::int32_t value);

  public:
  // int32 character_count = 10;
  void clear_character_count() ;
  ::int32_t character_count() const;
  void set_character_count(::int32_t value);

  private:
  ::int32_t _internal_character_count() const;
  void _internal_set_character_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.UserInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 3,
      57, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> roles_;
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::Timestamp* created_at_;
    ::google::protobuf::Timestamp* last_login_;
    ::google::protobuf::Timestamp* premium_expires_;
    int account_status_;
    bool email_verified_;
    bool is_premium_;
    ::int32_t max_characters_;
    ::int32_t character_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};// -------------------------------------------------------------------

class SessionInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.SessionInfo) */ {
 public:
  inline SessionInfo() : SessionInfo(nullptr) {}
  ~SessionInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SessionInfo(::google::protobuf::internal::ConstantInitialized);

  inline SessionInfo(const SessionInfo& from)
      : SessionInfo(nullptr, from) {}
  SessionInfo(SessionInfo&& from) noexcept
    : SessionInfo() {
    *this = ::std::move(from);
  }

  inline SessionInfo& operator=(const SessionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionInfo& operator=(SessionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionInfo* internal_default_instance() {
    return reinterpret_cast<const SessionInfo*>(
               &_SessionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SessionInfo& a, SessionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SessionInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SessionInfo& from) {
    SessionInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SessionInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.SessionInfo";
  }
  protected:
  explicit SessionInfo(::google::protobuf::Arena* arena);
  SessionInfo(::google::protobuf::Arena* arena, const SessionInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kDeviceIdFieldNumber = 3,
    kIpAddressFieldNumber = 4,
    kUserAgentFieldNumber = 5,
    kCreatedAtFieldNumber = 6,
    kLastActiveFieldNumber = 7,
    kExpiresAtFieldNumber = 8,
  };
  // string session_id = 1;
  void clear_session_id() ;
  const std::string& session_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* value);

  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(
      const std::string& value);
  std::string* _internal_mutable_session_id();

  public:
  // string user_id = 2;
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* value);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // string device_id = 3;
  void clear_device_id() ;
  const std::string& device_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_device_id(Arg_&& arg, Args_... args);
  std::string* mutable_device_id();
  PROTOBUF_NODISCARD std::string* release_device_id();
  void set_allocated_device_id(std::string* value);

  private:
  const std::string& _internal_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_id(
      const std::string& value);
  std::string* _internal_mutable_device_id();

  public:
  // string ip_address = 4;
  void clear_ip_address() ;
  const std::string& ip_address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip_address(Arg_&& arg, Args_... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* value);

  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(
      const std::string& value);
  std::string* _internal_mutable_ip_address();

  public:
  // string user_agent = 5;
  void clear_user_agent() ;
  const std::string& user_agent() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_agent(Arg_&& arg, Args_... args);
  std::string* mutable_user_agent();
  PROTOBUF_NODISCARD std::string* release_user_agent();
  void set_allocated_user_agent(std::string* value);

  private:
  const std::string& _internal_user_agent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_agent(
      const std::string& value);
  std::string* _internal_mutable_user_agent();

  public:
  // .google.protobuf.Timestamp created_at = 6;
  bool has_created_at() const;
  void clear_created_at() ;
  const ::google::protobuf::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_created_at();
  ::google::protobuf::Timestamp* mutable_created_at();
  void set_allocated_created_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_created_at();

  private:
  const ::google::protobuf::Timestamp& _internal_created_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_created_at();

  public:
  // .google.protobuf.Timestamp last_active = 7;
  bool has_last_active() const;
  void clear_last_active() ;
  const ::google::protobuf::Timestamp& last_active() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_last_active();
  ::google::protobuf::Timestamp* mutable_last_active();
  void set_allocated_last_active(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_last_active(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_last_active();

  private:
  const ::google::protobuf::Timestamp& _internal_last_active() const;
  ::google::protobuf::Timestamp* _internal_mutable_last_active();

  public:
  // .google.protobuf.Timestamp expires_at = 8;
  bool has_expires_at() const;
  void clear_expires_at() ;
  const ::google::protobuf::Timestamp& expires_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_expires_at();
  ::google::protobuf::Timestamp* mutable_expires_at();
  void set_allocated_expires_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_expires_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_expires_at();

  private:
  const ::google::protobuf::Timestamp& _internal_expires_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_expires_at();

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.SessionInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 3,
      81, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::ArenaStringPtr device_id_;
    ::google::protobuf::internal::ArenaStringPtr ip_address_;
    ::google::protobuf::internal::ArenaStringPtr user_agent_;
    ::google::protobuf::Timestamp* created_at_;
    ::google::protobuf::Timestamp* last_active_;
    ::google::protobuf::Timestamp* expires_at_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};// -------------------------------------------------------------------

class RegisterResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.RegisterResponse) */ {
 public:
  inline RegisterResponse() : RegisterResponse(nullptr) {}
  ~RegisterResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterResponse(::google::protobuf::internal::ConstantInitialized);

  inline RegisterResponse(const RegisterResponse& from)
      : RegisterResponse(nullptr, from) {}
  RegisterResponse(RegisterResponse&& from) noexcept
    : RegisterResponse() {
    *this = ::std::move(from);
  }

  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterResponse& operator=(RegisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterResponse*>(
               &_RegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RegisterResponse& a, RegisterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RegisterResponse& from) {
    RegisterResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RegisterResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.RegisterResponse";
  }
  protected:
  explicit RegisterResponse(::google::protobuf::Arena* arena);
  RegisterResponse(::google::protobuf::Arena* arena, const RegisterResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kFieldErrorsFieldNumber = 5,
    kUserIdFieldNumber = 2,
    kErrorMessageFieldNumber = 3,
    kSuccessFieldNumber = 1,
    kErrorCodeFieldNumber = 4,
  };
  // map<string, string> field_errors = 5;
  int field_errors_size() const;
  private:
  int _internal_field_errors_size() const;

  public:
  void clear_field_errors() ;
  const ::google::protobuf::Map<std::string, std::string>& field_errors() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_field_errors();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_field_errors() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_field_errors();

  public:
  // string user_id = 2;
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* value);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // string error_message = 3;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // .mmorpg.ErrorCode error_code = 4;
  void clear_error_code() ;
  ::mmorpg::ErrorCode error_code() const;
  void set_error_code(::mmorpg::ErrorCode value);

  private:
  ::mmorpg::ErrorCode _internal_error_code() const;
  void _internal_set_error_code(::mmorpg::ErrorCode value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.RegisterResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 5, 1,
      64, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::MapField<RegisterResponse_FieldErrorsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        field_errors_;
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    bool success_;
    int error_code_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};// -------------------------------------------------------------------

class LoginResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.LoginResponse) */ {
 public:
  inline LoginResponse() : LoginResponse(nullptr) {}
  ~LoginResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LoginResponse(::google::protobuf::internal::ConstantInitialized);

  inline LoginResponse(const LoginResponse& from)
      : LoginResponse(nullptr, from) {}
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LoginResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LoginResponse& from) {
    LoginResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LoginResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.LoginResponse";
  }
  protected:
  explicit LoginResponse(::google::protobuf::Arena* arena);
  LoginResponse(::google::protobuf::Arena* arena, const LoginResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccessTokenFieldNumber = 2,
    kRefreshTokenFieldNumber = 3,
    kSessionIdFieldNumber = 4,
    kErrorMessageFieldNumber = 6,
    kUserInfoFieldNumber = 8,
    kSuccessFieldNumber = 1,
    kExpiresInFieldNumber = 5,
    kErrorCodeFieldNumber = 7,
  };
  // string access_token = 2;
  void clear_access_token() ;
  const std::string& access_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_access_token(Arg_&& arg, Args_... args);
  std::string* mutable_access_token();
  PROTOBUF_NODISCARD std::string* release_access_token();
  void set_allocated_access_token(std::string* value);

  private:
  const std::string& _internal_access_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access_token(
      const std::string& value);
  std::string* _internal_mutable_access_token();

  public:
  // string refresh_token = 3;
  void clear_refresh_token() ;
  const std::string& refresh_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_refresh_token(Arg_&& arg, Args_... args);
  std::string* mutable_refresh_token();
  PROTOBUF_NODISCARD std::string* release_refresh_token();
  void set_allocated_refresh_token(std::string* value);

  private:
  const std::string& _internal_refresh_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_refresh_token(
      const std::string& value);
  std::string* _internal_mutable_refresh_token();

  public:
  // string session_id = 4;
  void clear_session_id() ;
  const std::string& session_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* value);

  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(
      const std::string& value);
  std::string* _internal_mutable_session_id();

  public:
  // string error_message = 6;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // .mmorpg.UserInfo user_info = 8;
  bool has_user_info() const;
  void clear_user_info() ;
  const ::mmorpg::UserInfo& user_info() const;
  PROTOBUF_NODISCARD ::mmorpg::UserInfo* release_user_info();
  ::mmorpg::UserInfo* mutable_user_info();
  void set_allocated_user_info(::mmorpg::UserInfo* value);
  void unsafe_arena_set_allocated_user_info(::mmorpg::UserInfo* value);
  ::mmorpg::UserInfo* unsafe_arena_release_user_info();

  private:
  const ::mmorpg::UserInfo& _internal_user_info() const;
  ::mmorpg::UserInfo* _internal_mutable_user_info();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // int32 expires_in = 5;
  void clear_expires_in() ;
  ::int32_t expires_in() const;
  void set_expires_in(::int32_t value);

  private:
  ::int32_t _internal_expires_in() const;
  void _internal_set_expires_in(::int32_t value);

  public:
  // .mmorpg.ErrorCode error_code = 7;
  void clear_error_code() ;
  ::mmorpg::ErrorCode error_code() const;
  void set_error_code(::mmorpg::ErrorCode value);

  private:
  ::mmorpg::ErrorCode _internal_error_code() const;
  void _internal_set_error_code(::mmorpg::ErrorCode value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.LoginResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 1,
      85, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr access_token_;
    ::google::protobuf::internal::ArenaStringPtr refresh_token_;
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    ::mmorpg::UserInfo* user_info_;
    bool success_;
    ::int32_t expires_in_;
    int error_code_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// LoginRequest

// string email = 1;
inline void LoginRequest::clear_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.email_.ClearToEmpty();
}
inline const std::string& LoginRequest::email() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.LoginRequest.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoginRequest::set_email(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.LoginRequest.email)
}
inline std::string* LoginRequest::mutable_email() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:mmorpg.LoginRequest.email)
  return _s;
}
inline const std::string& LoginRequest::_internal_email() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.email_.Get();
}
inline void LoginRequest::_internal_set_email(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.email_.Set(value, GetArena());
}
inline std::string* LoginRequest::_internal_mutable_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.email_.Mutable( GetArena());
}
inline std::string* LoginRequest::release_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.LoginRequest.email)
  return _impl_.email_.Release();
}
inline void LoginRequest::set_allocated_email(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.email_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.email_.IsDefault()) {
          _impl_.email_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.LoginRequest.email)
}

// string password = 2;
inline void LoginRequest::clear_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.password_.ClearToEmpty();
}
inline const std::string& LoginRequest::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.LoginRequest.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoginRequest::set_password(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.LoginRequest.password)
}
inline std::string* LoginRequest::mutable_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:mmorpg.LoginRequest.password)
  return _s;
}
inline const std::string& LoginRequest::_internal_password() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.password_.Get();
}
inline void LoginRequest::_internal_set_password(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.password_.Set(value, GetArena());
}
inline std::string* LoginRequest::_internal_mutable_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.password_.Mutable( GetArena());
}
inline std::string* LoginRequest::release_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.LoginRequest.password)
  return _impl_.password_.Release();
}
inline void LoginRequest::set_allocated_password(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.password_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.LoginRequest.password)
}

// string client_version = 3;
inline void LoginRequest::clear_client_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.client_version_.ClearToEmpty();
}
inline const std::string& LoginRequest::client_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.LoginRequest.client_version)
  return _internal_client_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoginRequest::set_client_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.client_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.LoginRequest.client_version)
}
inline std::string* LoginRequest::mutable_client_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_client_version();
  // @@protoc_insertion_point(field_mutable:mmorpg.LoginRequest.client_version)
  return _s;
}
inline const std::string& LoginRequest::_internal_client_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.client_version_.Get();
}
inline void LoginRequest::_internal_set_client_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.client_version_.Set(value, GetArena());
}
inline std::string* LoginRequest::_internal_mutable_client_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.client_version_.Mutable( GetArena());
}
inline std::string* LoginRequest::release_client_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.LoginRequest.client_version)
  return _impl_.client_version_.Release();
}
inline void LoginRequest::set_allocated_client_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.client_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_version_.IsDefault()) {
          _impl_.client_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.LoginRequest.client_version)
}

// string device_id = 4;
inline void LoginRequest::clear_device_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_id_.ClearToEmpty();
}
inline const std::string& LoginRequest::device_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.LoginRequest.device_id)
  return _internal_device_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoginRequest::set_device_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.LoginRequest.device_id)
}
inline std::string* LoginRequest::mutable_device_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.LoginRequest.device_id)
  return _s;
}
inline const std::string& LoginRequest::_internal_device_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_id_.Get();
}
inline void LoginRequest::_internal_set_device_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_id_.Set(value, GetArena());
}
inline std::string* LoginRequest::_internal_mutable_device_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.device_id_.Mutable( GetArena());
}
inline std::string* LoginRequest::release_device_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.LoginRequest.device_id)
  return _impl_.device_id_.Release();
}
inline void LoginRequest::set_allocated_device_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_id_.IsDefault()) {
          _impl_.device_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.LoginRequest.device_id)
}

// string platform = 5;
inline void LoginRequest::clear_platform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.platform_.ClearToEmpty();
}
inline const std::string& LoginRequest::platform() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.LoginRequest.platform)
  return _internal_platform();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoginRequest::set_platform(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.platform_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.LoginRequest.platform)
}
inline std::string* LoginRequest::mutable_platform() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:mmorpg.LoginRequest.platform)
  return _s;
}
inline const std::string& LoginRequest::_internal_platform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.platform_.Get();
}
inline void LoginRequest::_internal_set_platform(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.platform_.Set(value, GetArena());
}
inline std::string* LoginRequest::_internal_mutable_platform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.platform_.Mutable( GetArena());
}
inline std::string* LoginRequest::release_platform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.LoginRequest.platform)
  return _impl_.platform_.Release();
}
inline void LoginRequest::set_allocated_platform(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.platform_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.platform_.IsDefault()) {
          _impl_.platform_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.LoginRequest.platform)
}

// -------------------------------------------------------------------

// LoginResponse

// bool success = 1;
inline void LoginResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool LoginResponse::success() const {
  // @@protoc_insertion_point(field_get:mmorpg.LoginResponse.success)
  return _internal_success();
}
inline void LoginResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:mmorpg.LoginResponse.success)
}
inline bool LoginResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void LoginResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string access_token = 2;
inline void LoginResponse::clear_access_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.access_token_.ClearToEmpty();
}
inline const std::string& LoginResponse::access_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.LoginResponse.access_token)
  return _internal_access_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoginResponse::set_access_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.access_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.LoginResponse.access_token)
}
inline std::string* LoginResponse::mutable_access_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_access_token();
  // @@protoc_insertion_point(field_mutable:mmorpg.LoginResponse.access_token)
  return _s;
}
inline const std::string& LoginResponse::_internal_access_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.access_token_.Get();
}
inline void LoginResponse::_internal_set_access_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.access_token_.Set(value, GetArena());
}
inline std::string* LoginResponse::_internal_mutable_access_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.access_token_.Mutable( GetArena());
}
inline std::string* LoginResponse::release_access_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.LoginResponse.access_token)
  return _impl_.access_token_.Release();
}
inline void LoginResponse::set_allocated_access_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.access_token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.access_token_.IsDefault()) {
          _impl_.access_token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.LoginResponse.access_token)
}

// string refresh_token = 3;
inline void LoginResponse::clear_refresh_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.refresh_token_.ClearToEmpty();
}
inline const std::string& LoginResponse::refresh_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.LoginResponse.refresh_token)
  return _internal_refresh_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoginResponse::set_refresh_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.refresh_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.LoginResponse.refresh_token)
}
inline std::string* LoginResponse::mutable_refresh_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_refresh_token();
  // @@protoc_insertion_point(field_mutable:mmorpg.LoginResponse.refresh_token)
  return _s;
}
inline const std::string& LoginResponse::_internal_refresh_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.refresh_token_.Get();
}
inline void LoginResponse::_internal_set_refresh_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.refresh_token_.Set(value, GetArena());
}
inline std::string* LoginResponse::_internal_mutable_refresh_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.refresh_token_.Mutable( GetArena());
}
inline std::string* LoginResponse::release_refresh_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.LoginResponse.refresh_token)
  return _impl_.refresh_token_.Release();
}
inline void LoginResponse::set_allocated_refresh_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.refresh_token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.refresh_token_.IsDefault()) {
          _impl_.refresh_token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.LoginResponse.refresh_token)
}

// string session_id = 4;
inline void LoginResponse::clear_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& LoginResponse::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.LoginResponse.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoginResponse::set_session_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.session_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.LoginResponse.session_id)
}
inline std::string* LoginResponse::mutable_session_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.LoginResponse.session_id)
  return _s;
}
inline const std::string& LoginResponse::_internal_session_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.session_id_.Get();
}
inline void LoginResponse::_internal_set_session_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.session_id_.Set(value, GetArena());
}
inline std::string* LoginResponse::_internal_mutable_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.session_id_.Mutable( GetArena());
}
inline std::string* LoginResponse::release_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.LoginResponse.session_id)
  return _impl_.session_id_.Release();
}
inline void LoginResponse::set_allocated_session_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_id_.IsDefault()) {
          _impl_.session_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.LoginResponse.session_id)
}

// int32 expires_in = 5;
inline void LoginResponse::clear_expires_in() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.expires_in_ = 0;
}
inline ::int32_t LoginResponse::expires_in() const {
  // @@protoc_insertion_point(field_get:mmorpg.LoginResponse.expires_in)
  return _internal_expires_in();
}
inline void LoginResponse::set_expires_in(::int32_t value) {
  _internal_set_expires_in(value);
  // @@protoc_insertion_point(field_set:mmorpg.LoginResponse.expires_in)
}
inline ::int32_t LoginResponse::_internal_expires_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.expires_in_;
}
inline void LoginResponse::_internal_set_expires_in(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.expires_in_ = value;
}

// string error_message = 6;
inline void LoginResponse::clear_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& LoginResponse::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.LoginResponse.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoginResponse::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.LoginResponse.error_message)
}
inline std::string* LoginResponse::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:mmorpg.LoginResponse.error_message)
  return _s;
}
inline const std::string& LoginResponse::_internal_error_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_message_.Get();
}
inline void LoginResponse::_internal_set_error_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* LoginResponse::_internal_mutable_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* LoginResponse::release_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.LoginResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void LoginResponse::set_allocated_error_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_message_.IsDefault()) {
          _impl_.error_message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.LoginResponse.error_message)
}

// .mmorpg.ErrorCode error_code = 7;
inline void LoginResponse::clear_error_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_code_ = 0;
}
inline ::mmorpg::ErrorCode LoginResponse::error_code() const {
  // @@protoc_insertion_point(field_get:mmorpg.LoginResponse.error_code)
  return _internal_error_code();
}
inline void LoginResponse::set_error_code(::mmorpg::ErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:mmorpg.LoginResponse.error_code)
}
inline ::mmorpg::ErrorCode LoginResponse::_internal_error_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::ErrorCode>(_impl_.error_code_);
}
inline void LoginResponse::_internal_set_error_code(::mmorpg::ErrorCode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_code_ = value;
}

// .mmorpg.UserInfo user_info = 8;
inline bool LoginResponse::has_user_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_info_ != nullptr);
  return value;
}
inline void LoginResponse::clear_user_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.user_info_ != nullptr) _impl_.user_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::mmorpg::UserInfo& LoginResponse::_internal_user_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::mmorpg::UserInfo* p = _impl_.user_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::mmorpg::UserInfo&>(::mmorpg::_UserInfo_default_instance_);
}
inline const ::mmorpg::UserInfo& LoginResponse::user_info() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.LoginResponse.user_info)
  return _internal_user_info();
}
inline void LoginResponse::unsafe_arena_set_allocated_user_info(::mmorpg::UserInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_info_);
  }
  _impl_.user_info_ = reinterpret_cast<::mmorpg::UserInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.LoginResponse.user_info)
}
inline ::mmorpg::UserInfo* LoginResponse::release_user_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::UserInfo* released = _impl_.user_info_;
  _impl_.user_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::mmorpg::UserInfo* LoginResponse::unsafe_arena_release_user_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.LoginResponse.user_info)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::UserInfo* temp = _impl_.user_info_;
  _impl_.user_info_ = nullptr;
  return temp;
}
inline ::mmorpg::UserInfo* LoginResponse::_internal_mutable_user_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.user_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::mmorpg::UserInfo>(GetArena());
    _impl_.user_info_ = reinterpret_cast<::mmorpg::UserInfo*>(p);
  }
  return _impl_.user_info_;
}
inline ::mmorpg::UserInfo* LoginResponse::mutable_user_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::UserInfo* _msg = _internal_mutable_user_info();
  // @@protoc_insertion_point(field_mutable:mmorpg.LoginResponse.user_info)
  return _msg;
}
inline void LoginResponse::set_allocated_user_info(::mmorpg::UserInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::mmorpg::UserInfo*>(_impl_.user_info_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::mmorpg::UserInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.user_info_ = reinterpret_cast<::mmorpg::UserInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.LoginResponse.user_info)
}

// -------------------------------------------------------------------

// RegisterRequest

// string email = 1;
inline void RegisterRequest::clear_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.email_.ClearToEmpty();
}
inline const std::string& RegisterRequest::email() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.RegisterRequest.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterRequest::set_email(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.RegisterRequest.email)
}
inline std::string* RegisterRequest::mutable_email() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:mmorpg.RegisterRequest.email)
  return _s;
}
inline const std::string& RegisterRequest::_internal_email() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.email_.Get();
}
inline void RegisterRequest::_internal_set_email(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.email_.Set(value, GetArena());
}
inline std::string* RegisterRequest::_internal_mutable_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.email_.Mutable( GetArena());
}
inline std::string* RegisterRequest::release_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.RegisterRequest.email)
  return _impl_.email_.Release();
}
inline void RegisterRequest::set_allocated_email(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.email_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.email_.IsDefault()) {
          _impl_.email_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.RegisterRequest.email)
}

// string password = 2;
inline void RegisterRequest::clear_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.password_.ClearToEmpty();
}
inline const std::string& RegisterRequest::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.RegisterRequest.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterRequest::set_password(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.RegisterRequest.password)
}
inline std::string* RegisterRequest::mutable_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:mmorpg.RegisterRequest.password)
  return _s;
}
inline const std::string& RegisterRequest::_internal_password() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.password_.Get();
}
inline void RegisterRequest::_internal_set_password(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.password_.Set(value, GetArena());
}
inline std::string* RegisterRequest::_internal_mutable_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.password_.Mutable( GetArena());
}
inline std::string* RegisterRequest::release_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.RegisterRequest.password)
  return _impl_.password_.Release();
}
inline void RegisterRequest::set_allocated_password(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.password_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.RegisterRequest.password)
}

// string username = 3;
inline void RegisterRequest::clear_username() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& RegisterRequest::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.RegisterRequest.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterRequest::set_username(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.RegisterRequest.username)
}
inline std::string* RegisterRequest::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:mmorpg.RegisterRequest.username)
  return _s;
}
inline const std::string& RegisterRequest::_internal_username() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.username_.Get();
}
inline void RegisterRequest::_internal_set_username(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.username_.Set(value, GetArena());
}
inline std::string* RegisterRequest::_internal_mutable_username() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* RegisterRequest::release_username() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.RegisterRequest.username)
  return _impl_.username_.Release();
}
inline void RegisterRequest::set_allocated_username(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.username_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_.IsDefault()) {
          _impl_.username_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.RegisterRequest.username)
}

// string client_version = 4;
inline void RegisterRequest::clear_client_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.client_version_.ClearToEmpty();
}
inline const std::string& RegisterRequest::client_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.RegisterRequest.client_version)
  return _internal_client_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterRequest::set_client_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.client_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.RegisterRequest.client_version)
}
inline std::string* RegisterRequest::mutable_client_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_client_version();
  // @@protoc_insertion_point(field_mutable:mmorpg.RegisterRequest.client_version)
  return _s;
}
inline const std::string& RegisterRequest::_internal_client_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.client_version_.Get();
}
inline void RegisterRequest::_internal_set_client_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.client_version_.Set(value, GetArena());
}
inline std::string* RegisterRequest::_internal_mutable_client_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.client_version_.Mutable( GetArena());
}
inline std::string* RegisterRequest::release_client_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.RegisterRequest.client_version)
  return _impl_.client_version_.Release();
}
inline void RegisterRequest::set_allocated_client_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.client_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.client_version_.IsDefault()) {
          _impl_.client_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.RegisterRequest.client_version)
}

// bool accept_terms = 5;
inline void RegisterRequest::clear_accept_terms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.accept_terms_ = false;
}
inline bool RegisterRequest::accept_terms() const {
  // @@protoc_insertion_point(field_get:mmorpg.RegisterRequest.accept_terms)
  return _internal_accept_terms();
}
inline void RegisterRequest::set_accept_terms(bool value) {
  _internal_set_accept_terms(value);
  // @@protoc_insertion_point(field_set:mmorpg.RegisterRequest.accept_terms)
}
inline bool RegisterRequest::_internal_accept_terms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.accept_terms_;
}
inline void RegisterRequest::_internal_set_accept_terms(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.accept_terms_ = value;
}

// optional string referral_code = 6;
inline bool RegisterRequest::has_referral_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RegisterRequest::clear_referral_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.referral_code_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegisterRequest::referral_code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.RegisterRequest.referral_code)
  return _internal_referral_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterRequest::set_referral_code(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.referral_code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.RegisterRequest.referral_code)
}
inline std::string* RegisterRequest::mutable_referral_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_referral_code();
  // @@protoc_insertion_point(field_mutable:mmorpg.RegisterRequest.referral_code)
  return _s;
}
inline const std::string& RegisterRequest::_internal_referral_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.referral_code_.Get();
}
inline void RegisterRequest::_internal_set_referral_code(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.referral_code_.Set(value, GetArena());
}
inline std::string* RegisterRequest::_internal_mutable_referral_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.referral_code_.Mutable( GetArena());
}
inline std::string* RegisterRequest::release_referral_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.RegisterRequest.referral_code)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.referral_code_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.referral_code_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RegisterRequest::set_allocated_referral_code(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.referral_code_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.referral_code_.IsDefault()) {
          _impl_.referral_code_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.RegisterRequest.referral_code)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RegisterResponse

// bool success = 1;
inline void RegisterResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool RegisterResponse::success() const {
  // @@protoc_insertion_point(field_get:mmorpg.RegisterResponse.success)
  return _internal_success();
}
inline void RegisterResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:mmorpg.RegisterResponse.success)
}
inline bool RegisterResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void RegisterResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string user_id = 2;
inline void RegisterResponse::clear_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& RegisterResponse::user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.RegisterResponse.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterResponse::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.RegisterResponse.user_id)
}
inline std::string* RegisterResponse::mutable_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.RegisterResponse.user_id)
  return _s;
}
inline const std::string& RegisterResponse::_internal_user_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_id_.Get();
}
inline void RegisterResponse::_internal_set_user_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_id_.Set(value, GetArena());
}
inline std::string* RegisterResponse::_internal_mutable_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.user_id_.Mutable( GetArena());
}
inline std::string* RegisterResponse::release_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.RegisterResponse.user_id)
  return _impl_.user_id_.Release();
}
inline void RegisterResponse::set_allocated_user_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_id_.IsDefault()) {
          _impl_.user_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.RegisterResponse.user_id)
}

// string error_message = 3;
inline void RegisterResponse::clear_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& RegisterResponse::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.RegisterResponse.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterResponse::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.RegisterResponse.error_message)
}
inline std::string* RegisterResponse::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:mmorpg.RegisterResponse.error_message)
  return _s;
}
inline const std::string& RegisterResponse::_internal_error_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_message_.Get();
}
inline void RegisterResponse::_internal_set_error_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* RegisterResponse::_internal_mutable_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* RegisterResponse::release_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.RegisterResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void RegisterResponse::set_allocated_error_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_message_.IsDefault()) {
          _impl_.error_message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.RegisterResponse.error_message)
}

// .mmorpg.ErrorCode error_code = 4;
inline void RegisterResponse::clear_error_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_code_ = 0;
}
inline ::mmorpg::ErrorCode RegisterResponse::error_code() const {
  // @@protoc_insertion_point(field_get:mmorpg.RegisterResponse.error_code)
  return _internal_error_code();
}
inline void RegisterResponse::set_error_code(::mmorpg::ErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:mmorpg.RegisterResponse.error_code)
}
inline ::mmorpg::ErrorCode RegisterResponse::_internal_error_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::ErrorCode>(_impl_.error_code_);
}
inline void RegisterResponse::_internal_set_error_code(::mmorpg::ErrorCode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_code_ = value;
}

// map<string, string> field_errors = 5;
inline int RegisterResponse::_internal_field_errors_size() const {
  return _internal_field_errors().size();
}
inline int RegisterResponse::field_errors_size() const {
  return _internal_field_errors_size();
}
inline void RegisterResponse::clear_field_errors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.field_errors_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& RegisterResponse::_internal_field_errors() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.field_errors_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& RegisterResponse::field_errors() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:mmorpg.RegisterResponse.field_errors)
  return _internal_field_errors();
}
inline ::google::protobuf::Map<std::string, std::string>* RegisterResponse::_internal_mutable_field_errors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.field_errors_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* RegisterResponse::mutable_field_errors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:mmorpg.RegisterResponse.field_errors)
  return _internal_mutable_field_errors();
}

// -------------------------------------------------------------------

// LogoutRequest

// string session_id = 1;
inline void LogoutRequest::clear_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& LogoutRequest::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.LogoutRequest.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LogoutRequest::set_session_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.session_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.LogoutRequest.session_id)
}
inline std::string* LogoutRequest::mutable_session_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.LogoutRequest.session_id)
  return _s;
}
inline const std::string& LogoutRequest::_internal_session_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.session_id_.Get();
}
inline void LogoutRequest::_internal_set_session_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.session_id_.Set(value, GetArena());
}
inline std::string* LogoutRequest::_internal_mutable_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.session_id_.Mutable( GetArena());
}
inline std::string* LogoutRequest::release_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.LogoutRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void LogoutRequest::set_allocated_session_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_id_.IsDefault()) {
          _impl_.session_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.LogoutRequest.session_id)
}

// bool logout_all_devices = 2;
inline void LogoutRequest::clear_logout_all_devices() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.logout_all_devices_ = false;
}
inline bool LogoutRequest::logout_all_devices() const {
  // @@protoc_insertion_point(field_get:mmorpg.LogoutRequest.logout_all_devices)
  return _internal_logout_all_devices();
}
inline void LogoutRequest::set_logout_all_devices(bool value) {
  _internal_set_logout_all_devices(value);
  // @@protoc_insertion_point(field_set:mmorpg.LogoutRequest.logout_all_devices)
}
inline bool LogoutRequest::_internal_logout_all_devices() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.logout_all_devices_;
}
inline void LogoutRequest::_internal_set_logout_all_devices(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.logout_all_devices_ = value;
}

// -------------------------------------------------------------------

// LogoutResponse

// bool success = 1;
inline void LogoutResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool LogoutResponse::success() const {
  // @@protoc_insertion_point(field_get:mmorpg.LogoutResponse.success)
  return _internal_success();
}
inline void LogoutResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:mmorpg.LogoutResponse.success)
}
inline bool LogoutResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void LogoutResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string message = 2;
inline void LogoutResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& LogoutResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.LogoutResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LogoutResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.LogoutResponse.message)
}
inline std::string* LogoutResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:mmorpg.LogoutResponse.message)
  return _s;
}
inline const std::string& LogoutResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void LogoutResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* LogoutResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* LogoutResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.LogoutResponse.message)
  return _impl_.message_.Release();
}
inline void LogoutResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.LogoutResponse.message)
}

// -------------------------------------------------------------------

// RefreshTokenRequest

// string refresh_token = 1;
inline void RefreshTokenRequest::clear_refresh_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.refresh_token_.ClearToEmpty();
}
inline const std::string& RefreshTokenRequest::refresh_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.RefreshTokenRequest.refresh_token)
  return _internal_refresh_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RefreshTokenRequest::set_refresh_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.refresh_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.RefreshTokenRequest.refresh_token)
}
inline std::string* RefreshTokenRequest::mutable_refresh_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_refresh_token();
  // @@protoc_insertion_point(field_mutable:mmorpg.RefreshTokenRequest.refresh_token)
  return _s;
}
inline const std::string& RefreshTokenRequest::_internal_refresh_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.refresh_token_.Get();
}
inline void RefreshTokenRequest::_internal_set_refresh_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.refresh_token_.Set(value, GetArena());
}
inline std::string* RefreshTokenRequest::_internal_mutable_refresh_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.refresh_token_.Mutable( GetArena());
}
inline std::string* RefreshTokenRequest::release_refresh_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.RefreshTokenRequest.refresh_token)
  return _impl_.refresh_token_.Release();
}
inline void RefreshTokenRequest::set_allocated_refresh_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.refresh_token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.refresh_token_.IsDefault()) {
          _impl_.refresh_token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.RefreshTokenRequest.refresh_token)
}

// -------------------------------------------------------------------

// RefreshTokenResponse

// bool success = 1;
inline void RefreshTokenResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool RefreshTokenResponse::success() const {
  // @@protoc_insertion_point(field_get:mmorpg.RefreshTokenResponse.success)
  return _internal_success();
}
inline void RefreshTokenResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:mmorpg.RefreshTokenResponse.success)
}
inline bool RefreshTokenResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void RefreshTokenResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string access_token = 2;
inline void RefreshTokenResponse::clear_access_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.access_token_.ClearToEmpty();
}
inline const std::string& RefreshTokenResponse::access_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.RefreshTokenResponse.access_token)
  return _internal_access_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RefreshTokenResponse::set_access_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.access_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.RefreshTokenResponse.access_token)
}
inline std::string* RefreshTokenResponse::mutable_access_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_access_token();
  // @@protoc_insertion_point(field_mutable:mmorpg.RefreshTokenResponse.access_token)
  return _s;
}
inline const std::string& RefreshTokenResponse::_internal_access_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.access_token_.Get();
}
inline void RefreshTokenResponse::_internal_set_access_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.access_token_.Set(value, GetArena());
}
inline std::string* RefreshTokenResponse::_internal_mutable_access_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.access_token_.Mutable( GetArena());
}
inline std::string* RefreshTokenResponse::release_access_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.RefreshTokenResponse.access_token)
  return _impl_.access_token_.Release();
}
inline void RefreshTokenResponse::set_allocated_access_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.access_token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.access_token_.IsDefault()) {
          _impl_.access_token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.RefreshTokenResponse.access_token)
}

// string refresh_token = 3;
inline void RefreshTokenResponse::clear_refresh_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.refresh_token_.ClearToEmpty();
}
inline const std::string& RefreshTokenResponse::refresh_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.RefreshTokenResponse.refresh_token)
  return _internal_refresh_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RefreshTokenResponse::set_refresh_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.refresh_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.RefreshTokenResponse.refresh_token)
}
inline std::string* RefreshTokenResponse::mutable_refresh_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_refresh_token();
  // @@protoc_insertion_point(field_mutable:mmorpg.RefreshTokenResponse.refresh_token)
  return _s;
}
inline const std::string& RefreshTokenResponse::_internal_refresh_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.refresh_token_.Get();
}
inline void RefreshTokenResponse::_internal_set_refresh_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.refresh_token_.Set(value, GetArena());
}
inline std::string* RefreshTokenResponse::_internal_mutable_refresh_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.refresh_token_.Mutable( GetArena());
}
inline std::string* RefreshTokenResponse::release_refresh_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.RefreshTokenResponse.refresh_token)
  return _impl_.refresh_token_.Release();
}
inline void RefreshTokenResponse::set_allocated_refresh_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.refresh_token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.refresh_token_.IsDefault()) {
          _impl_.refresh_token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.RefreshTokenResponse.refresh_token)
}

// int32 expires_in = 4;
inline void RefreshTokenResponse::clear_expires_in() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.expires_in_ = 0;
}
inline ::int32_t RefreshTokenResponse::expires_in() const {
  // @@protoc_insertion_point(field_get:mmorpg.RefreshTokenResponse.expires_in)
  return _internal_expires_in();
}
inline void RefreshTokenResponse::set_expires_in(::int32_t value) {
  _internal_set_expires_in(value);
  // @@protoc_insertion_point(field_set:mmorpg.RefreshTokenResponse.expires_in)
}
inline ::int32_t RefreshTokenResponse::_internal_expires_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.expires_in_;
}
inline void RefreshTokenResponse::_internal_set_expires_in(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.expires_in_ = value;
}

// string error_message = 5;
inline void RefreshTokenResponse::clear_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& RefreshTokenResponse::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.RefreshTokenResponse.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RefreshTokenResponse::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.RefreshTokenResponse.error_message)
}
inline std::string* RefreshTokenResponse::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:mmorpg.RefreshTokenResponse.error_message)
  return _s;
}
inline const std::string& RefreshTokenResponse::_internal_error_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_message_.Get();
}
inline void RefreshTokenResponse::_internal_set_error_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* RefreshTokenResponse::_internal_mutable_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* RefreshTokenResponse::release_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.RefreshTokenResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void RefreshTokenResponse::set_allocated_error_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_message_.IsDefault()) {
          _impl_.error_message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.RefreshTokenResponse.error_message)
}

// .mmorpg.ErrorCode error_code = 6;
inline void RefreshTokenResponse::clear_error_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_code_ = 0;
}
inline ::mmorpg::ErrorCode RefreshTokenResponse::error_code() const {
  // @@protoc_insertion_point(field_get:mmorpg.RefreshTokenResponse.error_code)
  return _internal_error_code();
}
inline void RefreshTokenResponse::set_error_code(::mmorpg::ErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:mmorpg.RefreshTokenResponse.error_code)
}
inline ::mmorpg::ErrorCode RefreshTokenResponse::_internal_error_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::ErrorCode>(_impl_.error_code_);
}
inline void RefreshTokenResponse::_internal_set_error_code(::mmorpg::ErrorCode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_code_ = value;
}

// -------------------------------------------------------------------

// PasswordResetRequest

// string email = 1;
inline void PasswordResetRequest::clear_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.email_.ClearToEmpty();
}
inline const std::string& PasswordResetRequest::email() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.PasswordResetRequest.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PasswordResetRequest::set_email(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.PasswordResetRequest.email)
}
inline std::string* PasswordResetRequest::mutable_email() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:mmorpg.PasswordResetRequest.email)
  return _s;
}
inline const std::string& PasswordResetRequest::_internal_email() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.email_.Get();
}
inline void PasswordResetRequest::_internal_set_email(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.email_.Set(value, GetArena());
}
inline std::string* PasswordResetRequest::_internal_mutable_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.email_.Mutable( GetArena());
}
inline std::string* PasswordResetRequest::release_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.PasswordResetRequest.email)
  return _impl_.email_.Release();
}
inline void PasswordResetRequest::set_allocated_email(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.email_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.email_.IsDefault()) {
          _impl_.email_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.PasswordResetRequest.email)
}

// -------------------------------------------------------------------

// PasswordResetResponse

// bool success = 1;
inline void PasswordResetResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool PasswordResetResponse::success() const {
  // @@protoc_insertion_point(field_get:mmorpg.PasswordResetResponse.success)
  return _internal_success();
}
inline void PasswordResetResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:mmorpg.PasswordResetResponse.success)
}
inline bool PasswordResetResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void PasswordResetResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string message = 2;
inline void PasswordResetResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& PasswordResetResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.PasswordResetResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PasswordResetResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.PasswordResetResponse.message)
}
inline std::string* PasswordResetResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:mmorpg.PasswordResetResponse.message)
  return _s;
}
inline const std::string& PasswordResetResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void PasswordResetResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* PasswordResetResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* PasswordResetResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.PasswordResetResponse.message)
  return _impl_.message_.Release();
}
inline void PasswordResetResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.PasswordResetResponse.message)
}

// -------------------------------------------------------------------

// ChangePasswordRequest

// string current_password = 1;
inline void ChangePasswordRequest::clear_current_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.current_password_.ClearToEmpty();
}
inline const std::string& ChangePasswordRequest::current_password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChangePasswordRequest.current_password)
  return _internal_current_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChangePasswordRequest::set_current_password(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.current_password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChangePasswordRequest.current_password)
}
inline std::string* ChangePasswordRequest::mutable_current_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_current_password();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChangePasswordRequest.current_password)
  return _s;
}
inline const std::string& ChangePasswordRequest::_internal_current_password() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.current_password_.Get();
}
inline void ChangePasswordRequest::_internal_set_current_password(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.current_password_.Set(value, GetArena());
}
inline std::string* ChangePasswordRequest::_internal_mutable_current_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.current_password_.Mutable( GetArena());
}
inline std::string* ChangePasswordRequest::release_current_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChangePasswordRequest.current_password)
  return _impl_.current_password_.Release();
}
inline void ChangePasswordRequest::set_allocated_current_password(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.current_password_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.current_password_.IsDefault()) {
          _impl_.current_password_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChangePasswordRequest.current_password)
}

// string new_password = 2;
inline void ChangePasswordRequest::clear_new_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.new_password_.ClearToEmpty();
}
inline const std::string& ChangePasswordRequest::new_password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChangePasswordRequest.new_password)
  return _internal_new_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChangePasswordRequest::set_new_password(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.new_password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChangePasswordRequest.new_password)
}
inline std::string* ChangePasswordRequest::mutable_new_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_new_password();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChangePasswordRequest.new_password)
  return _s;
}
inline const std::string& ChangePasswordRequest::_internal_new_password() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.new_password_.Get();
}
inline void ChangePasswordRequest::_internal_set_new_password(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.new_password_.Set(value, GetArena());
}
inline std::string* ChangePasswordRequest::_internal_mutable_new_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.new_password_.Mutable( GetArena());
}
inline std::string* ChangePasswordRequest::release_new_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChangePasswordRequest.new_password)
  return _impl_.new_password_.Release();
}
inline void ChangePasswordRequest::set_allocated_new_password(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.new_password_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.new_password_.IsDefault()) {
          _impl_.new_password_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChangePasswordRequest.new_password)
}

// string session_id = 3;
inline void ChangePasswordRequest::clear_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& ChangePasswordRequest::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChangePasswordRequest.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChangePasswordRequest::set_session_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.session_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChangePasswordRequest.session_id)
}
inline std::string* ChangePasswordRequest::mutable_session_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChangePasswordRequest.session_id)
  return _s;
}
inline const std::string& ChangePasswordRequest::_internal_session_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.session_id_.Get();
}
inline void ChangePasswordRequest::_internal_set_session_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.session_id_.Set(value, GetArena());
}
inline std::string* ChangePasswordRequest::_internal_mutable_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.session_id_.Mutable( GetArena());
}
inline std::string* ChangePasswordRequest::release_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChangePasswordRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void ChangePasswordRequest::set_allocated_session_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_id_.IsDefault()) {
          _impl_.session_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChangePasswordRequest.session_id)
}

// -------------------------------------------------------------------

// ChangePasswordResponse

// bool success = 1;
inline void ChangePasswordResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool ChangePasswordResponse::success() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChangePasswordResponse.success)
  return _internal_success();
}
inline void ChangePasswordResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChangePasswordResponse.success)
}
inline bool ChangePasswordResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void ChangePasswordResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string message = 2;
inline void ChangePasswordResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ChangePasswordResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ChangePasswordResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChangePasswordResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ChangePasswordResponse.message)
}
inline std::string* ChangePasswordResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:mmorpg.ChangePasswordResponse.message)
  return _s;
}
inline const std::string& ChangePasswordResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void ChangePasswordResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* ChangePasswordResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* ChangePasswordResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ChangePasswordResponse.message)
  return _impl_.message_.Release();
}
inline void ChangePasswordResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ChangePasswordResponse.message)
}

// .mmorpg.ErrorCode error_code = 3;
inline void ChangePasswordResponse::clear_error_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_code_ = 0;
}
inline ::mmorpg::ErrorCode ChangePasswordResponse::error_code() const {
  // @@protoc_insertion_point(field_get:mmorpg.ChangePasswordResponse.error_code)
  return _internal_error_code();
}
inline void ChangePasswordResponse::set_error_code(::mmorpg::ErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:mmorpg.ChangePasswordResponse.error_code)
}
inline ::mmorpg::ErrorCode ChangePasswordResponse::_internal_error_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::ErrorCode>(_impl_.error_code_);
}
inline void ChangePasswordResponse::_internal_set_error_code(::mmorpg::ErrorCode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_code_ = value;
}

// -------------------------------------------------------------------

// UserInfo

// string user_id = 1;
inline void UserInfo::clear_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& UserInfo::user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.UserInfo.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserInfo::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.UserInfo.user_id)
}
inline std::string* UserInfo::mutable_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.UserInfo.user_id)
  return _s;
}
inline const std::string& UserInfo::_internal_user_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_id_.Get();
}
inline void UserInfo::_internal_set_user_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_id_.Set(value, GetArena());
}
inline std::string* UserInfo::_internal_mutable_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.user_id_.Mutable( GetArena());
}
inline std::string* UserInfo::release_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.UserInfo.user_id)
  return _impl_.user_id_.Release();
}
inline void UserInfo::set_allocated_user_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_id_.IsDefault()) {
          _impl_.user_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.UserInfo.user_id)
}

// string email = 2;
inline void UserInfo::clear_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.email_.ClearToEmpty();
}
inline const std::string& UserInfo::email() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.UserInfo.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserInfo::set_email(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.UserInfo.email)
}
inline std::string* UserInfo::mutable_email() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:mmorpg.UserInfo.email)
  return _s;
}
inline const std::string& UserInfo::_internal_email() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.email_.Get();
}
inline void UserInfo::_internal_set_email(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.email_.Set(value, GetArena());
}
inline std::string* UserInfo::_internal_mutable_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.email_.Mutable( GetArena());
}
inline std::string* UserInfo::release_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.UserInfo.email)
  return _impl_.email_.Release();
}
inline void UserInfo::set_allocated_email(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.email_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.email_.IsDefault()) {
          _impl_.email_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.UserInfo.email)
}

// string username = 3;
inline void UserInfo::clear_username() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& UserInfo::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.UserInfo.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserInfo::set_username(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.UserInfo.username)
}
inline std::string* UserInfo::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:mmorpg.UserInfo.username)
  return _s;
}
inline const std::string& UserInfo::_internal_username() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.username_.Get();
}
inline void UserInfo::_internal_set_username(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.username_.Set(value, GetArena());
}
inline std::string* UserInfo::_internal_mutable_username() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* UserInfo::release_username() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.UserInfo.username)
  return _impl_.username_.Release();
}
inline void UserInfo::set_allocated_username(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.username_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_.IsDefault()) {
          _impl_.username_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.UserInfo.username)
}

// .google.protobuf.Timestamp created_at = 4;
inline bool UserInfo::has_created_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.created_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& UserInfo::_internal_created_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& UserInfo::created_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.UserInfo.created_at)
  return _internal_created_at();
}
inline void UserInfo::unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.UserInfo.created_at)
}
inline ::google::protobuf::Timestamp* UserInfo::release_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* UserInfo::unsafe_arena_release_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.UserInfo.created_at)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* UserInfo::_internal_mutable_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.created_at_;
}
inline ::google::protobuf::Timestamp* UserInfo::mutable_created_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:mmorpg.UserInfo.created_at)
  return _msg;
}
inline void UserInfo::set_allocated_created_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.UserInfo.created_at)
}

// .google.protobuf.Timestamp last_login = 5;
inline bool UserInfo::has_last_login() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.last_login_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& UserInfo::_internal_last_login() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.last_login_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& UserInfo::last_login() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.UserInfo.last_login)
  return _internal_last_login();
}
inline void UserInfo::unsafe_arena_set_allocated_last_login(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_login_);
  }
  _impl_.last_login_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.UserInfo.last_login)
}
inline ::google::protobuf::Timestamp* UserInfo::release_last_login() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.last_login_;
  _impl_.last_login_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* UserInfo::unsafe_arena_release_last_login() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.UserInfo.last_login)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.last_login_;
  _impl_.last_login_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* UserInfo::_internal_mutable_last_login() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.last_login_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.last_login_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.last_login_;
}
inline ::google::protobuf::Timestamp* UserInfo::mutable_last_login() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_last_login();
  // @@protoc_insertion_point(field_mutable:mmorpg.UserInfo.last_login)
  return _msg;
}
inline void UserInfo::set_allocated_last_login(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_login_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.last_login_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.UserInfo.last_login)
}

// bool email_verified = 6;
inline void UserInfo::clear_email_verified() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.email_verified_ = false;
}
inline bool UserInfo::email_verified() const {
  // @@protoc_insertion_point(field_get:mmorpg.UserInfo.email_verified)
  return _internal_email_verified();
}
inline void UserInfo::set_email_verified(bool value) {
  _internal_set_email_verified(value);
  // @@protoc_insertion_point(field_set:mmorpg.UserInfo.email_verified)
}
inline bool UserInfo::_internal_email_verified() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.email_verified_;
}
inline void UserInfo::_internal_set_email_verified(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.email_verified_ = value;
}

// .mmorpg.AccountStatus account_status = 7;
inline void UserInfo::clear_account_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.account_status_ = 0;
}
inline ::mmorpg::AccountStatus UserInfo::account_status() const {
  // @@protoc_insertion_point(field_get:mmorpg.UserInfo.account_status)
  return _internal_account_status();
}
inline void UserInfo::set_account_status(::mmorpg::AccountStatus value) {
  _internal_set_account_status(value);
  // @@protoc_insertion_point(field_set:mmorpg.UserInfo.account_status)
}
inline ::mmorpg::AccountStatus UserInfo::_internal_account_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::AccountStatus>(_impl_.account_status_);
}
inline void UserInfo::_internal_set_account_status(::mmorpg::AccountStatus value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.account_status_ = value;
}

// repeated string roles = 8;
inline int UserInfo::_internal_roles_size() const {
  return _internal_roles().size();
}
inline int UserInfo::roles_size() const {
  return _internal_roles_size();
}
inline void UserInfo::clear_roles() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.roles_.Clear();
}
inline std::string* UserInfo::add_roles()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_roles()->Add();
  // @@protoc_insertion_point(field_add_mutable:mmorpg.UserInfo.roles)
  return _s;
}
inline const std::string& UserInfo::roles(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.UserInfo.roles)
  return _internal_roles().Get(index);
}
inline std::string* UserInfo::mutable_roles(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.UserInfo.roles)
  return _internal_mutable_roles()->Mutable(index);
}
inline void UserInfo::set_roles(int index, const std::string& value) {
  _internal_mutable_roles()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:mmorpg.UserInfo.roles)
}
inline void UserInfo::set_roles(int index, std::string&& value) {
  _internal_mutable_roles()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:mmorpg.UserInfo.roles)
}
inline void UserInfo::set_roles(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_roles()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mmorpg.UserInfo.roles)
}
inline void UserInfo::set_roles(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_roles()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mmorpg.UserInfo.roles)
}
inline void UserInfo::set_roles(int index, absl::string_view value) {
  _internal_mutable_roles()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:mmorpg.UserInfo.roles)
}
inline void UserInfo::add_roles(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_roles()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:mmorpg.UserInfo.roles)
}
inline void UserInfo::add_roles(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_roles()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:mmorpg.UserInfo.roles)
}
inline void UserInfo::add_roles(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_roles()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mmorpg.UserInfo.roles)
}
inline void UserInfo::add_roles(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_roles()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mmorpg.UserInfo.roles)
}
inline void UserInfo::add_roles(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_roles()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:mmorpg.UserInfo.roles)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UserInfo::roles() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.UserInfo.roles)
  return _internal_roles();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UserInfo::mutable_roles() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.UserInfo.roles)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_roles();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UserInfo::_internal_roles() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.roles_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UserInfo::_internal_mutable_roles() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.roles_;
}

// int32 max_characters = 9;
inline void UserInfo::clear_max_characters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_characters_ = 0;
}
inline ::int32_t UserInfo::max_characters() const {
  // @@protoc_insertion_point(field_get:mmorpg.UserInfo.max_characters)
  return _internal_max_characters();
}
inline void UserInfo::set_max_characters(::int32_t value) {
  _internal_set_max_characters(value);
  // @@protoc_insertion_point(field_set:mmorpg.UserInfo.max_characters)
}
inline ::int32_t UserInfo::_internal_max_characters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_characters_;
}
inline void UserInfo::_internal_set_max_characters(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_characters_ = value;
}

// int32 character_count = 10;
inline void UserInfo::clear_character_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.character_count_ = 0;
}
inline ::int32_t UserInfo::character_count() const {
  // @@protoc_insertion_point(field_get:mmorpg.UserInfo.character_count)
  return _internal_character_count();
}
inline void UserInfo::set_character_count(::int32_t value) {
  _internal_set_character_count(value);
  // @@protoc_insertion_point(field_set:mmorpg.UserInfo.character_count)
}
inline ::int32_t UserInfo::_internal_character_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.character_count_;
}
inline void UserInfo::_internal_set_character_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.character_count_ = value;
}

// bool is_premium = 11;
inline void UserInfo::clear_is_premium() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_premium_ = false;
}
inline bool UserInfo::is_premium() const {
  // @@protoc_insertion_point(field_get:mmorpg.UserInfo.is_premium)
  return _internal_is_premium();
}
inline void UserInfo::set_is_premium(bool value) {
  _internal_set_is_premium(value);
  // @@protoc_insertion_point(field_set:mmorpg.UserInfo.is_premium)
}
inline bool UserInfo::_internal_is_premium() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_premium_;
}
inline void UserInfo::_internal_set_is_premium(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_premium_ = value;
}

// .google.protobuf.Timestamp premium_expires = 12;
inline bool UserInfo::has_premium_expires() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.premium_expires_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& UserInfo::_internal_premium_expires() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.premium_expires_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& UserInfo::premium_expires() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.UserInfo.premium_expires)
  return _internal_premium_expires();
}
inline void UserInfo::unsafe_arena_set_allocated_premium_expires(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.premium_expires_);
  }
  _impl_.premium_expires_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.UserInfo.premium_expires)
}
inline ::google::protobuf::Timestamp* UserInfo::release_premium_expires() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* released = _impl_.premium_expires_;
  _impl_.premium_expires_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* UserInfo::unsafe_arena_release_premium_expires() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.UserInfo.premium_expires)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* temp = _impl_.premium_expires_;
  _impl_.premium_expires_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* UserInfo::_internal_mutable_premium_expires() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.premium_expires_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.premium_expires_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.premium_expires_;
}
inline ::google::protobuf::Timestamp* UserInfo::mutable_premium_expires() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_premium_expires();
  // @@protoc_insertion_point(field_mutable:mmorpg.UserInfo.premium_expires)
  return _msg;
}
inline void UserInfo::set_allocated_premium_expires(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.premium_expires_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.premium_expires_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.UserInfo.premium_expires)
}

// -------------------------------------------------------------------

// SessionInfo

// string session_id = 1;
inline void SessionInfo::clear_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& SessionInfo::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.SessionInfo.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SessionInfo::set_session_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.session_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.SessionInfo.session_id)
}
inline std::string* SessionInfo::mutable_session_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.SessionInfo.session_id)
  return _s;
}
inline const std::string& SessionInfo::_internal_session_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.session_id_.Get();
}
inline void SessionInfo::_internal_set_session_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.session_id_.Set(value, GetArena());
}
inline std::string* SessionInfo::_internal_mutable_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.session_id_.Mutable( GetArena());
}
inline std::string* SessionInfo::release_session_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.SessionInfo.session_id)
  return _impl_.session_id_.Release();
}
inline void SessionInfo::set_allocated_session_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_id_.IsDefault()) {
          _impl_.session_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.SessionInfo.session_id)
}

// string user_id = 2;
inline void SessionInfo::clear_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& SessionInfo::user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.SessionInfo.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SessionInfo::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.SessionInfo.user_id)
}
inline std::string* SessionInfo::mutable_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.SessionInfo.user_id)
  return _s;
}
inline const std::string& SessionInfo::_internal_user_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_id_.Get();
}
inline void SessionInfo::_internal_set_user_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_id_.Set(value, GetArena());
}
inline std::string* SessionInfo::_internal_mutable_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.user_id_.Mutable( GetArena());
}
inline std::string* SessionInfo::release_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.SessionInfo.user_id)
  return _impl_.user_id_.Release();
}
inline void SessionInfo::set_allocated_user_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_id_.IsDefault()) {
          _impl_.user_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.SessionInfo.user_id)
}

// string device_id = 3;
inline void SessionInfo::clear_device_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_id_.ClearToEmpty();
}
inline const std::string& SessionInfo::device_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.SessionInfo.device_id)
  return _internal_device_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SessionInfo::set_device_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.SessionInfo.device_id)
}
inline std::string* SessionInfo::mutable_device_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_device_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.SessionInfo.device_id)
  return _s;
}
inline const std::string& SessionInfo::_internal_device_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.device_id_.Get();
}
inline void SessionInfo::_internal_set_device_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.device_id_.Set(value, GetArena());
}
inline std::string* SessionInfo::_internal_mutable_device_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.device_id_.Mutable( GetArena());
}
inline std::string* SessionInfo::release_device_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.SessionInfo.device_id)
  return _impl_.device_id_.Release();
}
inline void SessionInfo::set_allocated_device_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.device_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.device_id_.IsDefault()) {
          _impl_.device_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.SessionInfo.device_id)
}

// string ip_address = 4;
inline void SessionInfo::clear_ip_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_address_.ClearToEmpty();
}
inline const std::string& SessionInfo::ip_address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.SessionInfo.ip_address)
  return _internal_ip_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SessionInfo::set_ip_address(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.SessionInfo.ip_address)
}
inline std::string* SessionInfo::mutable_ip_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:mmorpg.SessionInfo.ip_address)
  return _s;
}
inline const std::string& SessionInfo::_internal_ip_address() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ip_address_.Get();
}
inline void SessionInfo::_internal_set_ip_address(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ip_address_.Set(value, GetArena());
}
inline std::string* SessionInfo::_internal_mutable_ip_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ip_address_.Mutable( GetArena());
}
inline std::string* SessionInfo::release_ip_address() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.SessionInfo.ip_address)
  return _impl_.ip_address_.Release();
}
inline void SessionInfo::set_allocated_ip_address(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_address_.IsDefault()) {
          _impl_.ip_address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.SessionInfo.ip_address)
}

// string user_agent = 5;
inline void SessionInfo::clear_user_agent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_agent_.ClearToEmpty();
}
inline const std::string& SessionInfo::user_agent() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.SessionInfo.user_agent)
  return _internal_user_agent();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SessionInfo::set_user_agent(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_agent_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.SessionInfo.user_agent)
}
inline std::string* SessionInfo::mutable_user_agent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_agent();
  // @@protoc_insertion_point(field_mutable:mmorpg.SessionInfo.user_agent)
  return _s;
}
inline const std::string& SessionInfo::_internal_user_agent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_agent_.Get();
}
inline void SessionInfo::_internal_set_user_agent(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_agent_.Set(value, GetArena());
}
inline std::string* SessionInfo::_internal_mutable_user_agent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.user_agent_.Mutable( GetArena());
}
inline std::string* SessionInfo::release_user_agent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.SessionInfo.user_agent)
  return _impl_.user_agent_.Release();
}
inline void SessionInfo::set_allocated_user_agent(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_agent_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_agent_.IsDefault()) {
          _impl_.user_agent_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.SessionInfo.user_agent)
}

// .google.protobuf.Timestamp created_at = 6;
inline bool SessionInfo::has_created_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.created_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& SessionInfo::_internal_created_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& SessionInfo::created_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.SessionInfo.created_at)
  return _internal_created_at();
}
inline void SessionInfo::unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.SessionInfo.created_at)
}
inline ::google::protobuf::Timestamp* SessionInfo::release_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* SessionInfo::unsafe_arena_release_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.SessionInfo.created_at)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* SessionInfo::_internal_mutable_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.created_at_;
}
inline ::google::protobuf::Timestamp* SessionInfo::mutable_created_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:mmorpg.SessionInfo.created_at)
  return _msg;
}
inline void SessionInfo::set_allocated_created_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.SessionInfo.created_at)
}

// .google.protobuf.Timestamp last_active = 7;
inline bool SessionInfo::has_last_active() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.last_active_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& SessionInfo::_internal_last_active() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.last_active_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& SessionInfo::last_active() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.SessionInfo.last_active)
  return _internal_last_active();
}
inline void SessionInfo::unsafe_arena_set_allocated_last_active(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_active_);
  }
  _impl_.last_active_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.SessionInfo.last_active)
}
inline ::google::protobuf::Timestamp* SessionInfo::release_last_active() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.last_active_;
  _impl_.last_active_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* SessionInfo::unsafe_arena_release_last_active() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.SessionInfo.last_active)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.last_active_;
  _impl_.last_active_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* SessionInfo::_internal_mutable_last_active() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.last_active_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.last_active_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.last_active_;
}
inline ::google::protobuf::Timestamp* SessionInfo::mutable_last_active() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_last_active();
  // @@protoc_insertion_point(field_mutable:mmorpg.SessionInfo.last_active)
  return _msg;
}
inline void SessionInfo::set_allocated_last_active(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.last_active_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.last_active_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.SessionInfo.last_active)
}

// .google.protobuf.Timestamp expires_at = 8;
inline bool SessionInfo::has_expires_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expires_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& SessionInfo::_internal_expires_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.expires_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& SessionInfo::expires_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.SessionInfo.expires_at)
  return _internal_expires_at();
}
inline void SessionInfo::unsafe_arena_set_allocated_expires_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expires_at_);
  }
  _impl_.expires_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.SessionInfo.expires_at)
}
inline ::google::protobuf::Timestamp* SessionInfo::release_expires_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* released = _impl_.expires_at_;
  _impl_.expires_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* SessionInfo::unsafe_arena_release_expires_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.SessionInfo.expires_at)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::google::protobuf::Timestamp* temp = _impl_.expires_at_;
  _impl_.expires_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* SessionInfo::_internal_mutable_expires_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.expires_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.expires_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.expires_at_;
}
inline ::google::protobuf::Timestamp* SessionInfo::mutable_expires_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_expires_at();
  // @@protoc_insertion_point(field_mutable:mmorpg.SessionInfo.expires_at)
  return _msg;
}
inline void SessionInfo::set_allocated_expires_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expires_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.expires_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.SessionInfo.expires_at)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace mmorpg


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::mmorpg::AccountStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mmorpg::AccountStatus>() {
  return ::mmorpg::AccountStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_auth_2eproto_2epb_2eh
