// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: game.proto

#include "game.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
#include "google/protobuf/generated_message_tctable_impl.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace mmorpg {

inline constexpr TradeRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : initiator_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        target_player_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR TradeRequest::TradeRequest(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct TradeRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TradeRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TradeRequestDefaultTypeInternal() {}
  union {
    TradeRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TradeRequestDefaultTypeInternal _TradeRequest_default_instance_;

inline constexpr TradeItem::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : item_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        quantity_{0},
        inventory_slot_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR TradeItem::TradeItem(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct TradeItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TradeItemDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TradeItemDefaultTypeInternal() {}
  union {
    TradeItem _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TradeItemDefaultTypeInternal _TradeItem_default_instance_;

inline constexpr QuestReward::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : reward_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        type_{static_cast< ::mmorpg::RewardType >(0)},
        quantity_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR QuestReward::QuestReward(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct QuestRewardDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QuestRewardDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~QuestRewardDefaultTypeInternal() {}
  union {
    QuestReward _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QuestRewardDefaultTypeInternal _QuestReward_default_instance_;

inline constexpr QuestObjective::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : objective_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        description_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        target_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        type_{static_cast< ::mmorpg::ObjectiveType >(0)},
        current_progress_{0},
        required_progress_{0},
        is_completed_{false},
        is_optional_{false},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR QuestObjective::QuestObjective(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct QuestObjectiveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QuestObjectiveDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~QuestObjectiveDefaultTypeInternal() {}
  union {
    QuestObjective _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QuestObjectiveDefaultTypeInternal _QuestObjective_default_instance_;

inline constexpr ItemEffect::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : effect_type_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        value_{0},
        duration_{0},
        chance_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR ItemEffect::ItemEffect(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct ItemEffectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ItemEffectDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ItemEffectDefaultTypeInternal() {}
  union {
    ItemEffect _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ItemEffectDefaultTypeInternal _ItemEffect_default_instance_;
      template <typename>
PROTOBUF_CONSTEXPR Item_StatsEntry_DoNotUse::Item_StatsEntry_DoNotUse(::_pbi::ConstantInitialized) {}
struct Item_StatsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Item_StatsEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Item_StatsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    Item_StatsEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Item_StatsEntry_DoNotUseDefaultTypeInternal _Item_StatsEntry_DoNotUse_default_instance_;
      template <typename>
PROTOBUF_CONSTEXPR GameActionResponse_ResultsEntry_DoNotUse::GameActionResponse_ResultsEntry_DoNotUse(::_pbi::ConstantInitialized) {}
struct GameActionResponse_ResultsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameActionResponse_ResultsEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameActionResponse_ResultsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    GameActionResponse_ResultsEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameActionResponse_ResultsEntry_DoNotUseDefaultTypeInternal _GameActionResponse_ResultsEntry_DoNotUse_default_instance_;
      template <typename>
PROTOBUF_CONSTEXPR GameActionRequest_ParametersEntry_DoNotUse::GameActionRequest_ParametersEntry_DoNotUse(::_pbi::ConstantInitialized) {}
struct GameActionRequest_ParametersEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameActionRequest_ParametersEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameActionRequest_ParametersEntry_DoNotUseDefaultTypeInternal() {}
  union {
    GameActionRequest_ParametersEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameActionRequest_ParametersEntry_DoNotUseDefaultTypeInternal _GameActionRequest_ParametersEntry_DoNotUse_default_instance_;
      template <typename>
PROTOBUF_CONSTEXPR CurrencyUpdate_CurrenciesEntry_DoNotUse::CurrencyUpdate_CurrenciesEntry_DoNotUse(::_pbi::ConstantInitialized) {}
struct CurrencyUpdate_CurrenciesEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CurrencyUpdate_CurrenciesEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CurrencyUpdate_CurrenciesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    CurrencyUpdate_CurrenciesEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CurrencyUpdate_CurrenciesEntry_DoNotUseDefaultTypeInternal _CurrencyUpdate_CurrenciesEntry_DoNotUse_default_instance_;

inline constexpr CombatEffect::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : target_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        effect_type_{static_cast< ::mmorpg::CombatEffectType >(0)},
        value_{0},
        is_critical_{false},
        is_blocked_{false},
        is_dodged_{false},
        is_resisted_{false},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR CombatEffect::CombatEffect(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CombatEffectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CombatEffectDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CombatEffectDefaultTypeInternal() {}
  union {
    CombatEffect _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CombatEffectDefaultTypeInternal _CombatEffect_default_instance_;

inline constexpr TradeOffer::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : items_{},
        player_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        gold_{::int64_t{0}},
        locked_{false},
        accepted_{false},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR TradeOffer::TradeOffer(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct TradeOfferDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TradeOfferDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TradeOfferDefaultTypeInternal() {}
  union {
    TradeOffer _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TradeOfferDefaultTypeInternal _TradeOffer_default_instance_;

inline constexpr StatsUpdate::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        player_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        stats_{nullptr},
        attributes_{nullptr},
        experience_{::int64_t{0}},
        experience_to_next_level_{::int64_t{0}},
        level_{0} {}

template <typename>
PROTOBUF_CONSTEXPR StatsUpdate::StatsUpdate(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct StatsUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatsUpdateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatsUpdateDefaultTypeInternal() {}
  union {
    StatsUpdate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsUpdateDefaultTypeInternal _StatsUpdate_default_instance_;

inline constexpr SkillUseResult::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : effects_{},
        skill_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        failure_reason_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        success_{false},
        cooldown_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR SkillUseResult::SkillUseResult(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct SkillUseResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SkillUseResultDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SkillUseResultDefaultTypeInternal() {}
  union {
    SkillUseResult _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SkillUseResultDefaultTypeInternal _SkillUseResult_default_instance_;

inline constexpr SkillUseRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        player_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        skill_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        target_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        target_position_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR SkillUseRequest::SkillUseRequest(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct SkillUseRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SkillUseRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SkillUseRequestDefaultTypeInternal() {}
  union {
    SkillUseRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SkillUseRequestDefaultTypeInternal _SkillUseRequest_default_instance_;

inline constexpr QuestInfo::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        objectives_{},
        rewards_{},
        quest_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        quest_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        description_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        accepted_at_{nullptr},
        completed_at_{nullptr},
        status_{static_cast< ::mmorpg::QuestStatus >(0)},
        recommended_level_{0},
        is_main_quest_{false},
        is_daily_quest_{false} {}

template <typename>
PROTOBUF_CONSTEXPR QuestInfo::QuestInfo(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct QuestInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QuestInfoDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~QuestInfoDefaultTypeInternal() {}
  union {
    QuestInfo _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QuestInfoDefaultTypeInternal _QuestInfo_default_instance_;

inline constexpr Item::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : stats_{},
        effects_{},
        item_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        item_type_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        description_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        icon_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        equipment_slot_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        rarity_{static_cast< ::mmorpg::ItemRarity >(0)},
        max_stack_{0},
        is_unique_{false},
        is_quest_item_{false},
        is_bound_{false},
        required_level_{0},
        sell_price_{::int64_t{0}},
        required_class_{static_cast< ::mmorpg::CharacterClass >(0)},
        durability_{0},
        buy_price_{::int64_t{0}},
        max_durability_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Item::Item(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct ItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ItemDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ItemDefaultTypeInternal() {}
  union {
    Item _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ItemDefaultTypeInternal _Item_default_instance_;

inline constexpr GameActionResponse::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : results_{},
        action_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        message_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        success_{false},
        error_code_{static_cast< ::mmorpg::ErrorCode >(0)},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR GameActionResponse::GameActionResponse(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct GameActionResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameActionResponseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameActionResponseDefaultTypeInternal() {}
  union {
    GameActionResponse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameActionResponseDefaultTypeInternal _GameActionResponse_default_instance_;

inline constexpr GameActionRequest::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        parameters_{},
        player_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        target_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        action_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        timestamp_{nullptr},
        action_type_{static_cast< ::mmorpg::ActionType >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR GameActionRequest::GameActionRequest(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct GameActionRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameActionRequestDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameActionRequestDefaultTypeInternal() {}
  union {
    GameActionRequest _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameActionRequestDefaultTypeInternal _GameActionRequest_default_instance_;

inline constexpr CurrencyUpdate::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : currencies_{},
        player_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR CurrencyUpdate::CurrencyUpdate(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CurrencyUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CurrencyUpdateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CurrencyUpdateDefaultTypeInternal() {}
  union {
    CurrencyUpdate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CurrencyUpdateDefaultTypeInternal _CurrencyUpdate_default_instance_;

inline constexpr CombatResult::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : effects_{},
        action_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        failure_reason_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        success_{false},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR CombatResult::CombatResult(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CombatResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CombatResultDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CombatResultDefaultTypeInternal() {}
  union {
    CombatResult _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CombatResultDefaultTypeInternal _CombatResult_default_instance_;

inline constexpr CombatAction::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        attacker_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        target_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        skill_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        timestamp_{nullptr},
        action_type_{static_cast< ::mmorpg::CombatActionType >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR CombatAction::CombatAction(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct CombatActionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CombatActionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CombatActionDefaultTypeInternal() {}
  union {
    CombatAction _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CombatActionDefaultTypeInternal _CombatAction_default_instance_;

inline constexpr AchievementUnlocked::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        player_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        achievement_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        achievement_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        description_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        unlocked_at_{nullptr},
        points_{0} {}

template <typename>
PROTOBUF_CONSTEXPR AchievementUnlocked::AchievementUnlocked(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct AchievementUnlockedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AchievementUnlockedDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AchievementUnlockedDefaultTypeInternal() {}
  union {
    AchievementUnlocked _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AchievementUnlockedDefaultTypeInternal _AchievementUnlocked_default_instance_;

inline constexpr TradeUpdate::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        trade_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        initiator_offer_{nullptr},
        target_offer_{nullptr},
        state_{static_cast< ::mmorpg::TradeState >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR TradeUpdate::TradeUpdate(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct TradeUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TradeUpdateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TradeUpdateDefaultTypeInternal() {}
  union {
    TradeUpdate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TradeUpdateDefaultTypeInternal _TradeUpdate_default_instance_;

inline constexpr QuestUpdate::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : active_quests_{},
        completed_quests_{},
        available_quest_ids_{},
        player_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR QuestUpdate::QuestUpdate(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct QuestUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR QuestUpdateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~QuestUpdateDefaultTypeInternal() {}
  union {
    QuestUpdate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 QuestUpdateDefaultTypeInternal _QuestUpdate_default_instance_;

inline constexpr LootItem::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        item_{nullptr},
        quantity_{0} {}

template <typename>
PROTOBUF_CONSTEXPR LootItem::LootItem(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct LootItemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LootItemDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LootItemDefaultTypeInternal() {}
  union {
    LootItem _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LootItemDefaultTypeInternal _LootItem_default_instance_;

inline constexpr InventorySlot::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        item_{nullptr},
        slot_index_{0},
        quantity_{0} {}

template <typename>
PROTOBUF_CONSTEXPR InventorySlot::InventorySlot(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct InventorySlotDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InventorySlotDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InventorySlotDefaultTypeInternal() {}
  union {
    InventorySlot _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InventorySlotDefaultTypeInternal _InventorySlot_default_instance_;

inline constexpr LootDropped::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        items_{},
        allowed_looters_{},
        entity_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        loot_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        position_{nullptr},
        expires_at_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR LootDropped::LootDropped(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct LootDroppedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LootDroppedDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~LootDroppedDefaultTypeInternal() {}
  union {
    LootDropped _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LootDroppedDefaultTypeInternal _LootDropped_default_instance_;

inline constexpr InventoryUpdate::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : slots_{},
        player_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        total_slots_{0},
        used_slots_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR InventoryUpdate::InventoryUpdate(::_pbi::ConstantInitialized)
    : _impl_(::_pbi::ConstantInitialized()) {}
struct InventoryUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InventoryUpdateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InventoryUpdateDefaultTypeInternal() {}
  union {
    InventoryUpdate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InventoryUpdateDefaultTypeInternal _InventoryUpdate_default_instance_;
}  // namespace mmorpg
static ::_pb::Metadata file_level_metadata_game_2eproto[28];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_game_2eproto[8];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_game_2eproto = nullptr;
const ::uint32_t TableStruct_game_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::mmorpg::GameActionRequest_ParametersEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::GameActionRequest_ParametersEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::GameActionRequest_ParametersEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::GameActionRequest_ParametersEntry_DoNotUse, value_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::mmorpg::GameActionRequest, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::GameActionRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::GameActionRequest, _impl_.player_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::GameActionRequest, _impl_.action_type_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::GameActionRequest, _impl_.target_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::GameActionRequest, _impl_.action_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::GameActionRequest, _impl_.parameters_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::GameActionRequest, _impl_.timestamp_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    PROTOBUF_FIELD_OFFSET(::mmorpg::GameActionResponse_ResultsEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::GameActionResponse_ResultsEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::GameActionResponse_ResultsEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::GameActionResponse_ResultsEntry_DoNotUse, value_),
    0,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::mmorpg::GameActionResponse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::GameActionResponse, _impl_.success_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::GameActionResponse, _impl_.action_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::GameActionResponse, _impl_.message_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::GameActionResponse, _impl_.error_code_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::GameActionResponse, _impl_.results_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::mmorpg::InventoryUpdate, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::InventoryUpdate, _impl_.player_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::InventoryUpdate, _impl_.slots_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::InventoryUpdate, _impl_.total_slots_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::InventoryUpdate, _impl_.used_slots_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::InventorySlot, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::InventorySlot, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::InventorySlot, _impl_.slot_index_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::InventorySlot, _impl_.item_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::InventorySlot, _impl_.quantity_),
    ~0u,
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::mmorpg::Item_StatsEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::Item_StatsEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::Item_StatsEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::Item_StatsEntry_DoNotUse, value_),
    0,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::mmorpg::Item, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::Item, _impl_.item_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::Item, _impl_.item_type_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::Item, _impl_.name_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::Item, _impl_.description_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::Item, _impl_.icon_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::Item, _impl_.rarity_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::Item, _impl_.max_stack_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::Item, _impl_.is_unique_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::Item, _impl_.is_quest_item_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::Item, _impl_.is_bound_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::Item, _impl_.required_level_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::Item, _impl_.required_class_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::Item, _impl_.stats_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::Item, _impl_.effects_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::Item, _impl_.sell_price_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::Item, _impl_.buy_price_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::Item, _impl_.equipment_slot_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::Item, _impl_.durability_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::Item, _impl_.max_durability_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::mmorpg::ItemEffect, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::ItemEffect, _impl_.effect_type_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::ItemEffect, _impl_.value_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::ItemEffect, _impl_.duration_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::ItemEffect, _impl_.chance_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::StatsUpdate, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::StatsUpdate, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::StatsUpdate, _impl_.player_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::StatsUpdate, _impl_.stats_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::StatsUpdate, _impl_.attributes_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::StatsUpdate, _impl_.level_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::StatsUpdate, _impl_.experience_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::StatsUpdate, _impl_.experience_to_next_level_),
    ~0u,
    0,
    1,
    ~0u,
    ~0u,
    ~0u,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestUpdate, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestUpdate, _impl_.player_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestUpdate, _impl_.active_quests_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestUpdate, _impl_.completed_quests_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestUpdate, _impl_.available_quest_ids_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestInfo, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestInfo, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestInfo, _impl_.quest_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestInfo, _impl_.quest_name_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestInfo, _impl_.description_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestInfo, _impl_.status_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestInfo, _impl_.objectives_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestInfo, _impl_.rewards_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestInfo, _impl_.recommended_level_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestInfo, _impl_.is_main_quest_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestInfo, _impl_.is_daily_quest_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestInfo, _impl_.accepted_at_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestInfo, _impl_.completed_at_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestObjective, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestObjective, _impl_.objective_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestObjective, _impl_.description_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestObjective, _impl_.type_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestObjective, _impl_.target_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestObjective, _impl_.current_progress_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestObjective, _impl_.required_progress_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestObjective, _impl_.is_completed_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestObjective, _impl_.is_optional_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestReward, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestReward, _impl_.type_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestReward, _impl_.reward_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::QuestReward, _impl_.quantity_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::CombatAction, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::CombatAction, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::CombatAction, _impl_.attacker_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::CombatAction, _impl_.target_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::CombatAction, _impl_.skill_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::CombatAction, _impl_.action_type_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::CombatAction, _impl_.timestamp_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::mmorpg::CombatResult, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::CombatResult, _impl_.action_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::CombatResult, _impl_.success_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::CombatResult, _impl_.effects_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::CombatResult, _impl_.failure_reason_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::mmorpg::CombatEffect, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::CombatEffect, _impl_.target_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::CombatEffect, _impl_.effect_type_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::CombatEffect, _impl_.value_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::CombatEffect, _impl_.is_critical_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::CombatEffect, _impl_.is_blocked_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::CombatEffect, _impl_.is_dodged_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::CombatEffect, _impl_.is_resisted_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::mmorpg::TradeRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::TradeRequest, _impl_.initiator_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::TradeRequest, _impl_.target_player_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::TradeUpdate, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::TradeUpdate, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::TradeUpdate, _impl_.trade_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::TradeUpdate, _impl_.state_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::TradeUpdate, _impl_.initiator_offer_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::TradeUpdate, _impl_.target_offer_),
    ~0u,
    ~0u,
    0,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::mmorpg::TradeOffer, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::TradeOffer, _impl_.player_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::TradeOffer, _impl_.items_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::TradeOffer, _impl_.gold_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::TradeOffer, _impl_.locked_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::TradeOffer, _impl_.accepted_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::mmorpg::TradeItem, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::TradeItem, _impl_.item_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::TradeItem, _impl_.quantity_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::TradeItem, _impl_.inventory_slot_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::SkillUseRequest, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::SkillUseRequest, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::SkillUseRequest, _impl_.player_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::SkillUseRequest, _impl_.skill_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::SkillUseRequest, _impl_.target_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::SkillUseRequest, _impl_.target_position_),
    ~0u,
    ~0u,
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::mmorpg::SkillUseResult, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::SkillUseResult, _impl_.success_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::SkillUseResult, _impl_.skill_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::SkillUseResult, _impl_.cooldown_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::SkillUseResult, _impl_.failure_reason_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::SkillUseResult, _impl_.effects_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::LootDropped, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::LootDropped, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::LootDropped, _impl_.entity_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::LootDropped, _impl_.loot_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::LootDropped, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::LootDropped, _impl_.items_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::LootDropped, _impl_.allowed_looters_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::LootDropped, _impl_.expires_at_),
    ~0u,
    ~0u,
    0,
    ~0u,
    ~0u,
    1,
    PROTOBUF_FIELD_OFFSET(::mmorpg::LootItem, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::LootItem, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::LootItem, _impl_.item_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::LootItem, _impl_.quantity_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::mmorpg::CurrencyUpdate_CurrenciesEntry_DoNotUse, _has_bits_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::CurrencyUpdate_CurrenciesEntry_DoNotUse, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::CurrencyUpdate_CurrenciesEntry_DoNotUse, key_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::CurrencyUpdate_CurrenciesEntry_DoNotUse, value_),
    0,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::mmorpg::CurrencyUpdate, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::CurrencyUpdate, _impl_.player_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::CurrencyUpdate, _impl_.currencies_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::AchievementUnlocked, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::AchievementUnlocked, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::mmorpg::AchievementUnlocked, _impl_.player_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::AchievementUnlocked, _impl_.achievement_id_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::AchievementUnlocked, _impl_.achievement_name_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::AchievementUnlocked, _impl_.description_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::AchievementUnlocked, _impl_.points_),
    PROTOBUF_FIELD_OFFSET(::mmorpg::AchievementUnlocked, _impl_.unlocked_at_),
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    0,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        {0, 10, -1, sizeof(::mmorpg::GameActionRequest_ParametersEntry_DoNotUse)},
        {12, 26, -1, sizeof(::mmorpg::GameActionRequest)},
        {32, 42, -1, sizeof(::mmorpg::GameActionResponse_ResultsEntry_DoNotUse)},
        {44, -1, -1, sizeof(::mmorpg::GameActionResponse)},
        {57, -1, -1, sizeof(::mmorpg::InventoryUpdate)},
        {69, 80, -1, sizeof(::mmorpg::InventorySlot)},
        {83, 93, -1, sizeof(::mmorpg::Item_StatsEntry_DoNotUse)},
        {95, -1, -1, sizeof(::mmorpg::Item)},
        {122, -1, -1, sizeof(::mmorpg::ItemEffect)},
        {134, 148, -1, sizeof(::mmorpg::StatsUpdate)},
        {154, -1, -1, sizeof(::mmorpg::QuestUpdate)},
        {166, 185, -1, sizeof(::mmorpg::QuestInfo)},
        {196, -1, -1, sizeof(::mmorpg::QuestObjective)},
        {212, -1, -1, sizeof(::mmorpg::QuestReward)},
        {223, 236, -1, sizeof(::mmorpg::CombatAction)},
        {241, -1, -1, sizeof(::mmorpg::CombatResult)},
        {253, -1, -1, sizeof(::mmorpg::CombatEffect)},
        {268, -1, -1, sizeof(::mmorpg::TradeRequest)},
        {278, 290, -1, sizeof(::mmorpg::TradeUpdate)},
        {294, -1, -1, sizeof(::mmorpg::TradeOffer)},
        {307, -1, -1, sizeof(::mmorpg::TradeItem)},
        {318, 330, -1, sizeof(::mmorpg::SkillUseRequest)},
        {334, -1, -1, sizeof(::mmorpg::SkillUseResult)},
        {347, 361, -1, sizeof(::mmorpg::LootDropped)},
        {367, 377, -1, sizeof(::mmorpg::LootItem)},
        {379, 389, -1, sizeof(::mmorpg::CurrencyUpdate_CurrenciesEntry_DoNotUse)},
        {391, -1, -1, sizeof(::mmorpg::CurrencyUpdate)},
        {401, 415, -1, sizeof(::mmorpg::AchievementUnlocked)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::mmorpg::_GameActionRequest_ParametersEntry_DoNotUse_default_instance_._instance,
    &::mmorpg::_GameActionRequest_default_instance_._instance,
    &::mmorpg::_GameActionResponse_ResultsEntry_DoNotUse_default_instance_._instance,
    &::mmorpg::_GameActionResponse_default_instance_._instance,
    &::mmorpg::_InventoryUpdate_default_instance_._instance,
    &::mmorpg::_InventorySlot_default_instance_._instance,
    &::mmorpg::_Item_StatsEntry_DoNotUse_default_instance_._instance,
    &::mmorpg::_Item_default_instance_._instance,
    &::mmorpg::_ItemEffect_default_instance_._instance,
    &::mmorpg::_StatsUpdate_default_instance_._instance,
    &::mmorpg::_QuestUpdate_default_instance_._instance,
    &::mmorpg::_QuestInfo_default_instance_._instance,
    &::mmorpg::_QuestObjective_default_instance_._instance,
    &::mmorpg::_QuestReward_default_instance_._instance,
    &::mmorpg::_CombatAction_default_instance_._instance,
    &::mmorpg::_CombatResult_default_instance_._instance,
    &::mmorpg::_CombatEffect_default_instance_._instance,
    &::mmorpg::_TradeRequest_default_instance_._instance,
    &::mmorpg::_TradeUpdate_default_instance_._instance,
    &::mmorpg::_TradeOffer_default_instance_._instance,
    &::mmorpg::_TradeItem_default_instance_._instance,
    &::mmorpg::_SkillUseRequest_default_instance_._instance,
    &::mmorpg::_SkillUseResult_default_instance_._instance,
    &::mmorpg::_LootDropped_default_instance_._instance,
    &::mmorpg::_LootItem_default_instance_._instance,
    &::mmorpg::_CurrencyUpdate_CurrenciesEntry_DoNotUse_default_instance_._instance,
    &::mmorpg::_CurrencyUpdate_default_instance_._instance,
    &::mmorpg::_AchievementUnlocked_default_instance_._instance,
};
const char descriptor_table_protodef_game_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\ngame.proto\022\006mmorpg\032\037google/protobuf/ti"
    "mestamp.proto\032\nbase.proto\032\017character.pro"
    "to\"\226\002\n\021GameActionRequest\022\021\n\tplayer_id\030\001 "
    "\001(\t\022\'\n\013action_type\030\002 \001(\0162\022.mmorpg.Action"
    "Type\022\021\n\ttarget_id\030\003 \001(\t\022\021\n\taction_id\030\004 \001"
    "(\t\022=\n\nparameters\030\005 \003(\0132).mmorpg.GameActi"
    "onRequest.ParametersEntry\022-\n\ttimestamp\030\006"
    " \001(\0132\032.google.protobuf.Timestamp\0321\n\017Para"
    "metersEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:"
    "\0028\001\"\332\001\n\022GameActionResponse\022\017\n\007success\030\001 "
    "\001(\010\022\021\n\taction_id\030\002 \001(\t\022\017\n\007message\030\003 \001(\t\022"
    "%\n\nerror_code\030\004 \001(\0162\021.mmorpg.ErrorCode\0228"
    "\n\007results\030\005 \003(\0132\'.mmorpg.GameActionRespo"
    "nse.ResultsEntry\032.\n\014ResultsEntry\022\013\n\003key\030"
    "\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"s\n\017InventoryUpd"
    "ate\022\021\n\tplayer_id\030\001 \001(\t\022$\n\005slots\030\002 \003(\0132\025."
    "mmorpg.InventorySlot\022\023\n\013total_slots\030\003 \001("
    "\005\022\022\n\nused_slots\030\004 \001(\005\"Q\n\rInventorySlot\022\022"
    "\n\nslot_index\030\001 \001(\005\022\032\n\004item\030\002 \001(\0132\014.mmorp"
    "g.Item\022\020\n\010quantity\030\003 \001(\005\"\377\003\n\004Item\022\017\n\007ite"
    "m_id\030\001 \001(\t\022\021\n\titem_type\030\002 \001(\t\022\014\n\004name\030\003 "
    "\001(\t\022\023\n\013description\030\004 \001(\t\022\017\n\007icon_id\030\005 \001("
    "\t\022\"\n\006rarity\030\006 \001(\0162\022.mmorpg.ItemRarity\022\021\n"
    "\tmax_stack\030\007 \001(\005\022\021\n\tis_unique\030\010 \001(\010\022\025\n\ri"
    "s_quest_item\030\t \001(\010\022\020\n\010is_bound\030\n \001(\010\022\026\n\016"
    "required_level\030\013 \001(\005\022.\n\016required_class\030\014"
    " \001(\0162\026.mmorpg.CharacterClass\022&\n\005stats\030\r "
    "\003(\0132\027.mmorpg.Item.StatsEntry\022#\n\007effects\030"
    "\016 \003(\0132\022.mmorpg.ItemEffect\022\022\n\nsell_price\030"
    "\017 \001(\003\022\021\n\tbuy_price\030\020 \001(\003\022\026\n\016equipment_sl"
    "ot\030\021 \001(\t\022\022\n\ndurability\030\022 \001(\005\022\026\n\016max_dura"
    "bility\030\023 \001(\005\032,\n\nStatsEntry\022\013\n\003key\030\001 \001(\t\022"
    "\r\n\005value\030\002 \001(\005:\0028\001\"R\n\nItemEffect\022\023\n\013effe"
    "ct_type\030\001 \001(\t\022\r\n\005value\030\002 \001(\005\022\020\n\010duration"
    "\030\003 \001(\002\022\016\n\006chance\030\004 \001(\002\"\275\001\n\013StatsUpdate\022\021"
    "\n\tplayer_id\030\001 \001(\t\022%\n\005stats\030\002 \001(\0132\026.mmorp"
    "g.CharacterStats\022/\n\nattributes\030\003 \001(\0132\033.m"
    "morpg.CharacterAttributes\022\r\n\005level\030\004 \001(\005"
    "\022\022\n\nexperience\030\005 \001(\003\022 \n\030experience_to_ne"
    "xt_level\030\006 \001(\003\"\224\001\n\013QuestUpdate\022\021\n\tplayer"
    "_id\030\001 \001(\t\022(\n\ractive_quests\030\002 \003(\0132\021.mmorp"
    "g.QuestInfo\022+\n\020completed_quests\030\003 \003(\0132\021."
    "mmorpg.QuestInfo\022\033\n\023available_quest_ids\030"
    "\004 \003(\t\"\352\002\n\tQuestInfo\022\020\n\010quest_id\030\001 \001(\t\022\022\n"
    "\nquest_name\030\002 \001(\t\022\023\n\013description\030\003 \001(\t\022#"
    "\n\006status\030\004 \001(\0162\023.mmorpg.QuestStatus\022*\n\no"
    "bjectives\030\005 \003(\0132\026.mmorpg.QuestObjective\022"
    "$\n\007rewards\030\006 \003(\0132\023.mmorpg.QuestReward\022\031\n"
    "\021recommended_level\030\007 \001(\005\022\025\n\ris_main_ques"
    "t\030\010 \001(\010\022\026\n\016is_daily_quest\030\t \001(\010\022/\n\013accep"
    "ted_at\030\n \001(\0132\032.google.protobuf.Timestamp"
    "\0220\n\014completed_at\030\013 \001(\0132\032.google.protobuf"
    ".Timestamp\"\323\001\n\016QuestObjective\022\024\n\014objecti"
    "ve_id\030\001 \001(\t\022\023\n\013description\030\002 \001(\t\022#\n\004type"
    "\030\003 \001(\0162\025.mmorpg.ObjectiveType\022\021\n\ttarget_"
    "id\030\004 \001(\t\022\030\n\020current_progress\030\005 \001(\005\022\031\n\021re"
    "quired_progress\030\006 \001(\005\022\024\n\014is_completed\030\007 "
    "\001(\010\022\023\n\013is_optional\030\010 \001(\010\"T\n\013QuestReward\022"
    " \n\004type\030\001 \001(\0162\022.mmorpg.RewardType\022\021\n\trew"
    "ard_id\030\002 \001(\t\022\020\n\010quantity\030\003 \001(\005\"\246\001\n\014Comba"
    "tAction\022\023\n\013attacker_id\030\001 \001(\t\022\021\n\ttarget_i"
    "d\030\002 \001(\t\022\020\n\010skill_id\030\003 \001(\t\022-\n\013action_type"
    "\030\004 \001(\0162\030.mmorpg.CombatActionType\022-\n\ttime"
    "stamp\030\005 \001(\0132\032.google.protobuf.Timestamp\""
    "q\n\014CombatResult\022\021\n\taction_id\030\001 \001(\t\022\017\n\007su"
    "ccess\030\002 \001(\010\022%\n\007effects\030\003 \003(\0132\024.mmorpg.Co"
    "mbatEffect\022\026\n\016failure_reason\030\004 \001(\t\"\260\001\n\014C"
    "ombatEffect\022\021\n\ttarget_id\030\001 \001(\t\022-\n\013effect"
    "_type\030\002 \001(\0162\030.mmorpg.CombatEffectType\022\r\n"
    "\005value\030\003 \001(\005\022\023\n\013is_critical\030\004 \001(\010\022\022\n\nis_"
    "blocked\030\005 \001(\010\022\021\n\tis_dodged\030\006 \001(\010\022\023\n\013is_r"
    "esisted\030\007 \001(\010\">\n\014TradeRequest\022\024\n\014initiat"
    "or_id\030\001 \001(\t\022\030\n\020target_player_id\030\002 \001(\t\"\231\001"
    "\n\013TradeUpdate\022\020\n\010trade_id\030\001 \001(\t\022!\n\005state"
    "\030\002 \001(\0162\022.mmorpg.TradeState\022+\n\017initiator_"
    "offer\030\003 \001(\0132\022.mmorpg.TradeOffer\022(\n\014targe"
    "t_offer\030\004 \001(\0132\022.mmorpg.TradeOffer\"q\n\nTra"
    "deOffer\022\021\n\tplayer_id\030\001 \001(\t\022 \n\005items\030\002 \003("
    "\0132\021.mmorpg.TradeItem\022\014\n\004gold\030\003 \001(\003\022\016\n\006lo"
    "cked\030\004 \001(\010\022\020\n\010accepted\030\005 \001(\010\"F\n\tTradeIte"
    "m\022\017\n\007item_id\030\001 \001(\t\022\020\n\010quantity\030\002 \001(\005\022\026\n\016"
    "inventory_slot\030\003 \001(\005\"s\n\017SkillUseRequest\022"
    "\021\n\tplayer_id\030\001 \001(\t\022\020\n\010skill_id\030\002 \001(\t\022\021\n\t"
    "target_id\030\003 \001(\t\022(\n\017target_position\030\004 \001(\013"
    "2\017.mmorpg.Vector3\"\204\001\n\016SkillUseResult\022\017\n\007"
    "success\030\001 \001(\010\022\020\n\010skill_id\030\002 \001(\t\022\020\n\010coold"
    "own\030\003 \001(\002\022\026\n\016failure_reason\030\004 \001(\t\022%\n\007eff"
    "ects\030\005 \003(\0132\024.mmorpg.CombatEffect\"\276\001\n\013Loo"
    "tDropped\022\021\n\tentity_id\030\001 \001(\t\022\017\n\007loot_id\030\002"
    " \001(\t\022!\n\010position\030\003 \001(\0132\017.mmorpg.Vector3\022"
    "\037\n\005items\030\004 \003(\0132\020.mmorpg.LootItem\022\027\n\017allo"
    "wed_looters\030\005 \003(\t\022.\n\nexpires_at\030\006 \001(\0132\032."
    "google.protobuf.Timestamp\"8\n\010LootItem\022\032\n"
    "\004item\030\001 \001(\0132\014.mmorpg.Item\022\020\n\010quantity\030\002 "
    "\001(\005\"\222\001\n\016CurrencyUpdate\022\021\n\tplayer_id\030\001 \001("
    "\t\022:\n\ncurrencies\030\002 \003(\0132&.mmorpg.CurrencyU"
    "pdate.CurrenciesEntry\0321\n\017CurrenciesEntry"
    "\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\003:\0028\001\"\260\001\n\023Ach"
    "ievementUnlocked\022\021\n\tplayer_id\030\001 \001(\t\022\026\n\016a"
    "chievement_id\030\002 \001(\t\022\030\n\020achievement_name\030"
    "\003 \001(\t\022\023\n\013description\030\004 \001(\t\022\016\n\006points\030\005 \001"
    "(\005\022/\n\013unlocked_at\030\006 \001(\0132\032.google.protobu"
    "f.Timestamp*\231\002\n\nActionType\022\033\n\027ACTION_TYP"
    "E_UNSPECIFIED\020\000\022\030\n\024ACTION_TYPE_USE_ITEM\020"
    "\001\022\031\n\025ACTION_TYPE_USE_SKILL\020\002\022\030\n\024ACTION_T"
    "YPE_INTERACT\020\003\022\024\n\020ACTION_TYPE_LOOT\020\004\022\025\n\021"
    "ACTION_TYPE_TRADE\020\005\022\025\n\021ACTION_TYPE_CRAFT"
    "\020\006\022\034\n\030ACTION_TYPE_QUEST_ACCEPT\020\007\022\036\n\032ACTI"
    "ON_TYPE_QUEST_COMPLETE\020\010\022\035\n\031ACTION_TYPE_"
    "QUEST_ABANDON\020\t*\274\001\n\nItemRarity\022\033\n\027ITEM_R"
    "ARITY_UNSPECIFIED\020\000\022\026\n\022ITEM_RARITY_COMMO"
    "N\020\001\022\030\n\024ITEM_RARITY_UNCOMMON\020\002\022\024\n\020ITEM_RA"
    "RITY_RARE\020\003\022\024\n\020ITEM_RARITY_EPIC\020\004\022\031\n\025ITE"
    "M_RARITY_LEGENDARY\020\005\022\030\n\024ITEM_RARITY_ARTI"
    "FACT\020\006*\261\001\n\013QuestStatus\022\034\n\030QUEST_STATUS_U"
    "NSPECIFIED\020\000\022\032\n\026QUEST_STATUS_AVAILABLE\020\001"
    "\022\027\n\023QUEST_STATUS_ACTIVE\020\002\022\032\n\026QUEST_STATU"
    "S_COMPLETED\020\003\022\027\n\023QUEST_STATUS_FAILED\020\004\022\032"
    "\n\026QUEST_STATUS_ABANDONED\020\005*\224\002\n\rObjective"
    "Type\022\036\n\032OBJECTIVE_TYPE_UNSPECIFIED\020\000\022\027\n\023"
    "OBJECTIVE_TYPE_KILL\020\001\022\032\n\026OBJECTIVE_TYPE_"
    "COLLECT\020\002\022\033\n\027OBJECTIVE_TYPE_INTERACT\020\003\022!"
    "\n\035OBJECTIVE_TYPE_REACH_LOCATION\020\004\022\032\n\026OBJ"
    "ECTIVE_TYPE_TALK_TO\020\005\022\032\n\026OBJECTIVE_TYPE_"
    "DELIVER\020\006\022\030\n\024OBJECTIVE_TYPE_CRAFT\020\007\022\034\n\030O"
    "BJECTIVE_TYPE_USE_SKILL\020\010*\307\001\n\nRewardType"
    "\022\033\n\027REWARD_TYPE_UNSPECIFIED\020\000\022\032\n\026REWARD_"
    "TYPE_EXPERIENCE\020\001\022\024\n\020REWARD_TYPE_GOLD\020\002\022"
    "\024\n\020REWARD_TYPE_ITEM\020\003\022\032\n\026REWARD_TYPE_REP"
    "UTATION\020\004\022\033\n\027REWARD_TYPE_SKILL_POINT\020\005\022\033"
    "\n\027REWARD_TYPE_ACHIEVEMENT\020\006*\234\001\n\020CombatAc"
    "tionType\022\035\n\031COMBAT_ACTION_UNSPECIFIED\020\000\022"
    "\036\n\032COMBAT_ACTION_BASIC_ATTACK\020\001\022\027\n\023COMBA"
    "T_ACTION_SKILL\020\002\022\026\n\022COMBAT_ACTION_ITEM\020\003"
    "\022\030\n\024COMBAT_ACTION_DEFEND\020\004*\246\002\n\020CombatEff"
    "ectType\022\035\n\031COMBAT_EFFECT_UNSPECIFIED\020\000\022\030"
    "\n\024COMBAT_EFFECT_DAMAGE\020\001\022\026\n\022COMBAT_EFFEC"
    "T_HEAL\020\002\022\026\n\022COMBAT_EFFECT_BUFF\020\003\022\030\n\024COMB"
    "AT_EFFECT_DEBUFF\020\004\022\025\n\021COMBAT_EFFECT_DOT\020"
    "\005\022\025\n\021COMBAT_EFFECT_HOT\020\006\022\026\n\022COMBAT_EFFEC"
    "T_STUN\020\007\022\026\n\022COMBAT_EFFECT_SLOW\020\010\022\026\n\022COMB"
    "AT_EFFECT_ROOT\020\t\022\031\n\025COMBAT_EFFECT_SILENC"
    "E\020\n*\220\001\n\nTradeState\022\033\n\027TRADE_STATE_UNSPEC"
    "IFIED\020\000\022\027\n\023TRADE_STATE_PENDING\020\001\022\026\n\022TRAD"
    "E_STATE_ACTIVE\020\002\022\031\n\025TRADE_STATE_COMPLETE"
    "D\020\003\022\031\n\025TRADE_STATE_CANCELLED\020\004B.Z,github"
    ".com/mmorpg-template/backend/pkg/protob\006"
    "proto3"
};
static const ::_pbi::DescriptorTable* const descriptor_table_game_2eproto_deps[3] =
    {
        &::descriptor_table_base_2eproto,
        &::descriptor_table_character_2eproto,
        &::descriptor_table_google_2fprotobuf_2ftimestamp_2eproto,
};
static ::absl::once_flag descriptor_table_game_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_game_2eproto = {
    false,
    false,
    5886,
    descriptor_table_protodef_game_2eproto,
    "game.proto",
    &descriptor_table_game_2eproto_once,
    descriptor_table_game_2eproto_deps,
    3,
    28,
    schemas,
    file_default_instances,
    TableStruct_game_2eproto::offsets,
    file_level_metadata_game_2eproto,
    file_level_enum_descriptors_game_2eproto,
    file_level_service_descriptors_game_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_game_2eproto_getter() {
  return &descriptor_table_game_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_game_2eproto(&descriptor_table_game_2eproto);
namespace mmorpg {
const ::google::protobuf::EnumDescriptor* ActionType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_game_2eproto);
  return file_level_enum_descriptors_game_2eproto[0];
}
PROTOBUF_CONSTINIT const uint32_t ActionType_internal_data_[] = {
    655360u, 0u, };
bool ActionType_IsValid(int value) {
  return 0 <= value && value <= 9;
}
const ::google::protobuf::EnumDescriptor* ItemRarity_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_game_2eproto);
  return file_level_enum_descriptors_game_2eproto[1];
}
PROTOBUF_CONSTINIT const uint32_t ItemRarity_internal_data_[] = {
    458752u, 0u, };
bool ItemRarity_IsValid(int value) {
  return 0 <= value && value <= 6;
}
const ::google::protobuf::EnumDescriptor* QuestStatus_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_game_2eproto);
  return file_level_enum_descriptors_game_2eproto[2];
}
PROTOBUF_CONSTINIT const uint32_t QuestStatus_internal_data_[] = {
    393216u, 0u, };
bool QuestStatus_IsValid(int value) {
  return 0 <= value && value <= 5;
}
const ::google::protobuf::EnumDescriptor* ObjectiveType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_game_2eproto);
  return file_level_enum_descriptors_game_2eproto[3];
}
PROTOBUF_CONSTINIT const uint32_t ObjectiveType_internal_data_[] = {
    589824u, 0u, };
bool ObjectiveType_IsValid(int value) {
  return 0 <= value && value <= 8;
}
const ::google::protobuf::EnumDescriptor* RewardType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_game_2eproto);
  return file_level_enum_descriptors_game_2eproto[4];
}
PROTOBUF_CONSTINIT const uint32_t RewardType_internal_data_[] = {
    458752u, 0u, };
bool RewardType_IsValid(int value) {
  return 0 <= value && value <= 6;
}
const ::google::protobuf::EnumDescriptor* CombatActionType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_game_2eproto);
  return file_level_enum_descriptors_game_2eproto[5];
}
PROTOBUF_CONSTINIT const uint32_t CombatActionType_internal_data_[] = {
    327680u, 0u, };
bool CombatActionType_IsValid(int value) {
  return 0 <= value && value <= 4;
}
const ::google::protobuf::EnumDescriptor* CombatEffectType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_game_2eproto);
  return file_level_enum_descriptors_game_2eproto[6];
}
PROTOBUF_CONSTINIT const uint32_t CombatEffectType_internal_data_[] = {
    720896u, 0u, };
bool CombatEffectType_IsValid(int value) {
  return 0 <= value && value <= 10;
}
const ::google::protobuf::EnumDescriptor* TradeState_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_game_2eproto);
  return file_level_enum_descriptors_game_2eproto[7];
}
PROTOBUF_CONSTINIT const uint32_t TradeState_internal_data_[] = {
    327680u, 0u, };
bool TradeState_IsValid(int value) {
  return 0 <= value && value <= 4;
}
// ===================================================================

GameActionRequest_ParametersEntry_DoNotUse::GameActionRequest_ParametersEntry_DoNotUse() {}
GameActionRequest_ParametersEntry_DoNotUse::GameActionRequest_ParametersEntry_DoNotUse(::google::protobuf::Arena* arena)
    : SuperType(arena) {}
::google::protobuf::Metadata GameActionRequest_ParametersEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[0]);
}
// ===================================================================

class GameActionRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<GameActionRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(GameActionRequest, _impl_._has_bits_);
  static const ::google::protobuf::Timestamp& timestamp(const GameActionRequest* msg);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::google::protobuf::Timestamp& GameActionRequest::_Internal::timestamp(const GameActionRequest* msg) {
  return *msg->_impl_.timestamp_;
}
void GameActionRequest::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.timestamp_ != nullptr) _impl_.timestamp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
GameActionRequest::GameActionRequest(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:mmorpg.GameActionRequest)
}
inline PROTOBUF_NDEBUG_INLINE GameActionRequest::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        parameters_{visibility, arena, from.parameters_},
        player_id_(arena, from.player_id_),
        target_id_(arena, from.target_id_),
        action_id_(arena, from.action_id_) {}

GameActionRequest::GameActionRequest(
    ::google::protobuf::Arena* arena,
    const GameActionRequest& from)
    : ::google::protobuf::Message(arena) {
  GameActionRequest* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.timestamp_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::google::protobuf::Timestamp>(arena, *from._impl_.timestamp_)
                : nullptr;
  _impl_.action_type_ = from._impl_.action_type_;

  // @@protoc_insertion_point(copy_constructor:mmorpg.GameActionRequest)
}
inline PROTOBUF_NDEBUG_INLINE GameActionRequest::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        parameters_{visibility, arena},
        player_id_(arena),
        target_id_(arena),
        action_id_(arena) {}

inline void GameActionRequest::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_),
           0,
           offsetof(Impl_, action_type_) -
               offsetof(Impl_, timestamp_) +
               sizeof(Impl_::action_type_));
}
GameActionRequest::~GameActionRequest() {
  // @@protoc_insertion_point(destructor:mmorpg.GameActionRequest)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void GameActionRequest::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.player_id_.Destroy();
  _impl_.target_id_.Destroy();
  _impl_.action_id_.Destroy();
  delete _impl_.timestamp_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void GameActionRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:mmorpg.GameActionRequest)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.parameters_.Clear();
  _impl_.player_id_.ClearToEmpty();
  _impl_.target_id_.ClearToEmpty();
  _impl_.action_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.timestamp_ != nullptr);
    _impl_.timestamp_->Clear();
  }
  _impl_.action_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* GameActionRequest::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 2, 70, 2> GameActionRequest::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(GameActionRequest, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_GameActionRequest_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string player_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(GameActionRequest, _impl_.player_id_)}},
    // .mmorpg.ActionType action_type = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(GameActionRequest, _impl_.action_type_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(GameActionRequest, _impl_.action_type_)}},
    // string target_id = 3;
    {::_pbi::TcParser::FastUS1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(GameActionRequest, _impl_.target_id_)}},
    // string action_id = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(GameActionRequest, _impl_.action_id_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // .google.protobuf.Timestamp timestamp = 6;
    {::_pbi::TcParser::FastMtS1,
     {50, 0, 1, PROTOBUF_FIELD_OFFSET(GameActionRequest, _impl_.timestamp_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string player_id = 1;
    {PROTOBUF_FIELD_OFFSET(GameActionRequest, _impl_.player_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .mmorpg.ActionType action_type = 2;
    {PROTOBUF_FIELD_OFFSET(GameActionRequest, _impl_.action_type_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // string target_id = 3;
    {PROTOBUF_FIELD_OFFSET(GameActionRequest, _impl_.target_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string action_id = 4;
    {PROTOBUF_FIELD_OFFSET(GameActionRequest, _impl_.action_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // map<string, string> parameters = 5;
    {PROTOBUF_FIELD_OFFSET(GameActionRequest, _impl_.parameters_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
    // .google.protobuf.Timestamp timestamp = 6;
    {PROTOBUF_FIELD_OFFSET(GameActionRequest, _impl_.timestamp_), _Internal::kHasBitsOffset + 0, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetMapAuxInfo<
        decltype(GameActionRequest()._impl_.parameters_)>(
        1, 0, 0, 9,
        9)},
    {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
  }}, {{
    "\30\11\0\11\11\12\0\0"
    "mmorpg.GameActionRequest"
    "player_id"
    "target_id"
    "action_id"
    "parameters"
  }},
};

::uint8_t* GameActionRequest::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mmorpg.GameActionRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string player_id = 1;
  if (!this->_internal_player_id().empty()) {
    const std::string& _s = this->_internal_player_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.GameActionRequest.player_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // .mmorpg.ActionType action_type = 2;
  if (this->_internal_action_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_action_type(), target);
  }

  // string target_id = 3;
  if (!this->_internal_target_id().empty()) {
    const std::string& _s = this->_internal_target_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.GameActionRequest.target_id");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string action_id = 4;
  if (!this->_internal_action_id().empty()) {
    const std::string& _s = this->_internal_action_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.GameActionRequest.action_id");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // map<string, string> parameters = 5;
  if (!_internal_parameters().empty()) {
    using MapType = ::google::protobuf::Map<std::string, std::string>;
    using WireHelper = _pbi::MapEntryFuncs<std::string, std::string,
                                   _pbi::WireFormatLite::TYPE_STRING,
                                   _pbi::WireFormatLite::TYPE_STRING>;
    const auto& field = _internal_parameters();

    if (stream->IsSerializationDeterministic() && field.size() > 1) {
      for (const auto& entry : ::google::protobuf::internal::MapSorterPtr<MapType>(field)) {
        target = WireHelper::InternalSerialize(
            5, entry.first, entry.second, target, stream);
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.GameActionRequest.parameters");
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.GameActionRequest.parameters");
      }
    } else {
      for (const auto& entry : field) {
        target = WireHelper::InternalSerialize(
            5, entry.first, entry.second, target, stream);
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.GameActionRequest.parameters");
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.GameActionRequest.parameters");
      }
    }
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .google.protobuf.Timestamp timestamp = 6;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        6, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mmorpg.GameActionRequest)
  return target;
}

::size_t GameActionRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mmorpg.GameActionRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> parameters = 5;
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_parameters_size());
  for (const auto& entry : _internal_parameters()) {
    total_size += _pbi::MapEntryFuncs<std::string, std::string,
                                   _pbi::WireFormatLite::TYPE_STRING,
                                   _pbi::WireFormatLite::TYPE_STRING>::ByteSizeLong(entry.first, entry.second);
  }
  // string player_id = 1;
  if (!this->_internal_player_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_player_id());
  }

  // string target_id = 3;
  if (!this->_internal_target_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_target_id());
  }

  // string action_id = 4;
  if (!this->_internal_action_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_action_id());
  }

  // .google.protobuf.Timestamp timestamp = 6;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size +=
        1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.timestamp_);
  }

  // .mmorpg.ActionType action_type = 2;
  if (this->_internal_action_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_action_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData GameActionRequest::_class_data_ = {
    GameActionRequest::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* GameActionRequest::GetClassData() const {
  return &_class_data_;
}

void GameActionRequest::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<GameActionRequest*>(&to_msg);
  auto& from = static_cast<const GameActionRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:mmorpg.GameActionRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.parameters_.MergeFrom(from._impl_.parameters_);
  if (!from._internal_player_id().empty()) {
    _this->_internal_set_player_id(from._internal_player_id());
  }
  if (!from._internal_target_id().empty()) {
    _this->_internal_set_target_id(from._internal_target_id());
  }
  if (!from._internal_action_id().empty()) {
    _this->_internal_set_action_id(from._internal_action_id());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_timestamp()->::google::protobuf::Timestamp::MergeFrom(
        from._internal_timestamp());
  }
  if (from._internal_action_type() != 0) {
    _this->_internal_set_action_type(from._internal_action_type());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void GameActionRequest::CopyFrom(const GameActionRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mmorpg.GameActionRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool GameActionRequest::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* GameActionRequest::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void GameActionRequest::InternalSwap(GameActionRequest* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.parameters_.InternalSwap(&other->_impl_.parameters_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.player_id_, &other->_impl_.player_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.target_id_, &other->_impl_.target_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.action_id_, &other->_impl_.action_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameActionRequest, _impl_.action_type_)
      + sizeof(GameActionRequest::_impl_.action_type_)
      - PROTOBUF_FIELD_OFFSET(GameActionRequest, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::google::protobuf::Metadata GameActionRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[1]);
}
// ===================================================================

GameActionResponse_ResultsEntry_DoNotUse::GameActionResponse_ResultsEntry_DoNotUse() {}
GameActionResponse_ResultsEntry_DoNotUse::GameActionResponse_ResultsEntry_DoNotUse(::google::protobuf::Arena* arena)
    : SuperType(arena) {}
::google::protobuf::Metadata GameActionResponse_ResultsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[2]);
}
// ===================================================================

class GameActionResponse::_Internal {
 public:
};

GameActionResponse::GameActionResponse(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:mmorpg.GameActionResponse)
}
inline PROTOBUF_NDEBUG_INLINE GameActionResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : results_{visibility, arena, from.results_},
        action_id_(arena, from.action_id_),
        message_(arena, from.message_),
        _cached_size_{0} {}

GameActionResponse::GameActionResponse(
    ::google::protobuf::Arena* arena,
    const GameActionResponse& from)
    : ::google::protobuf::Message(arena) {
  GameActionResponse* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, success_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, success_),
           offsetof(Impl_, error_code_) -
               offsetof(Impl_, success_) +
               sizeof(Impl_::error_code_));

  // @@protoc_insertion_point(copy_constructor:mmorpg.GameActionResponse)
}
inline PROTOBUF_NDEBUG_INLINE GameActionResponse::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : results_{visibility, arena},
        action_id_(arena),
        message_(arena),
        _cached_size_{0} {}

inline void GameActionResponse::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, success_),
           0,
           offsetof(Impl_, error_code_) -
               offsetof(Impl_, success_) +
               sizeof(Impl_::error_code_));
}
GameActionResponse::~GameActionResponse() {
  // @@protoc_insertion_point(destructor:mmorpg.GameActionResponse)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void GameActionResponse::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.action_id_.Destroy();
  _impl_.message_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void GameActionResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:mmorpg.GameActionResponse)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.results_.Clear();
  _impl_.action_id_.ClearToEmpty();
  _impl_.message_.ClearToEmpty();
  ::memset(&_impl_.success_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.error_code_) -
      reinterpret_cast<char*>(&_impl_.success_)) + sizeof(_impl_.error_code_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* GameActionResponse::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 5, 1, 57, 2> GameActionResponse::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    5, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_GameActionResponse_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // .mmorpg.ErrorCode error_code = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(GameActionResponse, _impl_.error_code_), 63>(),
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(GameActionResponse, _impl_.error_code_)}},
    // bool success = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(GameActionResponse, _impl_.success_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(GameActionResponse, _impl_.success_)}},
    // string action_id = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(GameActionResponse, _impl_.action_id_)}},
    // string message = 3;
    {::_pbi::TcParser::FastUS1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(GameActionResponse, _impl_.message_)}},
  }}, {{
    65535, 65535
  }}, {{
    // bool success = 1;
    {PROTOBUF_FIELD_OFFSET(GameActionResponse, _impl_.success_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // string action_id = 2;
    {PROTOBUF_FIELD_OFFSET(GameActionResponse, _impl_.action_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string message = 3;
    {PROTOBUF_FIELD_OFFSET(GameActionResponse, _impl_.message_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .mmorpg.ErrorCode error_code = 4;
    {PROTOBUF_FIELD_OFFSET(GameActionResponse, _impl_.error_code_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // map<string, string> results = 5;
    {PROTOBUF_FIELD_OFFSET(GameActionResponse, _impl_.results_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
  }}, {{
    {::_pbi::TcParser::GetMapAuxInfo<
        decltype(GameActionResponse()._impl_.results_)>(
        1, 0, 0, 9,
        9)},
  }}, {{
    "\31\0\11\7\0\7\0\0"
    "mmorpg.GameActionResponse"
    "action_id"
    "message"
    "results"
  }},
};

::uint8_t* GameActionResponse::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mmorpg.GameActionResponse)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // bool success = 1;
  if (this->_internal_success() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_success(), target);
  }

  // string action_id = 2;
  if (!this->_internal_action_id().empty()) {
    const std::string& _s = this->_internal_action_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.GameActionResponse.action_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string message = 3;
  if (!this->_internal_message().empty()) {
    const std::string& _s = this->_internal_message();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.GameActionResponse.message");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // .mmorpg.ErrorCode error_code = 4;
  if (this->_internal_error_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_error_code(), target);
  }

  // map<string, string> results = 5;
  if (!_internal_results().empty()) {
    using MapType = ::google::protobuf::Map<std::string, std::string>;
    using WireHelper = _pbi::MapEntryFuncs<std::string, std::string,
                                   _pbi::WireFormatLite::TYPE_STRING,
                                   _pbi::WireFormatLite::TYPE_STRING>;
    const auto& field = _internal_results();

    if (stream->IsSerializationDeterministic() && field.size() > 1) {
      for (const auto& entry : ::google::protobuf::internal::MapSorterPtr<MapType>(field)) {
        target = WireHelper::InternalSerialize(
            5, entry.first, entry.second, target, stream);
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.GameActionResponse.results");
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.GameActionResponse.results");
      }
    } else {
      for (const auto& entry : field) {
        target = WireHelper::InternalSerialize(
            5, entry.first, entry.second, target, stream);
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.GameActionResponse.results");
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.GameActionResponse.results");
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mmorpg.GameActionResponse)
  return target;
}

::size_t GameActionResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mmorpg.GameActionResponse)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> results = 5;
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_results_size());
  for (const auto& entry : _internal_results()) {
    total_size += _pbi::MapEntryFuncs<std::string, std::string,
                                   _pbi::WireFormatLite::TYPE_STRING,
                                   _pbi::WireFormatLite::TYPE_STRING>::ByteSizeLong(entry.first, entry.second);
  }
  // string action_id = 2;
  if (!this->_internal_action_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_action_id());
  }

  // string message = 3;
  if (!this->_internal_message().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_message());
  }

  // bool success = 1;
  if (this->_internal_success() != 0) {
    total_size += 2;
  }

  // .mmorpg.ErrorCode error_code = 4;
  if (this->_internal_error_code() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_error_code());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData GameActionResponse::_class_data_ = {
    GameActionResponse::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* GameActionResponse::GetClassData() const {
  return &_class_data_;
}

void GameActionResponse::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<GameActionResponse*>(&to_msg);
  auto& from = static_cast<const GameActionResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:mmorpg.GameActionResponse)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.results_.MergeFrom(from._impl_.results_);
  if (!from._internal_action_id().empty()) {
    _this->_internal_set_action_id(from._internal_action_id());
  }
  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  if (from._internal_success() != 0) {
    _this->_internal_set_success(from._internal_success());
  }
  if (from._internal_error_code() != 0) {
    _this->_internal_set_error_code(from._internal_error_code());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void GameActionResponse::CopyFrom(const GameActionResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mmorpg.GameActionResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool GameActionResponse::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* GameActionResponse::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void GameActionResponse::InternalSwap(GameActionResponse* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.results_.InternalSwap(&other->_impl_.results_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.action_id_, &other->_impl_.action_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.message_, &other->_impl_.message_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameActionResponse, _impl_.error_code_)
      + sizeof(GameActionResponse::_impl_.error_code_)
      - PROTOBUF_FIELD_OFFSET(GameActionResponse, _impl_.success_)>(
          reinterpret_cast<char*>(&_impl_.success_),
          reinterpret_cast<char*>(&other->_impl_.success_));
}

::google::protobuf::Metadata GameActionResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[3]);
}
// ===================================================================

class InventoryUpdate::_Internal {
 public:
};

InventoryUpdate::InventoryUpdate(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:mmorpg.InventoryUpdate)
}
inline PROTOBUF_NDEBUG_INLINE InventoryUpdate::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : slots_{visibility, arena, from.slots_},
        player_id_(arena, from.player_id_),
        _cached_size_{0} {}

InventoryUpdate::InventoryUpdate(
    ::google::protobuf::Arena* arena,
    const InventoryUpdate& from)
    : ::google::protobuf::Message(arena) {
  InventoryUpdate* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, total_slots_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, total_slots_),
           offsetof(Impl_, used_slots_) -
               offsetof(Impl_, total_slots_) +
               sizeof(Impl_::used_slots_));

  // @@protoc_insertion_point(copy_constructor:mmorpg.InventoryUpdate)
}
inline PROTOBUF_NDEBUG_INLINE InventoryUpdate::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : slots_{visibility, arena},
        player_id_(arena),
        _cached_size_{0} {}

inline void InventoryUpdate::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, total_slots_),
           0,
           offsetof(Impl_, used_slots_) -
               offsetof(Impl_, total_slots_) +
               sizeof(Impl_::used_slots_));
}
InventoryUpdate::~InventoryUpdate() {
  // @@protoc_insertion_point(destructor:mmorpg.InventoryUpdate)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void InventoryUpdate::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.player_id_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void InventoryUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:mmorpg.InventoryUpdate)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.slots_.Clear();
  _impl_.player_id_.ClearToEmpty();
  ::memset(&_impl_.total_slots_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.used_slots_) -
      reinterpret_cast<char*>(&_impl_.total_slots_)) + sizeof(_impl_.used_slots_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* InventoryUpdate::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 40, 2> InventoryUpdate::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_InventoryUpdate_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // int32 used_slots = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(InventoryUpdate, _impl_.used_slots_), 63>(),
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(InventoryUpdate, _impl_.used_slots_)}},
    // string player_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(InventoryUpdate, _impl_.player_id_)}},
    // repeated .mmorpg.InventorySlot slots = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(InventoryUpdate, _impl_.slots_)}},
    // int32 total_slots = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(InventoryUpdate, _impl_.total_slots_), 63>(),
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(InventoryUpdate, _impl_.total_slots_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string player_id = 1;
    {PROTOBUF_FIELD_OFFSET(InventoryUpdate, _impl_.player_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated .mmorpg.InventorySlot slots = 2;
    {PROTOBUF_FIELD_OFFSET(InventoryUpdate, _impl_.slots_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // int32 total_slots = 3;
    {PROTOBUF_FIELD_OFFSET(InventoryUpdate, _impl_.total_slots_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // int32 used_slots = 4;
    {PROTOBUF_FIELD_OFFSET(InventoryUpdate, _impl_.used_slots_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::mmorpg::InventorySlot>()},
  }}, {{
    "\26\11\0\0\0\0\0\0"
    "mmorpg.InventoryUpdate"
    "player_id"
  }},
};

::uint8_t* InventoryUpdate::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mmorpg.InventoryUpdate)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string player_id = 1;
  if (!this->_internal_player_id().empty()) {
    const std::string& _s = this->_internal_player_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.InventoryUpdate.player_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated .mmorpg.InventorySlot slots = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_slots_size()); i < n; i++) {
    const auto& repfield = this->_internal_slots().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int32 total_slots = 3;
  if (this->_internal_total_slots() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<3>(
            stream, this->_internal_total_slots(), target);
  }

  // int32 used_slots = 4;
  if (this->_internal_used_slots() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<4>(
            stream, this->_internal_used_slots(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mmorpg.InventoryUpdate)
  return target;
}

::size_t InventoryUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mmorpg.InventoryUpdate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mmorpg.InventorySlot slots = 2;
  total_size += 1UL * this->_internal_slots_size();
  for (const auto& msg : this->_internal_slots()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // string player_id = 1;
  if (!this->_internal_player_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_player_id());
  }

  // int32 total_slots = 3;
  if (this->_internal_total_slots() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_total_slots());
  }

  // int32 used_slots = 4;
  if (this->_internal_used_slots() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_used_slots());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData InventoryUpdate::_class_data_ = {
    InventoryUpdate::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* InventoryUpdate::GetClassData() const {
  return &_class_data_;
}

void InventoryUpdate::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<InventoryUpdate*>(&to_msg);
  auto& from = static_cast<const InventoryUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:mmorpg.InventoryUpdate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_slots()->MergeFrom(
      from._internal_slots());
  if (!from._internal_player_id().empty()) {
    _this->_internal_set_player_id(from._internal_player_id());
  }
  if (from._internal_total_slots() != 0) {
    _this->_internal_set_total_slots(from._internal_total_slots());
  }
  if (from._internal_used_slots() != 0) {
    _this->_internal_set_used_slots(from._internal_used_slots());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void InventoryUpdate::CopyFrom(const InventoryUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mmorpg.InventoryUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool InventoryUpdate::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* InventoryUpdate::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void InventoryUpdate::InternalSwap(InventoryUpdate* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.slots_.InternalSwap(&other->_impl_.slots_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.player_id_, &other->_impl_.player_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InventoryUpdate, _impl_.used_slots_)
      + sizeof(InventoryUpdate::_impl_.used_slots_)
      - PROTOBUF_FIELD_OFFSET(InventoryUpdate, _impl_.total_slots_)>(
          reinterpret_cast<char*>(&_impl_.total_slots_),
          reinterpret_cast<char*>(&other->_impl_.total_slots_));
}

::google::protobuf::Metadata InventoryUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[4]);
}
// ===================================================================

class InventorySlot::_Internal {
 public:
  using HasBits = decltype(std::declval<InventorySlot>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(InventorySlot, _impl_._has_bits_);
  static const ::mmorpg::Item& item(const InventorySlot* msg);
  static void set_has_item(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::mmorpg::Item& InventorySlot::_Internal::item(const InventorySlot* msg) {
  return *msg->_impl_.item_;
}
InventorySlot::InventorySlot(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:mmorpg.InventorySlot)
}
inline PROTOBUF_NDEBUG_INLINE InventorySlot::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

InventorySlot::InventorySlot(
    ::google::protobuf::Arena* arena,
    const InventorySlot& from)
    : ::google::protobuf::Message(arena) {
  InventorySlot* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.item_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::mmorpg::Item>(arena, *from._impl_.item_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, slot_index_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, slot_index_),
           offsetof(Impl_, quantity_) -
               offsetof(Impl_, slot_index_) +
               sizeof(Impl_::quantity_));

  // @@protoc_insertion_point(copy_constructor:mmorpg.InventorySlot)
}
inline PROTOBUF_NDEBUG_INLINE InventorySlot::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void InventorySlot::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, item_),
           0,
           offsetof(Impl_, quantity_) -
               offsetof(Impl_, item_) +
               sizeof(Impl_::quantity_));
}
InventorySlot::~InventorySlot() {
  // @@protoc_insertion_point(destructor:mmorpg.InventorySlot)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void InventorySlot::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.item_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void InventorySlot::Clear() {
// @@protoc_insertion_point(message_clear_start:mmorpg.InventorySlot)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.item_ != nullptr);
    _impl_.item_->Clear();
  }
  ::memset(&_impl_.slot_index_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.quantity_) -
      reinterpret_cast<char*>(&_impl_.slot_index_)) + sizeof(_impl_.quantity_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* InventorySlot::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 1, 0, 2> InventorySlot::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(InventorySlot, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_InventorySlot_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // int32 slot_index = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(InventorySlot, _impl_.slot_index_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(InventorySlot, _impl_.slot_index_)}},
    // .mmorpg.Item item = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(InventorySlot, _impl_.item_)}},
    // int32 quantity = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(InventorySlot, _impl_.quantity_), 63>(),
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(InventorySlot, _impl_.quantity_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int32 slot_index = 1;
    {PROTOBUF_FIELD_OFFSET(InventorySlot, _impl_.slot_index_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // .mmorpg.Item item = 2;
    {PROTOBUF_FIELD_OFFSET(InventorySlot, _impl_.item_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // int32 quantity = 3;
    {PROTOBUF_FIELD_OFFSET(InventorySlot, _impl_.quantity_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::mmorpg::Item>()},
  }}, {{
  }},
};

::uint8_t* InventorySlot::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mmorpg.InventorySlot)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // int32 slot_index = 1;
  if (this->_internal_slot_index() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<1>(
            stream, this->_internal_slot_index(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .mmorpg.Item item = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::item(this),
        _Internal::item(this).GetCachedSize(), target, stream);
  }

  // int32 quantity = 3;
  if (this->_internal_quantity() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<3>(
            stream, this->_internal_quantity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mmorpg.InventorySlot)
  return target;
}

::size_t InventorySlot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mmorpg.InventorySlot)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .mmorpg.Item item = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size +=
        1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.item_);
  }

  // int32 slot_index = 1;
  if (this->_internal_slot_index() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_slot_index());
  }

  // int32 quantity = 3;
  if (this->_internal_quantity() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_quantity());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData InventorySlot::_class_data_ = {
    InventorySlot::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* InventorySlot::GetClassData() const {
  return &_class_data_;
}

void InventorySlot::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<InventorySlot*>(&to_msg);
  auto& from = static_cast<const InventorySlot&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:mmorpg.InventorySlot)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_item()->::mmorpg::Item::MergeFrom(
        from._internal_item());
  }
  if (from._internal_slot_index() != 0) {
    _this->_internal_set_slot_index(from._internal_slot_index());
  }
  if (from._internal_quantity() != 0) {
    _this->_internal_set_quantity(from._internal_quantity());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void InventorySlot::CopyFrom(const InventorySlot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mmorpg.InventorySlot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool InventorySlot::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* InventorySlot::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void InventorySlot::InternalSwap(InventorySlot* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InventorySlot, _impl_.quantity_)
      + sizeof(InventorySlot::_impl_.quantity_)
      - PROTOBUF_FIELD_OFFSET(InventorySlot, _impl_.item_)>(
          reinterpret_cast<char*>(&_impl_.item_),
          reinterpret_cast<char*>(&other->_impl_.item_));
}

::google::protobuf::Metadata InventorySlot::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[5]);
}
// ===================================================================

Item_StatsEntry_DoNotUse::Item_StatsEntry_DoNotUse() {}
Item_StatsEntry_DoNotUse::Item_StatsEntry_DoNotUse(::google::protobuf::Arena* arena)
    : SuperType(arena) {}
::google::protobuf::Metadata Item_StatsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[6]);
}
// ===================================================================

class Item::_Internal {
 public:
};

Item::Item(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:mmorpg.Item)
}
inline PROTOBUF_NDEBUG_INLINE Item::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : stats_{visibility, arena, from.stats_},
        effects_{visibility, arena, from.effects_},
        item_id_(arena, from.item_id_),
        item_type_(arena, from.item_type_),
        name_(arena, from.name_),
        description_(arena, from.description_),
        icon_id_(arena, from.icon_id_),
        equipment_slot_(arena, from.equipment_slot_),
        _cached_size_{0} {}

Item::Item(
    ::google::protobuf::Arena* arena,
    const Item& from)
    : ::google::protobuf::Message(arena) {
  Item* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, rarity_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, rarity_),
           offsetof(Impl_, max_durability_) -
               offsetof(Impl_, rarity_) +
               sizeof(Impl_::max_durability_));

  // @@protoc_insertion_point(copy_constructor:mmorpg.Item)
}
inline PROTOBUF_NDEBUG_INLINE Item::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : stats_{visibility, arena},
        effects_{visibility, arena},
        item_id_(arena),
        item_type_(arena),
        name_(arena),
        description_(arena),
        icon_id_(arena),
        equipment_slot_(arena),
        _cached_size_{0} {}

inline void Item::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, rarity_),
           0,
           offsetof(Impl_, max_durability_) -
               offsetof(Impl_, rarity_) +
               sizeof(Impl_::max_durability_));
}
Item::~Item() {
  // @@protoc_insertion_point(destructor:mmorpg.Item)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Item::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.item_id_.Destroy();
  _impl_.item_type_.Destroy();
  _impl_.name_.Destroy();
  _impl_.description_.Destroy();
  _impl_.icon_id_.Destroy();
  _impl_.equipment_slot_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void Item::Clear() {
// @@protoc_insertion_point(message_clear_start:mmorpg.Item)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stats_.Clear();
  _impl_.effects_.Clear();
  _impl_.item_id_.ClearToEmpty();
  _impl_.item_type_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  _impl_.icon_id_.ClearToEmpty();
  _impl_.equipment_slot_.ClearToEmpty();
  ::memset(&_impl_.rarity_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.max_durability_) -
      reinterpret_cast<char*>(&_impl_.rarity_)) + sizeof(_impl_.max_durability_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Item::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 19, 2, 93, 2> Item::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    19, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294443008,  // skipmap
    offsetof(decltype(_table_), field_entries),
    19,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_Item_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string item_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(Item, _impl_.item_id_)}},
    // string item_type = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(Item, _impl_.item_type_)}},
    // string name = 3;
    {::_pbi::TcParser::FastUS1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(Item, _impl_.name_)}},
    // string description = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(Item, _impl_.description_)}},
    // string icon_id = 5;
    {::_pbi::TcParser::FastUS1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(Item, _impl_.icon_id_)}},
    // .mmorpg.ItemRarity rarity = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Item, _impl_.rarity_), 63>(),
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(Item, _impl_.rarity_)}},
    // int32 max_stack = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Item, _impl_.max_stack_), 63>(),
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(Item, _impl_.max_stack_)}},
    // bool is_unique = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Item, _impl_.is_unique_), 63>(),
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(Item, _impl_.is_unique_)}},
    // bool is_quest_item = 9;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Item, _impl_.is_quest_item_), 63>(),
     {72, 63, 0, PROTOBUF_FIELD_OFFSET(Item, _impl_.is_quest_item_)}},
    // bool is_bound = 10;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Item, _impl_.is_bound_), 63>(),
     {80, 63, 0, PROTOBUF_FIELD_OFFSET(Item, _impl_.is_bound_)}},
    // int32 required_level = 11;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Item, _impl_.required_level_), 63>(),
     {88, 63, 0, PROTOBUF_FIELD_OFFSET(Item, _impl_.required_level_)}},
    // .mmorpg.CharacterClass required_class = 12;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Item, _impl_.required_class_), 63>(),
     {96, 63, 0, PROTOBUF_FIELD_OFFSET(Item, _impl_.required_class_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .mmorpg.ItemEffect effects = 14;
    {::_pbi::TcParser::FastMtR1,
     {114, 63, 1, PROTOBUF_FIELD_OFFSET(Item, _impl_.effects_)}},
    // int64 sell_price = 15;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(Item, _impl_.sell_price_), 63>(),
     {120, 63, 0, PROTOBUF_FIELD_OFFSET(Item, _impl_.sell_price_)}},
    // int64 buy_price = 16;
    {::_pbi::TcParser::FastV64S2,
     {384, 63, 0, PROTOBUF_FIELD_OFFSET(Item, _impl_.buy_price_)}},
    // string equipment_slot = 17;
    {::_pbi::TcParser::FastUS2,
     {394, 63, 0, PROTOBUF_FIELD_OFFSET(Item, _impl_.equipment_slot_)}},
    // int32 durability = 18;
    {::_pbi::TcParser::FastV32S2,
     {400, 63, 0, PROTOBUF_FIELD_OFFSET(Item, _impl_.durability_)}},
    // int32 max_durability = 19;
    {::_pbi::TcParser::FastV32S2,
     {408, 63, 0, PROTOBUF_FIELD_OFFSET(Item, _impl_.max_durability_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string item_id = 1;
    {PROTOBUF_FIELD_OFFSET(Item, _impl_.item_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string item_type = 2;
    {PROTOBUF_FIELD_OFFSET(Item, _impl_.item_type_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string name = 3;
    {PROTOBUF_FIELD_OFFSET(Item, _impl_.name_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string description = 4;
    {PROTOBUF_FIELD_OFFSET(Item, _impl_.description_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string icon_id = 5;
    {PROTOBUF_FIELD_OFFSET(Item, _impl_.icon_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .mmorpg.ItemRarity rarity = 6;
    {PROTOBUF_FIELD_OFFSET(Item, _impl_.rarity_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // int32 max_stack = 7;
    {PROTOBUF_FIELD_OFFSET(Item, _impl_.max_stack_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // bool is_unique = 8;
    {PROTOBUF_FIELD_OFFSET(Item, _impl_.is_unique_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool is_quest_item = 9;
    {PROTOBUF_FIELD_OFFSET(Item, _impl_.is_quest_item_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool is_bound = 10;
    {PROTOBUF_FIELD_OFFSET(Item, _impl_.is_bound_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // int32 required_level = 11;
    {PROTOBUF_FIELD_OFFSET(Item, _impl_.required_level_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // .mmorpg.CharacterClass required_class = 12;
    {PROTOBUF_FIELD_OFFSET(Item, _impl_.required_class_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // map<string, int32> stats = 13;
    {PROTOBUF_FIELD_OFFSET(Item, _impl_.stats_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
    // repeated .mmorpg.ItemEffect effects = 14;
    {PROTOBUF_FIELD_OFFSET(Item, _impl_.effects_), 0, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // int64 sell_price = 15;
    {PROTOBUF_FIELD_OFFSET(Item, _impl_.sell_price_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt64)},
    // int64 buy_price = 16;
    {PROTOBUF_FIELD_OFFSET(Item, _impl_.buy_price_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt64)},
    // string equipment_slot = 17;
    {PROTOBUF_FIELD_OFFSET(Item, _impl_.equipment_slot_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // int32 durability = 18;
    {PROTOBUF_FIELD_OFFSET(Item, _impl_.durability_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // int32 max_durability = 19;
    {PROTOBUF_FIELD_OFFSET(Item, _impl_.max_durability_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
  }}, {{
    {::_pbi::TcParser::GetMapAuxInfo<
        decltype(Item()._impl_.stats_)>(
        1, 0, 0, 9,
        5)},
    {::_pbi::TcParser::GetTable<::mmorpg::ItemEffect>()},
  }}, {{
    "\13\7\11\4\13\7\0\0\0\0\0\0\0\5\0\0\0\16\0\0\0\0\0\0"
    "mmorpg.Item"
    "item_id"
    "item_type"
    "name"
    "description"
    "icon_id"
    "stats"
    "equipment_slot"
  }},
};

::uint8_t* Item::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mmorpg.Item)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string item_id = 1;
  if (!this->_internal_item_id().empty()) {
    const std::string& _s = this->_internal_item_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.Item.item_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string item_type = 2;
  if (!this->_internal_item_type().empty()) {
    const std::string& _s = this->_internal_item_type();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.Item.item_type");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string name = 3;
  if (!this->_internal_name().empty()) {
    const std::string& _s = this->_internal_name();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.Item.name");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string description = 4;
  if (!this->_internal_description().empty()) {
    const std::string& _s = this->_internal_description();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.Item.description");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // string icon_id = 5;
  if (!this->_internal_icon_id().empty()) {
    const std::string& _s = this->_internal_icon_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.Item.icon_id");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // .mmorpg.ItemRarity rarity = 6;
  if (this->_internal_rarity() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        6, this->_internal_rarity(), target);
  }

  // int32 max_stack = 7;
  if (this->_internal_max_stack() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<7>(
            stream, this->_internal_max_stack(), target);
  }

  // bool is_unique = 8;
  if (this->_internal_is_unique() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this->_internal_is_unique(), target);
  }

  // bool is_quest_item = 9;
  if (this->_internal_is_quest_item() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        9, this->_internal_is_quest_item(), target);
  }

  // bool is_bound = 10;
  if (this->_internal_is_bound() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        10, this->_internal_is_bound(), target);
  }

  // int32 required_level = 11;
  if (this->_internal_required_level() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<11>(
            stream, this->_internal_required_level(), target);
  }

  // .mmorpg.CharacterClass required_class = 12;
  if (this->_internal_required_class() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        12, this->_internal_required_class(), target);
  }

  // map<string, int32> stats = 13;
  if (!_internal_stats().empty()) {
    using MapType = ::google::protobuf::Map<std::string, ::int32_t>;
    using WireHelper = _pbi::MapEntryFuncs<std::string, ::int32_t,
                                   _pbi::WireFormatLite::TYPE_STRING,
                                   _pbi::WireFormatLite::TYPE_INT32>;
    const auto& field = _internal_stats();

    if (stream->IsSerializationDeterministic() && field.size() > 1) {
      for (const auto& entry : ::google::protobuf::internal::MapSorterPtr<MapType>(field)) {
        target = WireHelper::InternalSerialize(
            13, entry.first, entry.second, target, stream);
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.Item.stats");
      }
    } else {
      for (const auto& entry : field) {
        target = WireHelper::InternalSerialize(
            13, entry.first, entry.second, target, stream);
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.Item.stats");
      }
    }
  }

  // repeated .mmorpg.ItemEffect effects = 14;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_effects_size()); i < n; i++) {
    const auto& repfield = this->_internal_effects().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(14, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int64 sell_price = 15;
  if (this->_internal_sell_price() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<15>(
            stream, this->_internal_sell_price(), target);
  }

  // int64 buy_price = 16;
  if (this->_internal_buy_price() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        16, this->_internal_buy_price(), target);
  }

  // string equipment_slot = 17;
  if (!this->_internal_equipment_slot().empty()) {
    const std::string& _s = this->_internal_equipment_slot();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.Item.equipment_slot");
    target = stream->WriteStringMaybeAliased(17, _s, target);
  }

  // int32 durability = 18;
  if (this->_internal_durability() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        18, this->_internal_durability(), target);
  }

  // int32 max_durability = 19;
  if (this->_internal_max_durability() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        19, this->_internal_max_durability(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mmorpg.Item)
  return target;
}

::size_t Item::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mmorpg.Item)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, int32> stats = 13;
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_stats_size());
  for (const auto& entry : _internal_stats()) {
    total_size += _pbi::MapEntryFuncs<std::string, ::int32_t,
                                   _pbi::WireFormatLite::TYPE_STRING,
                                   _pbi::WireFormatLite::TYPE_INT32>::ByteSizeLong(entry.first, entry.second);
  }
  // repeated .mmorpg.ItemEffect effects = 14;
  total_size += 1UL * this->_internal_effects_size();
  for (const auto& msg : this->_internal_effects()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // string item_id = 1;
  if (!this->_internal_item_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_item_id());
  }

  // string item_type = 2;
  if (!this->_internal_item_type().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_item_type());
  }

  // string name = 3;
  if (!this->_internal_name().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_name());
  }

  // string description = 4;
  if (!this->_internal_description().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_description());
  }

  // string icon_id = 5;
  if (!this->_internal_icon_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_icon_id());
  }

  // string equipment_slot = 17;
  if (!this->_internal_equipment_slot().empty()) {
    total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_equipment_slot());
  }

  // .mmorpg.ItemRarity rarity = 6;
  if (this->_internal_rarity() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_rarity());
  }

  // int32 max_stack = 7;
  if (this->_internal_max_stack() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_max_stack());
  }

  // bool is_unique = 8;
  if (this->_internal_is_unique() != 0) {
    total_size += 2;
  }

  // bool is_quest_item = 9;
  if (this->_internal_is_quest_item() != 0) {
    total_size += 2;
  }

  // bool is_bound = 10;
  if (this->_internal_is_bound() != 0) {
    total_size += 2;
  }

  // int32 required_level = 11;
  if (this->_internal_required_level() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_required_level());
  }

  // int64 sell_price = 15;
  if (this->_internal_sell_price() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_sell_price());
  }

  // .mmorpg.CharacterClass required_class = 12;
  if (this->_internal_required_class() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_required_class());
  }

  // int32 durability = 18;
  if (this->_internal_durability() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_durability());
  }

  // int64 buy_price = 16;
  if (this->_internal_buy_price() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int64Size(
                                    this->_internal_buy_price());
  }

  // int32 max_durability = 19;
  if (this->_internal_max_durability() != 0) {
    total_size += 2 + ::_pbi::WireFormatLite::Int32Size(
                                    this->_internal_max_durability());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Item::_class_data_ = {
    Item::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* Item::GetClassData() const {
  return &_class_data_;
}

void Item::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Item*>(&to_msg);
  auto& from = static_cast<const Item&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:mmorpg.Item)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.stats_.MergeFrom(from._impl_.stats_);
  _this->_internal_mutable_effects()->MergeFrom(
      from._internal_effects());
  if (!from._internal_item_id().empty()) {
    _this->_internal_set_item_id(from._internal_item_id());
  }
  if (!from._internal_item_type().empty()) {
    _this->_internal_set_item_type(from._internal_item_type());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_icon_id().empty()) {
    _this->_internal_set_icon_id(from._internal_icon_id());
  }
  if (!from._internal_equipment_slot().empty()) {
    _this->_internal_set_equipment_slot(from._internal_equipment_slot());
  }
  if (from._internal_rarity() != 0) {
    _this->_internal_set_rarity(from._internal_rarity());
  }
  if (from._internal_max_stack() != 0) {
    _this->_internal_set_max_stack(from._internal_max_stack());
  }
  if (from._internal_is_unique() != 0) {
    _this->_internal_set_is_unique(from._internal_is_unique());
  }
  if (from._internal_is_quest_item() != 0) {
    _this->_internal_set_is_quest_item(from._internal_is_quest_item());
  }
  if (from._internal_is_bound() != 0) {
    _this->_internal_set_is_bound(from._internal_is_bound());
  }
  if (from._internal_required_level() != 0) {
    _this->_internal_set_required_level(from._internal_required_level());
  }
  if (from._internal_sell_price() != 0) {
    _this->_internal_set_sell_price(from._internal_sell_price());
  }
  if (from._internal_required_class() != 0) {
    _this->_internal_set_required_class(from._internal_required_class());
  }
  if (from._internal_durability() != 0) {
    _this->_internal_set_durability(from._internal_durability());
  }
  if (from._internal_buy_price() != 0) {
    _this->_internal_set_buy_price(from._internal_buy_price());
  }
  if (from._internal_max_durability() != 0) {
    _this->_internal_set_max_durability(from._internal_max_durability());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Item::CopyFrom(const Item& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mmorpg.Item)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Item::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* Item::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void Item::InternalSwap(Item* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.stats_.InternalSwap(&other->_impl_.stats_);
  _impl_.effects_.InternalSwap(&other->_impl_.effects_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.item_id_, &other->_impl_.item_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.item_type_, &other->_impl_.item_type_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.description_, &other->_impl_.description_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.icon_id_, &other->_impl_.icon_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.equipment_slot_, &other->_impl_.equipment_slot_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Item, _impl_.max_durability_)
      + sizeof(Item::_impl_.max_durability_)
      - PROTOBUF_FIELD_OFFSET(Item, _impl_.rarity_)>(
          reinterpret_cast<char*>(&_impl_.rarity_),
          reinterpret_cast<char*>(&other->_impl_.rarity_));
}

::google::protobuf::Metadata Item::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[7]);
}
// ===================================================================

class ItemEffect::_Internal {
 public:
};

ItemEffect::ItemEffect(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:mmorpg.ItemEffect)
}
inline PROTOBUF_NDEBUG_INLINE ItemEffect::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : effect_type_(arena, from.effect_type_),
        _cached_size_{0} {}

ItemEffect::ItemEffect(
    ::google::protobuf::Arena* arena,
    const ItemEffect& from)
    : ::google::protobuf::Message(arena) {
  ItemEffect* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, value_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, value_),
           offsetof(Impl_, chance_) -
               offsetof(Impl_, value_) +
               sizeof(Impl_::chance_));

  // @@protoc_insertion_point(copy_constructor:mmorpg.ItemEffect)
}
inline PROTOBUF_NDEBUG_INLINE ItemEffect::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : effect_type_(arena),
        _cached_size_{0} {}

inline void ItemEffect::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, value_),
           0,
           offsetof(Impl_, chance_) -
               offsetof(Impl_, value_) +
               sizeof(Impl_::chance_));
}
ItemEffect::~ItemEffect() {
  // @@protoc_insertion_point(destructor:mmorpg.ItemEffect)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void ItemEffect::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.effect_type_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void ItemEffect::Clear() {
// @@protoc_insertion_point(message_clear_start:mmorpg.ItemEffect)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.effect_type_.ClearToEmpty();
  ::memset(&_impl_.value_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.chance_) -
      reinterpret_cast<char*>(&_impl_.value_)) + sizeof(_impl_.chance_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* ItemEffect::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 37, 2> ItemEffect::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_ItemEffect_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // float chance = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 63, 0, PROTOBUF_FIELD_OFFSET(ItemEffect, _impl_.chance_)}},
    // string effect_type = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(ItemEffect, _impl_.effect_type_)}},
    // int32 value = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(ItemEffect, _impl_.value_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(ItemEffect, _impl_.value_)}},
    // float duration = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(ItemEffect, _impl_.duration_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string effect_type = 1;
    {PROTOBUF_FIELD_OFFSET(ItemEffect, _impl_.effect_type_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // int32 value = 2;
    {PROTOBUF_FIELD_OFFSET(ItemEffect, _impl_.value_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // float duration = 3;
    {PROTOBUF_FIELD_OFFSET(ItemEffect, _impl_.duration_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float chance = 4;
    {PROTOBUF_FIELD_OFFSET(ItemEffect, _impl_.chance_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
    "\21\13\0\0\0\0\0\0"
    "mmorpg.ItemEffect"
    "effect_type"
  }},
};

::uint8_t* ItemEffect::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mmorpg.ItemEffect)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string effect_type = 1;
  if (!this->_internal_effect_type().empty()) {
    const std::string& _s = this->_internal_effect_type();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.ItemEffect.effect_type");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // int32 value = 2;
  if (this->_internal_value() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<2>(
            stream, this->_internal_value(), target);
  }

  // float duration = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_duration = this->_internal_duration();
  ::uint32_t raw_duration;
  memcpy(&raw_duration, &tmp_duration, sizeof(tmp_duration));
  if (raw_duration != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_duration(), target);
  }

  // float chance = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_chance = this->_internal_chance();
  ::uint32_t raw_chance;
  memcpy(&raw_chance, &tmp_chance, sizeof(tmp_chance));
  if (raw_chance != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_chance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mmorpg.ItemEffect)
  return target;
}

::size_t ItemEffect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mmorpg.ItemEffect)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string effect_type = 1;
  if (!this->_internal_effect_type().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_effect_type());
  }

  // int32 value = 2;
  if (this->_internal_value() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_value());
  }

  // float duration = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_duration = this->_internal_duration();
  ::uint32_t raw_duration;
  memcpy(&raw_duration, &tmp_duration, sizeof(tmp_duration));
  if (raw_duration != 0) {
    total_size += 5;
  }

  // float chance = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_chance = this->_internal_chance();
  ::uint32_t raw_chance;
  memcpy(&raw_chance, &tmp_chance, sizeof(tmp_chance));
  if (raw_chance != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData ItemEffect::_class_data_ = {
    ItemEffect::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* ItemEffect::GetClassData() const {
  return &_class_data_;
}

void ItemEffect::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<ItemEffect*>(&to_msg);
  auto& from = static_cast<const ItemEffect&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:mmorpg.ItemEffect)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_effect_type().empty()) {
    _this->_internal_set_effect_type(from._internal_effect_type());
  }
  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_duration = from._internal_duration();
  ::uint32_t raw_duration;
  memcpy(&raw_duration, &tmp_duration, sizeof(tmp_duration));
  if (raw_duration != 0) {
    _this->_internal_set_duration(from._internal_duration());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_chance = from._internal_chance();
  ::uint32_t raw_chance;
  memcpy(&raw_chance, &tmp_chance, sizeof(tmp_chance));
  if (raw_chance != 0) {
    _this->_internal_set_chance(from._internal_chance());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ItemEffect::CopyFrom(const ItemEffect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mmorpg.ItemEffect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool ItemEffect::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* ItemEffect::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void ItemEffect::InternalSwap(ItemEffect* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.effect_type_, &other->_impl_.effect_type_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ItemEffect, _impl_.chance_)
      + sizeof(ItemEffect::_impl_.chance_)
      - PROTOBUF_FIELD_OFFSET(ItemEffect, _impl_.value_)>(
          reinterpret_cast<char*>(&_impl_.value_),
          reinterpret_cast<char*>(&other->_impl_.value_));
}

::google::protobuf::Metadata ItemEffect::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[8]);
}
// ===================================================================

class StatsUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<StatsUpdate>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(StatsUpdate, _impl_._has_bits_);
  static const ::mmorpg::CharacterStats& stats(const StatsUpdate* msg);
  static void set_has_stats(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mmorpg::CharacterAttributes& attributes(const StatsUpdate* msg);
  static void set_has_attributes(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::mmorpg::CharacterStats& StatsUpdate::_Internal::stats(const StatsUpdate* msg) {
  return *msg->_impl_.stats_;
}
const ::mmorpg::CharacterAttributes& StatsUpdate::_Internal::attributes(const StatsUpdate* msg) {
  return *msg->_impl_.attributes_;
}
void StatsUpdate::clear_stats() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.stats_ != nullptr) _impl_.stats_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void StatsUpdate::clear_attributes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.attributes_ != nullptr) _impl_.attributes_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
StatsUpdate::StatsUpdate(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:mmorpg.StatsUpdate)
}
inline PROTOBUF_NDEBUG_INLINE StatsUpdate::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        player_id_(arena, from.player_id_) {}

StatsUpdate::StatsUpdate(
    ::google::protobuf::Arena* arena,
    const StatsUpdate& from)
    : ::google::protobuf::Message(arena) {
  StatsUpdate* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.stats_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::mmorpg::CharacterStats>(arena, *from._impl_.stats_)
                : nullptr;
  _impl_.attributes_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::mmorpg::CharacterAttributes>(arena, *from._impl_.attributes_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, experience_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, experience_),
           offsetof(Impl_, level_) -
               offsetof(Impl_, experience_) +
               sizeof(Impl_::level_));

  // @@protoc_insertion_point(copy_constructor:mmorpg.StatsUpdate)
}
inline PROTOBUF_NDEBUG_INLINE StatsUpdate::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        player_id_(arena) {}

inline void StatsUpdate::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, stats_),
           0,
           offsetof(Impl_, level_) -
               offsetof(Impl_, stats_) +
               sizeof(Impl_::level_));
}
StatsUpdate::~StatsUpdate() {
  // @@protoc_insertion_point(destructor:mmorpg.StatsUpdate)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void StatsUpdate::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.player_id_.Destroy();
  delete _impl_.stats_;
  delete _impl_.attributes_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void StatsUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:mmorpg.StatsUpdate)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.player_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.stats_ != nullptr);
      _impl_.stats_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.attributes_ != nullptr);
      _impl_.attributes_->Clear();
    }
  }
  ::memset(&_impl_.experience_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.level_) -
      reinterpret_cast<char*>(&_impl_.experience_)) + sizeof(_impl_.level_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* StatsUpdate::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 2, 36, 2> StatsUpdate::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(StatsUpdate, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_StatsUpdate_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string player_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(StatsUpdate, _impl_.player_id_)}},
    // .mmorpg.CharacterStats stats = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(StatsUpdate, _impl_.stats_)}},
    // .mmorpg.CharacterAttributes attributes = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 1, 1, PROTOBUF_FIELD_OFFSET(StatsUpdate, _impl_.attributes_)}},
    // int32 level = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(StatsUpdate, _impl_.level_), 63>(),
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(StatsUpdate, _impl_.level_)}},
    // int64 experience = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(StatsUpdate, _impl_.experience_), 63>(),
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(StatsUpdate, _impl_.experience_)}},
    // int64 experience_to_next_level = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(StatsUpdate, _impl_.experience_to_next_level_), 63>(),
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(StatsUpdate, _impl_.experience_to_next_level_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string player_id = 1;
    {PROTOBUF_FIELD_OFFSET(StatsUpdate, _impl_.player_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .mmorpg.CharacterStats stats = 2;
    {PROTOBUF_FIELD_OFFSET(StatsUpdate, _impl_.stats_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .mmorpg.CharacterAttributes attributes = 3;
    {PROTOBUF_FIELD_OFFSET(StatsUpdate, _impl_.attributes_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // int32 level = 4;
    {PROTOBUF_FIELD_OFFSET(StatsUpdate, _impl_.level_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // int64 experience = 5;
    {PROTOBUF_FIELD_OFFSET(StatsUpdate, _impl_.experience_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt64)},
    // int64 experience_to_next_level = 6;
    {PROTOBUF_FIELD_OFFSET(StatsUpdate, _impl_.experience_to_next_level_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt64)},
  }}, {{
    {::_pbi::TcParser::GetTable<::mmorpg::CharacterStats>()},
    {::_pbi::TcParser::GetTable<::mmorpg::CharacterAttributes>()},
  }}, {{
    "\22\11\0\0\0\0\0\0"
    "mmorpg.StatsUpdate"
    "player_id"
  }},
};

::uint8_t* StatsUpdate::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mmorpg.StatsUpdate)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string player_id = 1;
  if (!this->_internal_player_id().empty()) {
    const std::string& _s = this->_internal_player_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.StatsUpdate.player_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .mmorpg.CharacterStats stats = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        2, _Internal::stats(this),
        _Internal::stats(this).GetCachedSize(), target, stream);
  }

  // .mmorpg.CharacterAttributes attributes = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::attributes(this),
        _Internal::attributes(this).GetCachedSize(), target, stream);
  }

  // int32 level = 4;
  if (this->_internal_level() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<4>(
            stream, this->_internal_level(), target);
  }

  // int64 experience = 5;
  if (this->_internal_experience() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<5>(
            stream, this->_internal_experience(), target);
  }

  // int64 experience_to_next_level = 6;
  if (this->_internal_experience_to_next_level() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<6>(
            stream, this->_internal_experience_to_next_level(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mmorpg.StatsUpdate)
  return target;
}

::size_t StatsUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mmorpg.StatsUpdate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string player_id = 1;
  if (!this->_internal_player_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_player_id());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .mmorpg.CharacterStats stats = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.stats_);
    }

    // .mmorpg.CharacterAttributes attributes = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.attributes_);
    }

  }
  // int64 experience = 5;
  if (this->_internal_experience() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_experience());
  }

  // int64 experience_to_next_level = 6;
  if (this->_internal_experience_to_next_level() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_experience_to_next_level());
  }

  // int32 level = 4;
  if (this->_internal_level() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_level());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData StatsUpdate::_class_data_ = {
    StatsUpdate::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* StatsUpdate::GetClassData() const {
  return &_class_data_;
}

void StatsUpdate::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<StatsUpdate*>(&to_msg);
  auto& from = static_cast<const StatsUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:mmorpg.StatsUpdate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_player_id().empty()) {
    _this->_internal_set_player_id(from._internal_player_id());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_stats()->::mmorpg::CharacterStats::MergeFrom(
          from._internal_stats());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_attributes()->::mmorpg::CharacterAttributes::MergeFrom(
          from._internal_attributes());
    }
  }
  if (from._internal_experience() != 0) {
    _this->_internal_set_experience(from._internal_experience());
  }
  if (from._internal_experience_to_next_level() != 0) {
    _this->_internal_set_experience_to_next_level(from._internal_experience_to_next_level());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void StatsUpdate::CopyFrom(const StatsUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mmorpg.StatsUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool StatsUpdate::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* StatsUpdate::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void StatsUpdate::InternalSwap(StatsUpdate* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.player_id_, &other->_impl_.player_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StatsUpdate, _impl_.level_)
      + sizeof(StatsUpdate::_impl_.level_)
      - PROTOBUF_FIELD_OFFSET(StatsUpdate, _impl_.stats_)>(
          reinterpret_cast<char*>(&_impl_.stats_),
          reinterpret_cast<char*>(&other->_impl_.stats_));
}

::google::protobuf::Metadata StatsUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[9]);
}
// ===================================================================

class QuestUpdate::_Internal {
 public:
};

QuestUpdate::QuestUpdate(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:mmorpg.QuestUpdate)
}
inline PROTOBUF_NDEBUG_INLINE QuestUpdate::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : active_quests_{visibility, arena, from.active_quests_},
        completed_quests_{visibility, arena, from.completed_quests_},
        available_quest_ids_{visibility, arena, from.available_quest_ids_},
        player_id_(arena, from.player_id_),
        _cached_size_{0} {}

QuestUpdate::QuestUpdate(
    ::google::protobuf::Arena* arena,
    const QuestUpdate& from)
    : ::google::protobuf::Message(arena) {
  QuestUpdate* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);

  // @@protoc_insertion_point(copy_constructor:mmorpg.QuestUpdate)
}
inline PROTOBUF_NDEBUG_INLINE QuestUpdate::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : active_quests_{visibility, arena},
        completed_quests_{visibility, arena},
        available_quest_ids_{visibility, arena},
        player_id_(arena),
        _cached_size_{0} {}

inline void QuestUpdate::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
QuestUpdate::~QuestUpdate() {
  // @@protoc_insertion_point(destructor:mmorpg.QuestUpdate)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void QuestUpdate::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.player_id_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void QuestUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:mmorpg.QuestUpdate)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.active_quests_.Clear();
  _impl_.completed_quests_.Clear();
  _impl_.available_quest_ids_.Clear();
  _impl_.player_id_.ClearToEmpty();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* QuestUpdate::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 2, 55, 2> QuestUpdate::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_QuestUpdate_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // repeated string available_quest_ids = 4;
    {::_pbi::TcParser::FastUR1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(QuestUpdate, _impl_.available_quest_ids_)}},
    // string player_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(QuestUpdate, _impl_.player_id_)}},
    // repeated .mmorpg.QuestInfo active_quests = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(QuestUpdate, _impl_.active_quests_)}},
    // repeated .mmorpg.QuestInfo completed_quests = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 1, PROTOBUF_FIELD_OFFSET(QuestUpdate, _impl_.completed_quests_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string player_id = 1;
    {PROTOBUF_FIELD_OFFSET(QuestUpdate, _impl_.player_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated .mmorpg.QuestInfo active_quests = 2;
    {PROTOBUF_FIELD_OFFSET(QuestUpdate, _impl_.active_quests_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .mmorpg.QuestInfo completed_quests = 3;
    {PROTOBUF_FIELD_OFFSET(QuestUpdate, _impl_.completed_quests_), 0, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated string available_quest_ids = 4;
    {PROTOBUF_FIELD_OFFSET(QuestUpdate, _impl_.available_quest_ids_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
  }}, {{
    {::_pbi::TcParser::GetTable<::mmorpg::QuestInfo>()},
    {::_pbi::TcParser::GetTable<::mmorpg::QuestInfo>()},
  }}, {{
    "\22\11\0\0\23\0\0\0"
    "mmorpg.QuestUpdate"
    "player_id"
    "available_quest_ids"
  }},
};

::uint8_t* QuestUpdate::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mmorpg.QuestUpdate)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string player_id = 1;
  if (!this->_internal_player_id().empty()) {
    const std::string& _s = this->_internal_player_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.QuestUpdate.player_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated .mmorpg.QuestInfo active_quests = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_active_quests_size()); i < n; i++) {
    const auto& repfield = this->_internal_active_quests().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .mmorpg.QuestInfo completed_quests = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_completed_quests_size()); i < n; i++) {
    const auto& repfield = this->_internal_completed_quests().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string available_quest_ids = 4;
  for (int i = 0, n = this->_internal_available_quest_ids_size(); i < n; ++i) {
    const auto& s = this->_internal_available_quest_ids().Get(i);
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.QuestUpdate.available_quest_ids");
    target = stream->WriteString(4, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mmorpg.QuestUpdate)
  return target;
}

::size_t QuestUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mmorpg.QuestUpdate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mmorpg.QuestInfo active_quests = 2;
  total_size += 1UL * this->_internal_active_quests_size();
  for (const auto& msg : this->_internal_active_quests()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .mmorpg.QuestInfo completed_quests = 3;
  total_size += 1UL * this->_internal_completed_quests_size();
  for (const auto& msg : this->_internal_completed_quests()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated string available_quest_ids = 4;
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_available_quest_ids().size());
  for (int i = 0, n = _internal_available_quest_ids().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_available_quest_ids().Get(i));
  }
  // string player_id = 1;
  if (!this->_internal_player_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_player_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData QuestUpdate::_class_data_ = {
    QuestUpdate::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* QuestUpdate::GetClassData() const {
  return &_class_data_;
}

void QuestUpdate::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<QuestUpdate*>(&to_msg);
  auto& from = static_cast<const QuestUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:mmorpg.QuestUpdate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_active_quests()->MergeFrom(
      from._internal_active_quests());
  _this->_internal_mutable_completed_quests()->MergeFrom(
      from._internal_completed_quests());
  _this->_internal_mutable_available_quest_ids()->MergeFrom(from._internal_available_quest_ids());
  if (!from._internal_player_id().empty()) {
    _this->_internal_set_player_id(from._internal_player_id());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void QuestUpdate::CopyFrom(const QuestUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mmorpg.QuestUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool QuestUpdate::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* QuestUpdate::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void QuestUpdate::InternalSwap(QuestUpdate* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.active_quests_.InternalSwap(&other->_impl_.active_quests_);
  _impl_.completed_quests_.InternalSwap(&other->_impl_.completed_quests_);
  _impl_.available_quest_ids_.InternalSwap(&other->_impl_.available_quest_ids_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.player_id_, &other->_impl_.player_id_, arena);
}

::google::protobuf::Metadata QuestUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[10]);
}
// ===================================================================

class QuestInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<QuestInfo>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_._has_bits_);
  static const ::google::protobuf::Timestamp& accepted_at(const QuestInfo* msg);
  static void set_has_accepted_at(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::google::protobuf::Timestamp& completed_at(const QuestInfo* msg);
  static void set_has_completed_at(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::google::protobuf::Timestamp& QuestInfo::_Internal::accepted_at(const QuestInfo* msg) {
  return *msg->_impl_.accepted_at_;
}
const ::google::protobuf::Timestamp& QuestInfo::_Internal::completed_at(const QuestInfo* msg) {
  return *msg->_impl_.completed_at_;
}
void QuestInfo::clear_accepted_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.accepted_at_ != nullptr) _impl_.accepted_at_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void QuestInfo::clear_completed_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.completed_at_ != nullptr) _impl_.completed_at_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
QuestInfo::QuestInfo(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:mmorpg.QuestInfo)
}
inline PROTOBUF_NDEBUG_INLINE QuestInfo::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        objectives_{visibility, arena, from.objectives_},
        rewards_{visibility, arena, from.rewards_},
        quest_id_(arena, from.quest_id_),
        quest_name_(arena, from.quest_name_),
        description_(arena, from.description_) {}

QuestInfo::QuestInfo(
    ::google::protobuf::Arena* arena,
    const QuestInfo& from)
    : ::google::protobuf::Message(arena) {
  QuestInfo* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.accepted_at_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::google::protobuf::Timestamp>(arena, *from._impl_.accepted_at_)
                : nullptr;
  _impl_.completed_at_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::google::protobuf::Timestamp>(arena, *from._impl_.completed_at_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, status_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, status_),
           offsetof(Impl_, is_daily_quest_) -
               offsetof(Impl_, status_) +
               sizeof(Impl_::is_daily_quest_));

  // @@protoc_insertion_point(copy_constructor:mmorpg.QuestInfo)
}
inline PROTOBUF_NDEBUG_INLINE QuestInfo::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        objectives_{visibility, arena},
        rewards_{visibility, arena},
        quest_id_(arena),
        quest_name_(arena),
        description_(arena) {}

inline void QuestInfo::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, accepted_at_),
           0,
           offsetof(Impl_, is_daily_quest_) -
               offsetof(Impl_, accepted_at_) +
               sizeof(Impl_::is_daily_quest_));
}
QuestInfo::~QuestInfo() {
  // @@protoc_insertion_point(destructor:mmorpg.QuestInfo)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void QuestInfo::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.quest_id_.Destroy();
  _impl_.quest_name_.Destroy();
  _impl_.description_.Destroy();
  delete _impl_.accepted_at_;
  delete _impl_.completed_at_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void QuestInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mmorpg.QuestInfo)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.objectives_.Clear();
  _impl_.rewards_.Clear();
  _impl_.quest_id_.ClearToEmpty();
  _impl_.quest_name_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.accepted_at_ != nullptr);
      _impl_.accepted_at_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.completed_at_ != nullptr);
      _impl_.completed_at_->Clear();
    }
  }
  ::memset(&_impl_.status_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.is_daily_quest_) -
      reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.is_daily_quest_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* QuestInfo::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 11, 4, 62, 2> QuestInfo::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_._has_bits_),
    0, // no _extensions_
    11, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294965248,  // skipmap
    offsetof(decltype(_table_), field_entries),
    11,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_QuestInfo_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string quest_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_.quest_id_)}},
    // string quest_name = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_.quest_name_)}},
    // string description = 3;
    {::_pbi::TcParser::FastUS1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_.description_)}},
    // .mmorpg.QuestStatus status = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(QuestInfo, _impl_.status_), 63>(),
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_.status_)}},
    // repeated .mmorpg.QuestObjective objectives = 5;
    {::_pbi::TcParser::FastMtR1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_.objectives_)}},
    // repeated .mmorpg.QuestReward rewards = 6;
    {::_pbi::TcParser::FastMtR1,
     {50, 63, 1, PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_.rewards_)}},
    // int32 recommended_level = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(QuestInfo, _impl_.recommended_level_), 63>(),
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_.recommended_level_)}},
    // bool is_main_quest = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(QuestInfo, _impl_.is_main_quest_), 63>(),
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_.is_main_quest_)}},
    // bool is_daily_quest = 9;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(QuestInfo, _impl_.is_daily_quest_), 63>(),
     {72, 63, 0, PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_.is_daily_quest_)}},
    // .google.protobuf.Timestamp accepted_at = 10;
    {::_pbi::TcParser::FastMtS1,
     {82, 0, 2, PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_.accepted_at_)}},
    // .google.protobuf.Timestamp completed_at = 11;
    {::_pbi::TcParser::FastMtS1,
     {90, 1, 3, PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_.completed_at_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string quest_id = 1;
    {PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_.quest_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string quest_name = 2;
    {PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_.quest_name_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string description = 3;
    {PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_.description_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .mmorpg.QuestStatus status = 4;
    {PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_.status_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // repeated .mmorpg.QuestObjective objectives = 5;
    {PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_.objectives_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .mmorpg.QuestReward rewards = 6;
    {PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_.rewards_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // int32 recommended_level = 7;
    {PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_.recommended_level_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // bool is_main_quest = 8;
    {PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_.is_main_quest_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool is_daily_quest = 9;
    {PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_.is_daily_quest_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // .google.protobuf.Timestamp accepted_at = 10;
    {PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_.accepted_at_), _Internal::kHasBitsOffset + 0, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Timestamp completed_at = 11;
    {PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_.completed_at_), _Internal::kHasBitsOffset + 1, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::mmorpg::QuestObjective>()},
    {::_pbi::TcParser::GetTable<::mmorpg::QuestReward>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
  }}, {{
    "\20\10\12\13\0\0\0\0\0\0\0\0\0\0\0\0"
    "mmorpg.QuestInfo"
    "quest_id"
    "quest_name"
    "description"
  }},
};

::uint8_t* QuestInfo::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mmorpg.QuestInfo)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string quest_id = 1;
  if (!this->_internal_quest_id().empty()) {
    const std::string& _s = this->_internal_quest_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.QuestInfo.quest_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string quest_name = 2;
  if (!this->_internal_quest_name().empty()) {
    const std::string& _s = this->_internal_quest_name();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.QuestInfo.quest_name");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    const std::string& _s = this->_internal_description();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.QuestInfo.description");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // .mmorpg.QuestStatus status = 4;
  if (this->_internal_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_status(), target);
  }

  // repeated .mmorpg.QuestObjective objectives = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_objectives_size()); i < n; i++) {
    const auto& repfield = this->_internal_objectives().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .mmorpg.QuestReward rewards = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_rewards_size()); i < n; i++) {
    const auto& repfield = this->_internal_rewards().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int32 recommended_level = 7;
  if (this->_internal_recommended_level() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<7>(
            stream, this->_internal_recommended_level(), target);
  }

  // bool is_main_quest = 8;
  if (this->_internal_is_main_quest() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this->_internal_is_main_quest(), target);
  }

  // bool is_daily_quest = 9;
  if (this->_internal_is_daily_quest() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        9, this->_internal_is_daily_quest(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .google.protobuf.Timestamp accepted_at = 10;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        10, _Internal::accepted_at(this),
        _Internal::accepted_at(this).GetCachedSize(), target, stream);
  }

  // .google.protobuf.Timestamp completed_at = 11;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        11, _Internal::completed_at(this),
        _Internal::completed_at(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mmorpg.QuestInfo)
  return target;
}

::size_t QuestInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mmorpg.QuestInfo)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mmorpg.QuestObjective objectives = 5;
  total_size += 1UL * this->_internal_objectives_size();
  for (const auto& msg : this->_internal_objectives()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .mmorpg.QuestReward rewards = 6;
  total_size += 1UL * this->_internal_rewards_size();
  for (const auto& msg : this->_internal_rewards()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // string quest_id = 1;
  if (!this->_internal_quest_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_quest_id());
  }

  // string quest_name = 2;
  if (!this->_internal_quest_name().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_quest_name());
  }

  // string description = 3;
  if (!this->_internal_description().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_description());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .google.protobuf.Timestamp accepted_at = 10;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.accepted_at_);
    }

    // .google.protobuf.Timestamp completed_at = 11;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.completed_at_);
    }

  }
  // .mmorpg.QuestStatus status = 4;
  if (this->_internal_status() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
  }

  // int32 recommended_level = 7;
  if (this->_internal_recommended_level() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_recommended_level());
  }

  // bool is_main_quest = 8;
  if (this->_internal_is_main_quest() != 0) {
    total_size += 2;
  }

  // bool is_daily_quest = 9;
  if (this->_internal_is_daily_quest() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData QuestInfo::_class_data_ = {
    QuestInfo::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* QuestInfo::GetClassData() const {
  return &_class_data_;
}

void QuestInfo::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<QuestInfo*>(&to_msg);
  auto& from = static_cast<const QuestInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:mmorpg.QuestInfo)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_objectives()->MergeFrom(
      from._internal_objectives());
  _this->_internal_mutable_rewards()->MergeFrom(
      from._internal_rewards());
  if (!from._internal_quest_id().empty()) {
    _this->_internal_set_quest_id(from._internal_quest_id());
  }
  if (!from._internal_quest_name().empty()) {
    _this->_internal_set_quest_name(from._internal_quest_name());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_accepted_at()->::google::protobuf::Timestamp::MergeFrom(
          from._internal_accepted_at());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_completed_at()->::google::protobuf::Timestamp::MergeFrom(
          from._internal_completed_at());
    }
  }
  if (from._internal_status() != 0) {
    _this->_internal_set_status(from._internal_status());
  }
  if (from._internal_recommended_level() != 0) {
    _this->_internal_set_recommended_level(from._internal_recommended_level());
  }
  if (from._internal_is_main_quest() != 0) {
    _this->_internal_set_is_main_quest(from._internal_is_main_quest());
  }
  if (from._internal_is_daily_quest() != 0) {
    _this->_internal_set_is_daily_quest(from._internal_is_daily_quest());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void QuestInfo::CopyFrom(const QuestInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mmorpg.QuestInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool QuestInfo::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* QuestInfo::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void QuestInfo::InternalSwap(QuestInfo* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.objectives_.InternalSwap(&other->_impl_.objectives_);
  _impl_.rewards_.InternalSwap(&other->_impl_.rewards_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.quest_id_, &other->_impl_.quest_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.quest_name_, &other->_impl_.quest_name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.description_, &other->_impl_.description_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_.is_daily_quest_)
      + sizeof(QuestInfo::_impl_.is_daily_quest_)
      - PROTOBUF_FIELD_OFFSET(QuestInfo, _impl_.accepted_at_)>(
          reinterpret_cast<char*>(&_impl_.accepted_at_),
          reinterpret_cast<char*>(&other->_impl_.accepted_at_));
}

::google::protobuf::Metadata QuestInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[11]);
}
// ===================================================================

class QuestObjective::_Internal {
 public:
};

QuestObjective::QuestObjective(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:mmorpg.QuestObjective)
}
inline PROTOBUF_NDEBUG_INLINE QuestObjective::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : objective_id_(arena, from.objective_id_),
        description_(arena, from.description_),
        target_id_(arena, from.target_id_),
        _cached_size_{0} {}

QuestObjective::QuestObjective(
    ::google::protobuf::Arena* arena,
    const QuestObjective& from)
    : ::google::protobuf::Message(arena) {
  QuestObjective* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, type_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, type_),
           offsetof(Impl_, is_optional_) -
               offsetof(Impl_, type_) +
               sizeof(Impl_::is_optional_));

  // @@protoc_insertion_point(copy_constructor:mmorpg.QuestObjective)
}
inline PROTOBUF_NDEBUG_INLINE QuestObjective::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : objective_id_(arena),
        description_(arena),
        target_id_(arena),
        _cached_size_{0} {}

inline void QuestObjective::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, type_),
           0,
           offsetof(Impl_, is_optional_) -
               offsetof(Impl_, type_) +
               sizeof(Impl_::is_optional_));
}
QuestObjective::~QuestObjective() {
  // @@protoc_insertion_point(destructor:mmorpg.QuestObjective)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void QuestObjective::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.objective_id_.Destroy();
  _impl_.description_.Destroy();
  _impl_.target_id_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void QuestObjective::Clear() {
// @@protoc_insertion_point(message_clear_start:mmorpg.QuestObjective)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.objective_id_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  _impl_.target_id_.ClearToEmpty();
  ::memset(&_impl_.type_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.is_optional_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.is_optional_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* QuestObjective::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 0, 70, 2> QuestObjective::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_QuestObjective_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // bool is_optional = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(QuestObjective, _impl_.is_optional_), 63>(),
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(QuestObjective, _impl_.is_optional_)}},
    // string objective_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(QuestObjective, _impl_.objective_id_)}},
    // string description = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(QuestObjective, _impl_.description_)}},
    // .mmorpg.ObjectiveType type = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(QuestObjective, _impl_.type_), 63>(),
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(QuestObjective, _impl_.type_)}},
    // string target_id = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(QuestObjective, _impl_.target_id_)}},
    // int32 current_progress = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(QuestObjective, _impl_.current_progress_), 63>(),
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(QuestObjective, _impl_.current_progress_)}},
    // int32 required_progress = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(QuestObjective, _impl_.required_progress_), 63>(),
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(QuestObjective, _impl_.required_progress_)}},
    // bool is_completed = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(QuestObjective, _impl_.is_completed_), 63>(),
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(QuestObjective, _impl_.is_completed_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string objective_id = 1;
    {PROTOBUF_FIELD_OFFSET(QuestObjective, _impl_.objective_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string description = 2;
    {PROTOBUF_FIELD_OFFSET(QuestObjective, _impl_.description_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .mmorpg.ObjectiveType type = 3;
    {PROTOBUF_FIELD_OFFSET(QuestObjective, _impl_.type_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // string target_id = 4;
    {PROTOBUF_FIELD_OFFSET(QuestObjective, _impl_.target_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // int32 current_progress = 5;
    {PROTOBUF_FIELD_OFFSET(QuestObjective, _impl_.current_progress_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // int32 required_progress = 6;
    {PROTOBUF_FIELD_OFFSET(QuestObjective, _impl_.required_progress_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // bool is_completed = 7;
    {PROTOBUF_FIELD_OFFSET(QuestObjective, _impl_.is_completed_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool is_optional = 8;
    {PROTOBUF_FIELD_OFFSET(QuestObjective, _impl_.is_optional_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
    "\25\14\13\0\11\0\0\0\0\0\0\0\0\0\0\0"
    "mmorpg.QuestObjective"
    "objective_id"
    "description"
    "target_id"
  }},
};

::uint8_t* QuestObjective::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mmorpg.QuestObjective)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string objective_id = 1;
  if (!this->_internal_objective_id().empty()) {
    const std::string& _s = this->_internal_objective_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.QuestObjective.objective_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string description = 2;
  if (!this->_internal_description().empty()) {
    const std::string& _s = this->_internal_description();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.QuestObjective.description");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // .mmorpg.ObjectiveType type = 3;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_type(), target);
  }

  // string target_id = 4;
  if (!this->_internal_target_id().empty()) {
    const std::string& _s = this->_internal_target_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.QuestObjective.target_id");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // int32 current_progress = 5;
  if (this->_internal_current_progress() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<5>(
            stream, this->_internal_current_progress(), target);
  }

  // int32 required_progress = 6;
  if (this->_internal_required_progress() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<6>(
            stream, this->_internal_required_progress(), target);
  }

  // bool is_completed = 7;
  if (this->_internal_is_completed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this->_internal_is_completed(), target);
  }

  // bool is_optional = 8;
  if (this->_internal_is_optional() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this->_internal_is_optional(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mmorpg.QuestObjective)
  return target;
}

::size_t QuestObjective::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mmorpg.QuestObjective)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string objective_id = 1;
  if (!this->_internal_objective_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_objective_id());
  }

  // string description = 2;
  if (!this->_internal_description().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_description());
  }

  // string target_id = 4;
  if (!this->_internal_target_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_target_id());
  }

  // .mmorpg.ObjectiveType type = 3;
  if (this->_internal_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // int32 current_progress = 5;
  if (this->_internal_current_progress() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_current_progress());
  }

  // int32 required_progress = 6;
  if (this->_internal_required_progress() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_required_progress());
  }

  // bool is_completed = 7;
  if (this->_internal_is_completed() != 0) {
    total_size += 2;
  }

  // bool is_optional = 8;
  if (this->_internal_is_optional() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData QuestObjective::_class_data_ = {
    QuestObjective::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* QuestObjective::GetClassData() const {
  return &_class_data_;
}

void QuestObjective::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<QuestObjective*>(&to_msg);
  auto& from = static_cast<const QuestObjective&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:mmorpg.QuestObjective)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_objective_id().empty()) {
    _this->_internal_set_objective_id(from._internal_objective_id());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_target_id().empty()) {
    _this->_internal_set_target_id(from._internal_target_id());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_current_progress() != 0) {
    _this->_internal_set_current_progress(from._internal_current_progress());
  }
  if (from._internal_required_progress() != 0) {
    _this->_internal_set_required_progress(from._internal_required_progress());
  }
  if (from._internal_is_completed() != 0) {
    _this->_internal_set_is_completed(from._internal_is_completed());
  }
  if (from._internal_is_optional() != 0) {
    _this->_internal_set_is_optional(from._internal_is_optional());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void QuestObjective::CopyFrom(const QuestObjective& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mmorpg.QuestObjective)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool QuestObjective::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* QuestObjective::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void QuestObjective::InternalSwap(QuestObjective* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.objective_id_, &other->_impl_.objective_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.description_, &other->_impl_.description_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.target_id_, &other->_impl_.target_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QuestObjective, _impl_.is_optional_)
      + sizeof(QuestObjective::_impl_.is_optional_)
      - PROTOBUF_FIELD_OFFSET(QuestObjective, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::google::protobuf::Metadata QuestObjective::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[12]);
}
// ===================================================================

class QuestReward::_Internal {
 public:
};

QuestReward::QuestReward(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:mmorpg.QuestReward)
}
inline PROTOBUF_NDEBUG_INLINE QuestReward::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : reward_id_(arena, from.reward_id_),
        _cached_size_{0} {}

QuestReward::QuestReward(
    ::google::protobuf::Arena* arena,
    const QuestReward& from)
    : ::google::protobuf::Message(arena) {
  QuestReward* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, type_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, type_),
           offsetof(Impl_, quantity_) -
               offsetof(Impl_, type_) +
               sizeof(Impl_::quantity_));

  // @@protoc_insertion_point(copy_constructor:mmorpg.QuestReward)
}
inline PROTOBUF_NDEBUG_INLINE QuestReward::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : reward_id_(arena),
        _cached_size_{0} {}

inline void QuestReward::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, type_),
           0,
           offsetof(Impl_, quantity_) -
               offsetof(Impl_, type_) +
               sizeof(Impl_::quantity_));
}
QuestReward::~QuestReward() {
  // @@protoc_insertion_point(destructor:mmorpg.QuestReward)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void QuestReward::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.reward_id_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void QuestReward::Clear() {
// @@protoc_insertion_point(message_clear_start:mmorpg.QuestReward)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.reward_id_.ClearToEmpty();
  ::memset(&_impl_.type_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.quantity_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.quantity_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* QuestReward::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 36, 2> QuestReward::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_QuestReward_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .mmorpg.RewardType type = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(QuestReward, _impl_.type_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(QuestReward, _impl_.type_)}},
    // string reward_id = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(QuestReward, _impl_.reward_id_)}},
    // int32 quantity = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(QuestReward, _impl_.quantity_), 63>(),
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(QuestReward, _impl_.quantity_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .mmorpg.RewardType type = 1;
    {PROTOBUF_FIELD_OFFSET(QuestReward, _impl_.type_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // string reward_id = 2;
    {PROTOBUF_FIELD_OFFSET(QuestReward, _impl_.reward_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // int32 quantity = 3;
    {PROTOBUF_FIELD_OFFSET(QuestReward, _impl_.quantity_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
    "\22\0\11\0\0\0\0\0"
    "mmorpg.QuestReward"
    "reward_id"
  }},
};

::uint8_t* QuestReward::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mmorpg.QuestReward)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // .mmorpg.RewardType type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_type(), target);
  }

  // string reward_id = 2;
  if (!this->_internal_reward_id().empty()) {
    const std::string& _s = this->_internal_reward_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.QuestReward.reward_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // int32 quantity = 3;
  if (this->_internal_quantity() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<3>(
            stream, this->_internal_quantity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mmorpg.QuestReward)
  return target;
}

::size_t QuestReward::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mmorpg.QuestReward)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string reward_id = 2;
  if (!this->_internal_reward_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_reward_id());
  }

  // .mmorpg.RewardType type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // int32 quantity = 3;
  if (this->_internal_quantity() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_quantity());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData QuestReward::_class_data_ = {
    QuestReward::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* QuestReward::GetClassData() const {
  return &_class_data_;
}

void QuestReward::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<QuestReward*>(&to_msg);
  auto& from = static_cast<const QuestReward&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:mmorpg.QuestReward)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_reward_id().empty()) {
    _this->_internal_set_reward_id(from._internal_reward_id());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_quantity() != 0) {
    _this->_internal_set_quantity(from._internal_quantity());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void QuestReward::CopyFrom(const QuestReward& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mmorpg.QuestReward)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool QuestReward::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* QuestReward::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void QuestReward::InternalSwap(QuestReward* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.reward_id_, &other->_impl_.reward_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(QuestReward, _impl_.quantity_)
      + sizeof(QuestReward::_impl_.quantity_)
      - PROTOBUF_FIELD_OFFSET(QuestReward, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::google::protobuf::Metadata QuestReward::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[13]);
}
// ===================================================================

class CombatAction::_Internal {
 public:
  using HasBits = decltype(std::declval<CombatAction>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CombatAction, _impl_._has_bits_);
  static const ::google::protobuf::Timestamp& timestamp(const CombatAction* msg);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::google::protobuf::Timestamp& CombatAction::_Internal::timestamp(const CombatAction* msg) {
  return *msg->_impl_.timestamp_;
}
void CombatAction::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.timestamp_ != nullptr) _impl_.timestamp_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CombatAction::CombatAction(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:mmorpg.CombatAction)
}
inline PROTOBUF_NDEBUG_INLINE CombatAction::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        attacker_id_(arena, from.attacker_id_),
        target_id_(arena, from.target_id_),
        skill_id_(arena, from.skill_id_) {}

CombatAction::CombatAction(
    ::google::protobuf::Arena* arena,
    const CombatAction& from)
    : ::google::protobuf::Message(arena) {
  CombatAction* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.timestamp_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::google::protobuf::Timestamp>(arena, *from._impl_.timestamp_)
                : nullptr;
  _impl_.action_type_ = from._impl_.action_type_;

  // @@protoc_insertion_point(copy_constructor:mmorpg.CombatAction)
}
inline PROTOBUF_NDEBUG_INLINE CombatAction::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        attacker_id_(arena),
        target_id_(arena),
        skill_id_(arena) {}

inline void CombatAction::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, timestamp_),
           0,
           offsetof(Impl_, action_type_) -
               offsetof(Impl_, timestamp_) +
               sizeof(Impl_::action_type_));
}
CombatAction::~CombatAction() {
  // @@protoc_insertion_point(destructor:mmorpg.CombatAction)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CombatAction::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.attacker_id_.Destroy();
  _impl_.target_id_.Destroy();
  _impl_.skill_id_.Destroy();
  delete _impl_.timestamp_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CombatAction::Clear() {
// @@protoc_insertion_point(message_clear_start:mmorpg.CombatAction)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.attacker_id_.ClearToEmpty();
  _impl_.target_id_.ClearToEmpty();
  _impl_.skill_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.timestamp_ != nullptr);
    _impl_.timestamp_->Clear();
  }
  _impl_.action_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CombatAction::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 1, 56, 2> CombatAction::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CombatAction, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CombatAction_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string attacker_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(CombatAction, _impl_.attacker_id_)}},
    // string target_id = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(CombatAction, _impl_.target_id_)}},
    // string skill_id = 3;
    {::_pbi::TcParser::FastUS1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(CombatAction, _impl_.skill_id_)}},
    // .mmorpg.CombatActionType action_type = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CombatAction, _impl_.action_type_), 63>(),
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(CombatAction, _impl_.action_type_)}},
    // .google.protobuf.Timestamp timestamp = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 0, 0, PROTOBUF_FIELD_OFFSET(CombatAction, _impl_.timestamp_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string attacker_id = 1;
    {PROTOBUF_FIELD_OFFSET(CombatAction, _impl_.attacker_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string target_id = 2;
    {PROTOBUF_FIELD_OFFSET(CombatAction, _impl_.target_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string skill_id = 3;
    {PROTOBUF_FIELD_OFFSET(CombatAction, _impl_.skill_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .mmorpg.CombatActionType action_type = 4;
    {PROTOBUF_FIELD_OFFSET(CombatAction, _impl_.action_type_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .google.protobuf.Timestamp timestamp = 5;
    {PROTOBUF_FIELD_OFFSET(CombatAction, _impl_.timestamp_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
  }}, {{
    "\23\13\11\10\0\0\0\0"
    "mmorpg.CombatAction"
    "attacker_id"
    "target_id"
    "skill_id"
  }},
};

::uint8_t* CombatAction::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mmorpg.CombatAction)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string attacker_id = 1;
  if (!this->_internal_attacker_id().empty()) {
    const std::string& _s = this->_internal_attacker_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.CombatAction.attacker_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string target_id = 2;
  if (!this->_internal_target_id().empty()) {
    const std::string& _s = this->_internal_target_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.CombatAction.target_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string skill_id = 3;
  if (!this->_internal_skill_id().empty()) {
    const std::string& _s = this->_internal_skill_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.CombatAction.skill_id");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // .mmorpg.CombatActionType action_type = 4;
  if (this->_internal_action_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_action_type(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .google.protobuf.Timestamp timestamp = 5;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        5, _Internal::timestamp(this),
        _Internal::timestamp(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mmorpg.CombatAction)
  return target;
}

::size_t CombatAction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mmorpg.CombatAction)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string attacker_id = 1;
  if (!this->_internal_attacker_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_attacker_id());
  }

  // string target_id = 2;
  if (!this->_internal_target_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_target_id());
  }

  // string skill_id = 3;
  if (!this->_internal_skill_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_skill_id());
  }

  // .google.protobuf.Timestamp timestamp = 5;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size +=
        1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.timestamp_);
  }

  // .mmorpg.CombatActionType action_type = 4;
  if (this->_internal_action_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_action_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CombatAction::_class_data_ = {
    CombatAction::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* CombatAction::GetClassData() const {
  return &_class_data_;
}

void CombatAction::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CombatAction*>(&to_msg);
  auto& from = static_cast<const CombatAction&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:mmorpg.CombatAction)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_attacker_id().empty()) {
    _this->_internal_set_attacker_id(from._internal_attacker_id());
  }
  if (!from._internal_target_id().empty()) {
    _this->_internal_set_target_id(from._internal_target_id());
  }
  if (!from._internal_skill_id().empty()) {
    _this->_internal_set_skill_id(from._internal_skill_id());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_timestamp()->::google::protobuf::Timestamp::MergeFrom(
        from._internal_timestamp());
  }
  if (from._internal_action_type() != 0) {
    _this->_internal_set_action_type(from._internal_action_type());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CombatAction::CopyFrom(const CombatAction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mmorpg.CombatAction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CombatAction::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* CombatAction::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CombatAction::InternalSwap(CombatAction* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.attacker_id_, &other->_impl_.attacker_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.target_id_, &other->_impl_.target_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.skill_id_, &other->_impl_.skill_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CombatAction, _impl_.action_type_)
      + sizeof(CombatAction::_impl_.action_type_)
      - PROTOBUF_FIELD_OFFSET(CombatAction, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::google::protobuf::Metadata CombatAction::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[14]);
}
// ===================================================================

class CombatResult::_Internal {
 public:
};

CombatResult::CombatResult(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:mmorpg.CombatResult)
}
inline PROTOBUF_NDEBUG_INLINE CombatResult::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : effects_{visibility, arena, from.effects_},
        action_id_(arena, from.action_id_),
        failure_reason_(arena, from.failure_reason_),
        _cached_size_{0} {}

CombatResult::CombatResult(
    ::google::protobuf::Arena* arena,
    const CombatResult& from)
    : ::google::protobuf::Message(arena) {
  CombatResult* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  _impl_.success_ = from._impl_.success_;

  // @@protoc_insertion_point(copy_constructor:mmorpg.CombatResult)
}
inline PROTOBUF_NDEBUG_INLINE CombatResult::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : effects_{visibility, arena},
        action_id_(arena),
        failure_reason_(arena),
        _cached_size_{0} {}

inline void CombatResult::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.success_ = {};
}
CombatResult::~CombatResult() {
  // @@protoc_insertion_point(destructor:mmorpg.CombatResult)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CombatResult::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.action_id_.Destroy();
  _impl_.failure_reason_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CombatResult::Clear() {
// @@protoc_insertion_point(message_clear_start:mmorpg.CombatResult)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.effects_.Clear();
  _impl_.action_id_.ClearToEmpty();
  _impl_.failure_reason_.ClearToEmpty();
  _impl_.success_ = false;
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CombatResult::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 51, 2> CombatResult::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CombatResult_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // string failure_reason = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(CombatResult, _impl_.failure_reason_)}},
    // string action_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(CombatResult, _impl_.action_id_)}},
    // bool success = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CombatResult, _impl_.success_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(CombatResult, _impl_.success_)}},
    // repeated .mmorpg.CombatEffect effects = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(CombatResult, _impl_.effects_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string action_id = 1;
    {PROTOBUF_FIELD_OFFSET(CombatResult, _impl_.action_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bool success = 2;
    {PROTOBUF_FIELD_OFFSET(CombatResult, _impl_.success_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // repeated .mmorpg.CombatEffect effects = 3;
    {PROTOBUF_FIELD_OFFSET(CombatResult, _impl_.effects_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // string failure_reason = 4;
    {PROTOBUF_FIELD_OFFSET(CombatResult, _impl_.failure_reason_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }}, {{
    {::_pbi::TcParser::GetTable<::mmorpg::CombatEffect>()},
  }}, {{
    "\23\11\0\0\16\0\0\0"
    "mmorpg.CombatResult"
    "action_id"
    "failure_reason"
  }},
};

::uint8_t* CombatResult::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mmorpg.CombatResult)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string action_id = 1;
  if (!this->_internal_action_id().empty()) {
    const std::string& _s = this->_internal_action_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.CombatResult.action_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // bool success = 2;
  if (this->_internal_success() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_success(), target);
  }

  // repeated .mmorpg.CombatEffect effects = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_effects_size()); i < n; i++) {
    const auto& repfield = this->_internal_effects().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string failure_reason = 4;
  if (!this->_internal_failure_reason().empty()) {
    const std::string& _s = this->_internal_failure_reason();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.CombatResult.failure_reason");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mmorpg.CombatResult)
  return target;
}

::size_t CombatResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mmorpg.CombatResult)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mmorpg.CombatEffect effects = 3;
  total_size += 1UL * this->_internal_effects_size();
  for (const auto& msg : this->_internal_effects()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // string action_id = 1;
  if (!this->_internal_action_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_action_id());
  }

  // string failure_reason = 4;
  if (!this->_internal_failure_reason().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_failure_reason());
  }

  // bool success = 2;
  if (this->_internal_success() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CombatResult::_class_data_ = {
    CombatResult::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* CombatResult::GetClassData() const {
  return &_class_data_;
}

void CombatResult::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CombatResult*>(&to_msg);
  auto& from = static_cast<const CombatResult&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:mmorpg.CombatResult)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_effects()->MergeFrom(
      from._internal_effects());
  if (!from._internal_action_id().empty()) {
    _this->_internal_set_action_id(from._internal_action_id());
  }
  if (!from._internal_failure_reason().empty()) {
    _this->_internal_set_failure_reason(from._internal_failure_reason());
  }
  if (from._internal_success() != 0) {
    _this->_internal_set_success(from._internal_success());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CombatResult::CopyFrom(const CombatResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mmorpg.CombatResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CombatResult::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* CombatResult::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CombatResult::InternalSwap(CombatResult* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.effects_.InternalSwap(&other->_impl_.effects_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.action_id_, &other->_impl_.action_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.failure_reason_, &other->_impl_.failure_reason_, arena);
        swap(_impl_.success_, other->_impl_.success_);
}

::google::protobuf::Metadata CombatResult::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[15]);
}
// ===================================================================

class CombatEffect::_Internal {
 public:
};

CombatEffect::CombatEffect(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:mmorpg.CombatEffect)
}
inline PROTOBUF_NDEBUG_INLINE CombatEffect::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : target_id_(arena, from.target_id_),
        _cached_size_{0} {}

CombatEffect::CombatEffect(
    ::google::protobuf::Arena* arena,
    const CombatEffect& from)
    : ::google::protobuf::Message(arena) {
  CombatEffect* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, effect_type_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, effect_type_),
           offsetof(Impl_, is_resisted_) -
               offsetof(Impl_, effect_type_) +
               sizeof(Impl_::is_resisted_));

  // @@protoc_insertion_point(copy_constructor:mmorpg.CombatEffect)
}
inline PROTOBUF_NDEBUG_INLINE CombatEffect::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : target_id_(arena),
        _cached_size_{0} {}

inline void CombatEffect::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, effect_type_),
           0,
           offsetof(Impl_, is_resisted_) -
               offsetof(Impl_, effect_type_) +
               sizeof(Impl_::is_resisted_));
}
CombatEffect::~CombatEffect() {
  // @@protoc_insertion_point(destructor:mmorpg.CombatEffect)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CombatEffect::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.target_id_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CombatEffect::Clear() {
// @@protoc_insertion_point(message_clear_start:mmorpg.CombatEffect)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.target_id_.ClearToEmpty();
  ::memset(&_impl_.effect_type_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.is_resisted_) -
      reinterpret_cast<char*>(&_impl_.effect_type_)) + sizeof(_impl_.is_resisted_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CombatEffect::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 0, 37, 2> CombatEffect::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_CombatEffect_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string target_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(CombatEffect, _impl_.target_id_)}},
    // .mmorpg.CombatEffectType effect_type = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CombatEffect, _impl_.effect_type_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(CombatEffect, _impl_.effect_type_)}},
    // int32 value = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(CombatEffect, _impl_.value_), 63>(),
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(CombatEffect, _impl_.value_)}},
    // bool is_critical = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CombatEffect, _impl_.is_critical_), 63>(),
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(CombatEffect, _impl_.is_critical_)}},
    // bool is_blocked = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CombatEffect, _impl_.is_blocked_), 63>(),
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(CombatEffect, _impl_.is_blocked_)}},
    // bool is_dodged = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CombatEffect, _impl_.is_dodged_), 63>(),
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(CombatEffect, _impl_.is_dodged_)}},
    // bool is_resisted = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CombatEffect, _impl_.is_resisted_), 63>(),
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(CombatEffect, _impl_.is_resisted_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string target_id = 1;
    {PROTOBUF_FIELD_OFFSET(CombatEffect, _impl_.target_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .mmorpg.CombatEffectType effect_type = 2;
    {PROTOBUF_FIELD_OFFSET(CombatEffect, _impl_.effect_type_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // int32 value = 3;
    {PROTOBUF_FIELD_OFFSET(CombatEffect, _impl_.value_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // bool is_critical = 4;
    {PROTOBUF_FIELD_OFFSET(CombatEffect, _impl_.is_critical_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool is_blocked = 5;
    {PROTOBUF_FIELD_OFFSET(CombatEffect, _impl_.is_blocked_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool is_dodged = 6;
    {PROTOBUF_FIELD_OFFSET(CombatEffect, _impl_.is_dodged_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool is_resisted = 7;
    {PROTOBUF_FIELD_OFFSET(CombatEffect, _impl_.is_resisted_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
    "\23\11\0\0\0\0\0\0"
    "mmorpg.CombatEffect"
    "target_id"
  }},
};

::uint8_t* CombatEffect::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mmorpg.CombatEffect)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string target_id = 1;
  if (!this->_internal_target_id().empty()) {
    const std::string& _s = this->_internal_target_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.CombatEffect.target_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // .mmorpg.CombatEffectType effect_type = 2;
  if (this->_internal_effect_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_effect_type(), target);
  }

  // int32 value = 3;
  if (this->_internal_value() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<3>(
            stream, this->_internal_value(), target);
  }

  // bool is_critical = 4;
  if (this->_internal_is_critical() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_is_critical(), target);
  }

  // bool is_blocked = 5;
  if (this->_internal_is_blocked() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_is_blocked(), target);
  }

  // bool is_dodged = 6;
  if (this->_internal_is_dodged() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        6, this->_internal_is_dodged(), target);
  }

  // bool is_resisted = 7;
  if (this->_internal_is_resisted() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this->_internal_is_resisted(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mmorpg.CombatEffect)
  return target;
}

::size_t CombatEffect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mmorpg.CombatEffect)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string target_id = 1;
  if (!this->_internal_target_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_target_id());
  }

  // .mmorpg.CombatEffectType effect_type = 2;
  if (this->_internal_effect_type() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_effect_type());
  }

  // int32 value = 3;
  if (this->_internal_value() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_value());
  }

  // bool is_critical = 4;
  if (this->_internal_is_critical() != 0) {
    total_size += 2;
  }

  // bool is_blocked = 5;
  if (this->_internal_is_blocked() != 0) {
    total_size += 2;
  }

  // bool is_dodged = 6;
  if (this->_internal_is_dodged() != 0) {
    total_size += 2;
  }

  // bool is_resisted = 7;
  if (this->_internal_is_resisted() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CombatEffect::_class_data_ = {
    CombatEffect::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* CombatEffect::GetClassData() const {
  return &_class_data_;
}

void CombatEffect::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CombatEffect*>(&to_msg);
  auto& from = static_cast<const CombatEffect&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:mmorpg.CombatEffect)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_target_id().empty()) {
    _this->_internal_set_target_id(from._internal_target_id());
  }
  if (from._internal_effect_type() != 0) {
    _this->_internal_set_effect_type(from._internal_effect_type());
  }
  if (from._internal_value() != 0) {
    _this->_internal_set_value(from._internal_value());
  }
  if (from._internal_is_critical() != 0) {
    _this->_internal_set_is_critical(from._internal_is_critical());
  }
  if (from._internal_is_blocked() != 0) {
    _this->_internal_set_is_blocked(from._internal_is_blocked());
  }
  if (from._internal_is_dodged() != 0) {
    _this->_internal_set_is_dodged(from._internal_is_dodged());
  }
  if (from._internal_is_resisted() != 0) {
    _this->_internal_set_is_resisted(from._internal_is_resisted());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CombatEffect::CopyFrom(const CombatEffect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mmorpg.CombatEffect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CombatEffect::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* CombatEffect::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CombatEffect::InternalSwap(CombatEffect* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.target_id_, &other->_impl_.target_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CombatEffect, _impl_.is_resisted_)
      + sizeof(CombatEffect::_impl_.is_resisted_)
      - PROTOBUF_FIELD_OFFSET(CombatEffect, _impl_.effect_type_)>(
          reinterpret_cast<char*>(&_impl_.effect_type_),
          reinterpret_cast<char*>(&other->_impl_.effect_type_));
}

::google::protobuf::Metadata CombatEffect::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[16]);
}
// ===================================================================

class TradeRequest::_Internal {
 public:
};

TradeRequest::TradeRequest(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:mmorpg.TradeRequest)
}
inline PROTOBUF_NDEBUG_INLINE TradeRequest::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : initiator_id_(arena, from.initiator_id_),
        target_player_id_(arena, from.target_player_id_),
        _cached_size_{0} {}

TradeRequest::TradeRequest(
    ::google::protobuf::Arena* arena,
    const TradeRequest& from)
    : ::google::protobuf::Message(arena) {
  TradeRequest* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);

  // @@protoc_insertion_point(copy_constructor:mmorpg.TradeRequest)
}
inline PROTOBUF_NDEBUG_INLINE TradeRequest::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : initiator_id_(arena),
        target_player_id_(arena),
        _cached_size_{0} {}

inline void TradeRequest::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
TradeRequest::~TradeRequest() {
  // @@protoc_insertion_point(destructor:mmorpg.TradeRequest)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void TradeRequest::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.initiator_id_.Destroy();
  _impl_.target_player_id_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void TradeRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:mmorpg.TradeRequest)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.initiator_id_.ClearToEmpty();
  _impl_.target_player_id_.ClearToEmpty();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* TradeRequest::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 56, 2> TradeRequest::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_TradeRequest_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // string target_player_id = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(TradeRequest, _impl_.target_player_id_)}},
    // string initiator_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(TradeRequest, _impl_.initiator_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string initiator_id = 1;
    {PROTOBUF_FIELD_OFFSET(TradeRequest, _impl_.initiator_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string target_player_id = 2;
    {PROTOBUF_FIELD_OFFSET(TradeRequest, _impl_.target_player_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\23\14\20\0\0\0\0\0"
    "mmorpg.TradeRequest"
    "initiator_id"
    "target_player_id"
  }},
};

::uint8_t* TradeRequest::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mmorpg.TradeRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string initiator_id = 1;
  if (!this->_internal_initiator_id().empty()) {
    const std::string& _s = this->_internal_initiator_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.TradeRequest.initiator_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string target_player_id = 2;
  if (!this->_internal_target_player_id().empty()) {
    const std::string& _s = this->_internal_target_player_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.TradeRequest.target_player_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mmorpg.TradeRequest)
  return target;
}

::size_t TradeRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mmorpg.TradeRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string initiator_id = 1;
  if (!this->_internal_initiator_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_initiator_id());
  }

  // string target_player_id = 2;
  if (!this->_internal_target_player_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_target_player_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData TradeRequest::_class_data_ = {
    TradeRequest::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* TradeRequest::GetClassData() const {
  return &_class_data_;
}

void TradeRequest::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<TradeRequest*>(&to_msg);
  auto& from = static_cast<const TradeRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:mmorpg.TradeRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_initiator_id().empty()) {
    _this->_internal_set_initiator_id(from._internal_initiator_id());
  }
  if (!from._internal_target_player_id().empty()) {
    _this->_internal_set_target_player_id(from._internal_target_player_id());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void TradeRequest::CopyFrom(const TradeRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mmorpg.TradeRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TradeRequest::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* TradeRequest::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void TradeRequest::InternalSwap(TradeRequest* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.initiator_id_, &other->_impl_.initiator_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.target_player_id_, &other->_impl_.target_player_id_, arena);
}

::google::protobuf::Metadata TradeRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[17]);
}
// ===================================================================

class TradeUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<TradeUpdate>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TradeUpdate, _impl_._has_bits_);
  static const ::mmorpg::TradeOffer& initiator_offer(const TradeUpdate* msg);
  static void set_has_initiator_offer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::mmorpg::TradeOffer& target_offer(const TradeUpdate* msg);
  static void set_has_target_offer(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::mmorpg::TradeOffer& TradeUpdate::_Internal::initiator_offer(const TradeUpdate* msg) {
  return *msg->_impl_.initiator_offer_;
}
const ::mmorpg::TradeOffer& TradeUpdate::_Internal::target_offer(const TradeUpdate* msg) {
  return *msg->_impl_.target_offer_;
}
TradeUpdate::TradeUpdate(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:mmorpg.TradeUpdate)
}
inline PROTOBUF_NDEBUG_INLINE TradeUpdate::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        trade_id_(arena, from.trade_id_) {}

TradeUpdate::TradeUpdate(
    ::google::protobuf::Arena* arena,
    const TradeUpdate& from)
    : ::google::protobuf::Message(arena) {
  TradeUpdate* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.initiator_offer_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::mmorpg::TradeOffer>(arena, *from._impl_.initiator_offer_)
                : nullptr;
  _impl_.target_offer_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::mmorpg::TradeOffer>(arena, *from._impl_.target_offer_)
                : nullptr;
  _impl_.state_ = from._impl_.state_;

  // @@protoc_insertion_point(copy_constructor:mmorpg.TradeUpdate)
}
inline PROTOBUF_NDEBUG_INLINE TradeUpdate::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        trade_id_(arena) {}

inline void TradeUpdate::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, initiator_offer_),
           0,
           offsetof(Impl_, state_) -
               offsetof(Impl_, initiator_offer_) +
               sizeof(Impl_::state_));
}
TradeUpdate::~TradeUpdate() {
  // @@protoc_insertion_point(destructor:mmorpg.TradeUpdate)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void TradeUpdate::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.trade_id_.Destroy();
  delete _impl_.initiator_offer_;
  delete _impl_.target_offer_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void TradeUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:mmorpg.TradeUpdate)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.trade_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.initiator_offer_ != nullptr);
      _impl_.initiator_offer_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.target_offer_ != nullptr);
      _impl_.target_offer_->Clear();
    }
  }
  _impl_.state_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* TradeUpdate::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 2, 35, 2> TradeUpdate::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TradeUpdate, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_TradeUpdate_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // .mmorpg.TradeOffer target_offer = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 1, 1, PROTOBUF_FIELD_OFFSET(TradeUpdate, _impl_.target_offer_)}},
    // string trade_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(TradeUpdate, _impl_.trade_id_)}},
    // .mmorpg.TradeState state = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(TradeUpdate, _impl_.state_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(TradeUpdate, _impl_.state_)}},
    // .mmorpg.TradeOffer initiator_offer = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(TradeUpdate, _impl_.initiator_offer_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string trade_id = 1;
    {PROTOBUF_FIELD_OFFSET(TradeUpdate, _impl_.trade_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .mmorpg.TradeState state = 2;
    {PROTOBUF_FIELD_OFFSET(TradeUpdate, _impl_.state_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .mmorpg.TradeOffer initiator_offer = 3;
    {PROTOBUF_FIELD_OFFSET(TradeUpdate, _impl_.initiator_offer_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .mmorpg.TradeOffer target_offer = 4;
    {PROTOBUF_FIELD_OFFSET(TradeUpdate, _impl_.target_offer_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::mmorpg::TradeOffer>()},
    {::_pbi::TcParser::GetTable<::mmorpg::TradeOffer>()},
  }}, {{
    "\22\10\0\0\0\0\0\0"
    "mmorpg.TradeUpdate"
    "trade_id"
  }},
};

::uint8_t* TradeUpdate::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mmorpg.TradeUpdate)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string trade_id = 1;
  if (!this->_internal_trade_id().empty()) {
    const std::string& _s = this->_internal_trade_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.TradeUpdate.trade_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // .mmorpg.TradeState state = 2;
  if (this->_internal_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_state(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .mmorpg.TradeOffer initiator_offer = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::initiator_offer(this),
        _Internal::initiator_offer(this).GetCachedSize(), target, stream);
  }

  // .mmorpg.TradeOffer target_offer = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, _Internal::target_offer(this),
        _Internal::target_offer(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mmorpg.TradeUpdate)
  return target;
}

::size_t TradeUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mmorpg.TradeUpdate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string trade_id = 1;
  if (!this->_internal_trade_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_trade_id());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .mmorpg.TradeOffer initiator_offer = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.initiator_offer_);
    }

    // .mmorpg.TradeOffer target_offer = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.target_offer_);
    }

  }
  // .mmorpg.TradeState state = 2;
  if (this->_internal_state() != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_state());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData TradeUpdate::_class_data_ = {
    TradeUpdate::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* TradeUpdate::GetClassData() const {
  return &_class_data_;
}

void TradeUpdate::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<TradeUpdate*>(&to_msg);
  auto& from = static_cast<const TradeUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:mmorpg.TradeUpdate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_trade_id().empty()) {
    _this->_internal_set_trade_id(from._internal_trade_id());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_initiator_offer()->::mmorpg::TradeOffer::MergeFrom(
          from._internal_initiator_offer());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_target_offer()->::mmorpg::TradeOffer::MergeFrom(
          from._internal_target_offer());
    }
  }
  if (from._internal_state() != 0) {
    _this->_internal_set_state(from._internal_state());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void TradeUpdate::CopyFrom(const TradeUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mmorpg.TradeUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TradeUpdate::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* TradeUpdate::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void TradeUpdate::InternalSwap(TradeUpdate* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.trade_id_, &other->_impl_.trade_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TradeUpdate, _impl_.state_)
      + sizeof(TradeUpdate::_impl_.state_)
      - PROTOBUF_FIELD_OFFSET(TradeUpdate, _impl_.initiator_offer_)>(
          reinterpret_cast<char*>(&_impl_.initiator_offer_),
          reinterpret_cast<char*>(&other->_impl_.initiator_offer_));
}

::google::protobuf::Metadata TradeUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[18]);
}
// ===================================================================

class TradeOffer::_Internal {
 public:
};

TradeOffer::TradeOffer(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:mmorpg.TradeOffer)
}
inline PROTOBUF_NDEBUG_INLINE TradeOffer::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : items_{visibility, arena, from.items_},
        player_id_(arena, from.player_id_),
        _cached_size_{0} {}

TradeOffer::TradeOffer(
    ::google::protobuf::Arena* arena,
    const TradeOffer& from)
    : ::google::protobuf::Message(arena) {
  TradeOffer* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, gold_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, gold_),
           offsetof(Impl_, accepted_) -
               offsetof(Impl_, gold_) +
               sizeof(Impl_::accepted_));

  // @@protoc_insertion_point(copy_constructor:mmorpg.TradeOffer)
}
inline PROTOBUF_NDEBUG_INLINE TradeOffer::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : items_{visibility, arena},
        player_id_(arena),
        _cached_size_{0} {}

inline void TradeOffer::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, gold_),
           0,
           offsetof(Impl_, accepted_) -
               offsetof(Impl_, gold_) +
               sizeof(Impl_::accepted_));
}
TradeOffer::~TradeOffer() {
  // @@protoc_insertion_point(destructor:mmorpg.TradeOffer)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void TradeOffer::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.player_id_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void TradeOffer::Clear() {
// @@protoc_insertion_point(message_clear_start:mmorpg.TradeOffer)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _impl_.player_id_.ClearToEmpty();
  ::memset(&_impl_.gold_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.accepted_) -
      reinterpret_cast<char*>(&_impl_.gold_)) + sizeof(_impl_.accepted_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* TradeOffer::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 1, 35, 2> TradeOffer::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_TradeOffer_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string player_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(TradeOffer, _impl_.player_id_)}},
    // repeated .mmorpg.TradeItem items = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(TradeOffer, _impl_.items_)}},
    // int64 gold = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(TradeOffer, _impl_.gold_), 63>(),
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(TradeOffer, _impl_.gold_)}},
    // bool locked = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(TradeOffer, _impl_.locked_), 63>(),
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(TradeOffer, _impl_.locked_)}},
    // bool accepted = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(TradeOffer, _impl_.accepted_), 63>(),
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(TradeOffer, _impl_.accepted_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string player_id = 1;
    {PROTOBUF_FIELD_OFFSET(TradeOffer, _impl_.player_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated .mmorpg.TradeItem items = 2;
    {PROTOBUF_FIELD_OFFSET(TradeOffer, _impl_.items_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // int64 gold = 3;
    {PROTOBUF_FIELD_OFFSET(TradeOffer, _impl_.gold_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt64)},
    // bool locked = 4;
    {PROTOBUF_FIELD_OFFSET(TradeOffer, _impl_.locked_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool accepted = 5;
    {PROTOBUF_FIELD_OFFSET(TradeOffer, _impl_.accepted_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
  }}, {{
    {::_pbi::TcParser::GetTable<::mmorpg::TradeItem>()},
  }}, {{
    "\21\11\0\0\0\0\0\0"
    "mmorpg.TradeOffer"
    "player_id"
  }},
};

::uint8_t* TradeOffer::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mmorpg.TradeOffer)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string player_id = 1;
  if (!this->_internal_player_id().empty()) {
    const std::string& _s = this->_internal_player_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.TradeOffer.player_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // repeated .mmorpg.TradeItem items = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int64 gold = 3;
  if (this->_internal_gold() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<3>(
            stream, this->_internal_gold(), target);
  }

  // bool locked = 4;
  if (this->_internal_locked() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        4, this->_internal_locked(), target);
  }

  // bool accepted = 5;
  if (this->_internal_accepted() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        5, this->_internal_accepted(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mmorpg.TradeOffer)
  return target;
}

::size_t TradeOffer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mmorpg.TradeOffer)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mmorpg.TradeItem items = 2;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_internal_items()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // string player_id = 1;
  if (!this->_internal_player_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_player_id());
  }

  // int64 gold = 3;
  if (this->_internal_gold() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_gold());
  }

  // bool locked = 4;
  if (this->_internal_locked() != 0) {
    total_size += 2;
  }

  // bool accepted = 5;
  if (this->_internal_accepted() != 0) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData TradeOffer::_class_data_ = {
    TradeOffer::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* TradeOffer::GetClassData() const {
  return &_class_data_;
}

void TradeOffer::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<TradeOffer*>(&to_msg);
  auto& from = static_cast<const TradeOffer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:mmorpg.TradeOffer)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_items()->MergeFrom(
      from._internal_items());
  if (!from._internal_player_id().empty()) {
    _this->_internal_set_player_id(from._internal_player_id());
  }
  if (from._internal_gold() != 0) {
    _this->_internal_set_gold(from._internal_gold());
  }
  if (from._internal_locked() != 0) {
    _this->_internal_set_locked(from._internal_locked());
  }
  if (from._internal_accepted() != 0) {
    _this->_internal_set_accepted(from._internal_accepted());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void TradeOffer::CopyFrom(const TradeOffer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mmorpg.TradeOffer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TradeOffer::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* TradeOffer::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void TradeOffer::InternalSwap(TradeOffer* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.player_id_, &other->_impl_.player_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TradeOffer, _impl_.accepted_)
      + sizeof(TradeOffer::_impl_.accepted_)
      - PROTOBUF_FIELD_OFFSET(TradeOffer, _impl_.gold_)>(
          reinterpret_cast<char*>(&_impl_.gold_),
          reinterpret_cast<char*>(&other->_impl_.gold_));
}

::google::protobuf::Metadata TradeOffer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[19]);
}
// ===================================================================

class TradeItem::_Internal {
 public:
};

TradeItem::TradeItem(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:mmorpg.TradeItem)
}
inline PROTOBUF_NDEBUG_INLINE TradeItem::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : item_id_(arena, from.item_id_),
        _cached_size_{0} {}

TradeItem::TradeItem(
    ::google::protobuf::Arena* arena,
    const TradeItem& from)
    : ::google::protobuf::Message(arena) {
  TradeItem* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, quantity_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, quantity_),
           offsetof(Impl_, inventory_slot_) -
               offsetof(Impl_, quantity_) +
               sizeof(Impl_::inventory_slot_));

  // @@protoc_insertion_point(copy_constructor:mmorpg.TradeItem)
}
inline PROTOBUF_NDEBUG_INLINE TradeItem::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : item_id_(arena),
        _cached_size_{0} {}

inline void TradeItem::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, quantity_),
           0,
           offsetof(Impl_, inventory_slot_) -
               offsetof(Impl_, quantity_) +
               sizeof(Impl_::inventory_slot_));
}
TradeItem::~TradeItem() {
  // @@protoc_insertion_point(destructor:mmorpg.TradeItem)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void TradeItem::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.item_id_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void TradeItem::Clear() {
// @@protoc_insertion_point(message_clear_start:mmorpg.TradeItem)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.item_id_.ClearToEmpty();
  ::memset(&_impl_.quantity_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.inventory_slot_) -
      reinterpret_cast<char*>(&_impl_.quantity_)) + sizeof(_impl_.inventory_slot_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* TradeItem::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 32, 2> TradeItem::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_TradeItem_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string item_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(TradeItem, _impl_.item_id_)}},
    // int32 quantity = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(TradeItem, _impl_.quantity_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(TradeItem, _impl_.quantity_)}},
    // int32 inventory_slot = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(TradeItem, _impl_.inventory_slot_), 63>(),
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(TradeItem, _impl_.inventory_slot_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string item_id = 1;
    {PROTOBUF_FIELD_OFFSET(TradeItem, _impl_.item_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // int32 quantity = 2;
    {PROTOBUF_FIELD_OFFSET(TradeItem, _impl_.quantity_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // int32 inventory_slot = 3;
    {PROTOBUF_FIELD_OFFSET(TradeItem, _impl_.inventory_slot_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
    "\20\7\0\0\0\0\0\0"
    "mmorpg.TradeItem"
    "item_id"
  }},
};

::uint8_t* TradeItem::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mmorpg.TradeItem)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string item_id = 1;
  if (!this->_internal_item_id().empty()) {
    const std::string& _s = this->_internal_item_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.TradeItem.item_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // int32 quantity = 2;
  if (this->_internal_quantity() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<2>(
            stream, this->_internal_quantity(), target);
  }

  // int32 inventory_slot = 3;
  if (this->_internal_inventory_slot() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<3>(
            stream, this->_internal_inventory_slot(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mmorpg.TradeItem)
  return target;
}

::size_t TradeItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mmorpg.TradeItem)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string item_id = 1;
  if (!this->_internal_item_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_item_id());
  }

  // int32 quantity = 2;
  if (this->_internal_quantity() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_quantity());
  }

  // int32 inventory_slot = 3;
  if (this->_internal_inventory_slot() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_inventory_slot());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData TradeItem::_class_data_ = {
    TradeItem::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* TradeItem::GetClassData() const {
  return &_class_data_;
}

void TradeItem::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<TradeItem*>(&to_msg);
  auto& from = static_cast<const TradeItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:mmorpg.TradeItem)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_item_id().empty()) {
    _this->_internal_set_item_id(from._internal_item_id());
  }
  if (from._internal_quantity() != 0) {
    _this->_internal_set_quantity(from._internal_quantity());
  }
  if (from._internal_inventory_slot() != 0) {
    _this->_internal_set_inventory_slot(from._internal_inventory_slot());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void TradeItem::CopyFrom(const TradeItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mmorpg.TradeItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TradeItem::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* TradeItem::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void TradeItem::InternalSwap(TradeItem* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.item_id_, &other->_impl_.item_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TradeItem, _impl_.inventory_slot_)
      + sizeof(TradeItem::_impl_.inventory_slot_)
      - PROTOBUF_FIELD_OFFSET(TradeItem, _impl_.quantity_)>(
          reinterpret_cast<char*>(&_impl_.quantity_),
          reinterpret_cast<char*>(&other->_impl_.quantity_));
}

::google::protobuf::Metadata TradeItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[20]);
}
// ===================================================================

class SkillUseRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<SkillUseRequest>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SkillUseRequest, _impl_._has_bits_);
  static const ::mmorpg::Vector3& target_position(const SkillUseRequest* msg);
  static void set_has_target_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::mmorpg::Vector3& SkillUseRequest::_Internal::target_position(const SkillUseRequest* msg) {
  return *msg->_impl_.target_position_;
}
void SkillUseRequest::clear_target_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.target_position_ != nullptr) _impl_.target_position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
SkillUseRequest::SkillUseRequest(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:mmorpg.SkillUseRequest)
}
inline PROTOBUF_NDEBUG_INLINE SkillUseRequest::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        player_id_(arena, from.player_id_),
        skill_id_(arena, from.skill_id_),
        target_id_(arena, from.target_id_) {}

SkillUseRequest::SkillUseRequest(
    ::google::protobuf::Arena* arena,
    const SkillUseRequest& from)
    : ::google::protobuf::Message(arena) {
  SkillUseRequest* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.target_position_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::mmorpg::Vector3>(arena, *from._impl_.target_position_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:mmorpg.SkillUseRequest)
}
inline PROTOBUF_NDEBUG_INLINE SkillUseRequest::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        player_id_(arena),
        skill_id_(arena),
        target_id_(arena) {}

inline void SkillUseRequest::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.target_position_ = {};
}
SkillUseRequest::~SkillUseRequest() {
  // @@protoc_insertion_point(destructor:mmorpg.SkillUseRequest)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SkillUseRequest::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.player_id_.Destroy();
  _impl_.skill_id_.Destroy();
  _impl_.target_id_.Destroy();
  delete _impl_.target_position_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void SkillUseRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:mmorpg.SkillUseRequest)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.player_id_.ClearToEmpty();
  _impl_.skill_id_.ClearToEmpty();
  _impl_.target_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.target_position_ != nullptr);
    _impl_.target_position_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SkillUseRequest::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 57, 2> SkillUseRequest::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SkillUseRequest, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_SkillUseRequest_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // .mmorpg.Vector3 target_position = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 0, 0, PROTOBUF_FIELD_OFFSET(SkillUseRequest, _impl_.target_position_)}},
    // string player_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(SkillUseRequest, _impl_.player_id_)}},
    // string skill_id = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(SkillUseRequest, _impl_.skill_id_)}},
    // string target_id = 3;
    {::_pbi::TcParser::FastUS1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(SkillUseRequest, _impl_.target_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string player_id = 1;
    {PROTOBUF_FIELD_OFFSET(SkillUseRequest, _impl_.player_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string skill_id = 2;
    {PROTOBUF_FIELD_OFFSET(SkillUseRequest, _impl_.skill_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string target_id = 3;
    {PROTOBUF_FIELD_OFFSET(SkillUseRequest, _impl_.target_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .mmorpg.Vector3 target_position = 4;
    {PROTOBUF_FIELD_OFFSET(SkillUseRequest, _impl_.target_position_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::mmorpg::Vector3>()},
  }}, {{
    "\26\11\10\11\0\0\0\0"
    "mmorpg.SkillUseRequest"
    "player_id"
    "skill_id"
    "target_id"
  }},
};

::uint8_t* SkillUseRequest::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mmorpg.SkillUseRequest)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string player_id = 1;
  if (!this->_internal_player_id().empty()) {
    const std::string& _s = this->_internal_player_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.SkillUseRequest.player_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string skill_id = 2;
  if (!this->_internal_skill_id().empty()) {
    const std::string& _s = this->_internal_skill_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.SkillUseRequest.skill_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string target_id = 3;
  if (!this->_internal_target_id().empty()) {
    const std::string& _s = this->_internal_target_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.SkillUseRequest.target_id");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .mmorpg.Vector3 target_position = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        4, _Internal::target_position(this),
        _Internal::target_position(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mmorpg.SkillUseRequest)
  return target;
}

::size_t SkillUseRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mmorpg.SkillUseRequest)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string player_id = 1;
  if (!this->_internal_player_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_player_id());
  }

  // string skill_id = 2;
  if (!this->_internal_skill_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_skill_id());
  }

  // string target_id = 3;
  if (!this->_internal_target_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_target_id());
  }

  // .mmorpg.Vector3 target_position = 4;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size +=
        1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.target_position_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SkillUseRequest::_class_data_ = {
    SkillUseRequest::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* SkillUseRequest::GetClassData() const {
  return &_class_data_;
}

void SkillUseRequest::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SkillUseRequest*>(&to_msg);
  auto& from = static_cast<const SkillUseRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:mmorpg.SkillUseRequest)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_player_id().empty()) {
    _this->_internal_set_player_id(from._internal_player_id());
  }
  if (!from._internal_skill_id().empty()) {
    _this->_internal_set_skill_id(from._internal_skill_id());
  }
  if (!from._internal_target_id().empty()) {
    _this->_internal_set_target_id(from._internal_target_id());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_target_position()->::mmorpg::Vector3::MergeFrom(
        from._internal_target_position());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SkillUseRequest::CopyFrom(const SkillUseRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mmorpg.SkillUseRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SkillUseRequest::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* SkillUseRequest::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void SkillUseRequest::InternalSwap(SkillUseRequest* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.player_id_, &other->_impl_.player_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.skill_id_, &other->_impl_.skill_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.target_id_, &other->_impl_.target_id_, arena);
  swap(_impl_.target_position_, other->_impl_.target_position_);
}

::google::protobuf::Metadata SkillUseRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[21]);
}
// ===================================================================

class SkillUseResult::_Internal {
 public:
};

SkillUseResult::SkillUseResult(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:mmorpg.SkillUseResult)
}
inline PROTOBUF_NDEBUG_INLINE SkillUseResult::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : effects_{visibility, arena, from.effects_},
        skill_id_(arena, from.skill_id_),
        failure_reason_(arena, from.failure_reason_),
        _cached_size_{0} {}

SkillUseResult::SkillUseResult(
    ::google::protobuf::Arena* arena,
    const SkillUseResult& from)
    : ::google::protobuf::Message(arena) {
  SkillUseResult* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, success_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, success_),
           offsetof(Impl_, cooldown_) -
               offsetof(Impl_, success_) +
               sizeof(Impl_::cooldown_));

  // @@protoc_insertion_point(copy_constructor:mmorpg.SkillUseResult)
}
inline PROTOBUF_NDEBUG_INLINE SkillUseResult::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : effects_{visibility, arena},
        skill_id_(arena),
        failure_reason_(arena),
        _cached_size_{0} {}

inline void SkillUseResult::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, success_),
           0,
           offsetof(Impl_, cooldown_) -
               offsetof(Impl_, success_) +
               sizeof(Impl_::cooldown_));
}
SkillUseResult::~SkillUseResult() {
  // @@protoc_insertion_point(destructor:mmorpg.SkillUseResult)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SkillUseResult::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.skill_id_.Destroy();
  _impl_.failure_reason_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void SkillUseResult::Clear() {
// @@protoc_insertion_point(message_clear_start:mmorpg.SkillUseResult)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.effects_.Clear();
  _impl_.skill_id_.ClearToEmpty();
  _impl_.failure_reason_.ClearToEmpty();
  ::memset(&_impl_.success_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.cooldown_) -
      reinterpret_cast<char*>(&_impl_.success_)) + sizeof(_impl_.cooldown_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SkillUseResult::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 1, 52, 2> SkillUseResult::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_SkillUseResult_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // bool success = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(SkillUseResult, _impl_.success_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(SkillUseResult, _impl_.success_)}},
    // string skill_id = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(SkillUseResult, _impl_.skill_id_)}},
    // float cooldown = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(SkillUseResult, _impl_.cooldown_)}},
    // string failure_reason = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(SkillUseResult, _impl_.failure_reason_)}},
    // repeated .mmorpg.CombatEffect effects = 5;
    {::_pbi::TcParser::FastMtR1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(SkillUseResult, _impl_.effects_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // bool success = 1;
    {PROTOBUF_FIELD_OFFSET(SkillUseResult, _impl_.success_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // string skill_id = 2;
    {PROTOBUF_FIELD_OFFSET(SkillUseResult, _impl_.skill_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // float cooldown = 3;
    {PROTOBUF_FIELD_OFFSET(SkillUseResult, _impl_.cooldown_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // string failure_reason = 4;
    {PROTOBUF_FIELD_OFFSET(SkillUseResult, _impl_.failure_reason_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated .mmorpg.CombatEffect effects = 5;
    {PROTOBUF_FIELD_OFFSET(SkillUseResult, _impl_.effects_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::mmorpg::CombatEffect>()},
  }}, {{
    "\25\0\10\0\16\0\0\0"
    "mmorpg.SkillUseResult"
    "skill_id"
    "failure_reason"
  }},
};

::uint8_t* SkillUseResult::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mmorpg.SkillUseResult)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // bool success = 1;
  if (this->_internal_success() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_success(), target);
  }

  // string skill_id = 2;
  if (!this->_internal_skill_id().empty()) {
    const std::string& _s = this->_internal_skill_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.SkillUseResult.skill_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // float cooldown = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_cooldown = this->_internal_cooldown();
  ::uint32_t raw_cooldown;
  memcpy(&raw_cooldown, &tmp_cooldown, sizeof(tmp_cooldown));
  if (raw_cooldown != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_cooldown(), target);
  }

  // string failure_reason = 4;
  if (!this->_internal_failure_reason().empty()) {
    const std::string& _s = this->_internal_failure_reason();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.SkillUseResult.failure_reason");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // repeated .mmorpg.CombatEffect effects = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_effects_size()); i < n; i++) {
    const auto& repfield = this->_internal_effects().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mmorpg.SkillUseResult)
  return target;
}

::size_t SkillUseResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mmorpg.SkillUseResult)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mmorpg.CombatEffect effects = 5;
  total_size += 1UL * this->_internal_effects_size();
  for (const auto& msg : this->_internal_effects()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // string skill_id = 2;
  if (!this->_internal_skill_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_skill_id());
  }

  // string failure_reason = 4;
  if (!this->_internal_failure_reason().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_failure_reason());
  }

  // bool success = 1;
  if (this->_internal_success() != 0) {
    total_size += 2;
  }

  // float cooldown = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_cooldown = this->_internal_cooldown();
  ::uint32_t raw_cooldown;
  memcpy(&raw_cooldown, &tmp_cooldown, sizeof(tmp_cooldown));
  if (raw_cooldown != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SkillUseResult::_class_data_ = {
    SkillUseResult::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* SkillUseResult::GetClassData() const {
  return &_class_data_;
}

void SkillUseResult::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SkillUseResult*>(&to_msg);
  auto& from = static_cast<const SkillUseResult&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:mmorpg.SkillUseResult)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_effects()->MergeFrom(
      from._internal_effects());
  if (!from._internal_skill_id().empty()) {
    _this->_internal_set_skill_id(from._internal_skill_id());
  }
  if (!from._internal_failure_reason().empty()) {
    _this->_internal_set_failure_reason(from._internal_failure_reason());
  }
  if (from._internal_success() != 0) {
    _this->_internal_set_success(from._internal_success());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_cooldown = from._internal_cooldown();
  ::uint32_t raw_cooldown;
  memcpy(&raw_cooldown, &tmp_cooldown, sizeof(tmp_cooldown));
  if (raw_cooldown != 0) {
    _this->_internal_set_cooldown(from._internal_cooldown());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SkillUseResult::CopyFrom(const SkillUseResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mmorpg.SkillUseResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SkillUseResult::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* SkillUseResult::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void SkillUseResult::InternalSwap(SkillUseResult* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.effects_.InternalSwap(&other->_impl_.effects_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.skill_id_, &other->_impl_.skill_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.failure_reason_, &other->_impl_.failure_reason_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SkillUseResult, _impl_.cooldown_)
      + sizeof(SkillUseResult::_impl_.cooldown_)
      - PROTOBUF_FIELD_OFFSET(SkillUseResult, _impl_.success_)>(
          reinterpret_cast<char*>(&_impl_.success_),
          reinterpret_cast<char*>(&other->_impl_.success_));
}

::google::protobuf::Metadata SkillUseResult::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[22]);
}
// ===================================================================

class LootDropped::_Internal {
 public:
  using HasBits = decltype(std::declval<LootDropped>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(LootDropped, _impl_._has_bits_);
  static const ::mmorpg::Vector3& position(const LootDropped* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::google::protobuf::Timestamp& expires_at(const LootDropped* msg);
  static void set_has_expires_at(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::mmorpg::Vector3& LootDropped::_Internal::position(const LootDropped* msg) {
  return *msg->_impl_.position_;
}
const ::google::protobuf::Timestamp& LootDropped::_Internal::expires_at(const LootDropped* msg) {
  return *msg->_impl_.expires_at_;
}
void LootDropped::clear_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void LootDropped::clear_expires_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.expires_at_ != nullptr) _impl_.expires_at_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
LootDropped::LootDropped(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:mmorpg.LootDropped)
}
inline PROTOBUF_NDEBUG_INLINE LootDropped::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        items_{visibility, arena, from.items_},
        allowed_looters_{visibility, arena, from.allowed_looters_},
        entity_id_(arena, from.entity_id_),
        loot_id_(arena, from.loot_id_) {}

LootDropped::LootDropped(
    ::google::protobuf::Arena* arena,
    const LootDropped& from)
    : ::google::protobuf::Message(arena) {
  LootDropped* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.position_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::mmorpg::Vector3>(arena, *from._impl_.position_)
                : nullptr;
  _impl_.expires_at_ = (cached_has_bits & 0x00000002u)
                ? CreateMaybeMessage<::google::protobuf::Timestamp>(arena, *from._impl_.expires_at_)
                : nullptr;

  // @@protoc_insertion_point(copy_constructor:mmorpg.LootDropped)
}
inline PROTOBUF_NDEBUG_INLINE LootDropped::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        items_{visibility, arena},
        allowed_looters_{visibility, arena},
        entity_id_(arena),
        loot_id_(arena) {}

inline void LootDropped::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, position_),
           0,
           offsetof(Impl_, expires_at_) -
               offsetof(Impl_, position_) +
               sizeof(Impl_::expires_at_));
}
LootDropped::~LootDropped() {
  // @@protoc_insertion_point(destructor:mmorpg.LootDropped)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void LootDropped::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.entity_id_.Destroy();
  _impl_.loot_id_.Destroy();
  delete _impl_.position_;
  delete _impl_.expires_at_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void LootDropped::Clear() {
// @@protoc_insertion_point(message_clear_start:mmorpg.LootDropped)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.items_.Clear();
  _impl_.allowed_looters_.Clear();
  _impl_.entity_id_.ClearToEmpty();
  _impl_.loot_id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.expires_at_ != nullptr);
      _impl_.expires_at_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* LootDropped::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 3, 58, 2> LootDropped::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LootDropped, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_LootDropped_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string entity_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(LootDropped, _impl_.entity_id_)}},
    // string loot_id = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(LootDropped, _impl_.loot_id_)}},
    // .mmorpg.Vector3 position = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(LootDropped, _impl_.position_)}},
    // repeated .mmorpg.LootItem items = 4;
    {::_pbi::TcParser::FastMtR1,
     {34, 63, 1, PROTOBUF_FIELD_OFFSET(LootDropped, _impl_.items_)}},
    // repeated string allowed_looters = 5;
    {::_pbi::TcParser::FastUR1,
     {42, 63, 0, PROTOBUF_FIELD_OFFSET(LootDropped, _impl_.allowed_looters_)}},
    // .google.protobuf.Timestamp expires_at = 6;
    {::_pbi::TcParser::FastMtS1,
     {50, 1, 2, PROTOBUF_FIELD_OFFSET(LootDropped, _impl_.expires_at_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string entity_id = 1;
    {PROTOBUF_FIELD_OFFSET(LootDropped, _impl_.entity_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string loot_id = 2;
    {PROTOBUF_FIELD_OFFSET(LootDropped, _impl_.loot_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .mmorpg.Vector3 position = 3;
    {PROTOBUF_FIELD_OFFSET(LootDropped, _impl_.position_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .mmorpg.LootItem items = 4;
    {PROTOBUF_FIELD_OFFSET(LootDropped, _impl_.items_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated string allowed_looters = 5;
    {PROTOBUF_FIELD_OFFSET(LootDropped, _impl_.allowed_looters_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
    // .google.protobuf.Timestamp expires_at = 6;
    {PROTOBUF_FIELD_OFFSET(LootDropped, _impl_.expires_at_), _Internal::kHasBitsOffset + 1, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::mmorpg::Vector3>()},
    {::_pbi::TcParser::GetTable<::mmorpg::LootItem>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
  }}, {{
    "\22\11\7\0\0\17\0\0"
    "mmorpg.LootDropped"
    "entity_id"
    "loot_id"
    "allowed_looters"
  }},
};

::uint8_t* LootDropped::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mmorpg.LootDropped)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string entity_id = 1;
  if (!this->_internal_entity_id().empty()) {
    const std::string& _s = this->_internal_entity_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.LootDropped.entity_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string loot_id = 2;
  if (!this->_internal_loot_id().empty()) {
    const std::string& _s = this->_internal_loot_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.LootDropped.loot_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .mmorpg.Vector3 position = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        3, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // repeated .mmorpg.LootItem items = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_items().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string allowed_looters = 5;
  for (int i = 0, n = this->_internal_allowed_looters_size(); i < n; ++i) {
    const auto& s = this->_internal_allowed_looters().Get(i);
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.LootDropped.allowed_looters");
    target = stream->WriteString(5, s, target);
  }

  // .google.protobuf.Timestamp expires_at = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        6, _Internal::expires_at(this),
        _Internal::expires_at(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mmorpg.LootDropped)
  return target;
}

::size_t LootDropped::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mmorpg.LootDropped)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .mmorpg.LootItem items = 4;
  total_size += 1UL * this->_internal_items_size();
  for (const auto& msg : this->_internal_items()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated string allowed_looters = 5;
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_allowed_looters().size());
  for (int i = 0, n = _internal_allowed_looters().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_allowed_looters().Get(i));
  }
  // string entity_id = 1;
  if (!this->_internal_entity_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_entity_id());
  }

  // string loot_id = 2;
  if (!this->_internal_loot_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_loot_id());
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .mmorpg.Vector3 position = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.position_);
    }

    // .google.protobuf.Timestamp expires_at = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.expires_at_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData LootDropped::_class_data_ = {
    LootDropped::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* LootDropped::GetClassData() const {
  return &_class_data_;
}

void LootDropped::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<LootDropped*>(&to_msg);
  auto& from = static_cast<const LootDropped&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:mmorpg.LootDropped)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_items()->MergeFrom(
      from._internal_items());
  _this->_internal_mutable_allowed_looters()->MergeFrom(from._internal_allowed_looters());
  if (!from._internal_entity_id().empty()) {
    _this->_internal_set_entity_id(from._internal_entity_id());
  }
  if (!from._internal_loot_id().empty()) {
    _this->_internal_set_loot_id(from._internal_loot_id());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_position()->::mmorpg::Vector3::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_expires_at()->::google::protobuf::Timestamp::MergeFrom(
          from._internal_expires_at());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LootDropped::CopyFrom(const LootDropped& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mmorpg.LootDropped)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool LootDropped::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* LootDropped::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void LootDropped::InternalSwap(LootDropped* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.items_.InternalSwap(&other->_impl_.items_);
  _impl_.allowed_looters_.InternalSwap(&other->_impl_.allowed_looters_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.entity_id_, &other->_impl_.entity_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.loot_id_, &other->_impl_.loot_id_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LootDropped, _impl_.expires_at_)
      + sizeof(LootDropped::_impl_.expires_at_)
      - PROTOBUF_FIELD_OFFSET(LootDropped, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::google::protobuf::Metadata LootDropped::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[23]);
}
// ===================================================================

class LootItem::_Internal {
 public:
  using HasBits = decltype(std::declval<LootItem>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(LootItem, _impl_._has_bits_);
  static const ::mmorpg::Item& item(const LootItem* msg);
  static void set_has_item(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::mmorpg::Item& LootItem::_Internal::item(const LootItem* msg) {
  return *msg->_impl_.item_;
}
LootItem::LootItem(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:mmorpg.LootItem)
}
inline PROTOBUF_NDEBUG_INLINE LootItem::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

LootItem::LootItem(
    ::google::protobuf::Arena* arena,
    const LootItem& from)
    : ::google::protobuf::Message(arena) {
  LootItem* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.item_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::mmorpg::Item>(arena, *from._impl_.item_)
                : nullptr;
  _impl_.quantity_ = from._impl_.quantity_;

  // @@protoc_insertion_point(copy_constructor:mmorpg.LootItem)
}
inline PROTOBUF_NDEBUG_INLINE LootItem::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void LootItem::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, item_),
           0,
           offsetof(Impl_, quantity_) -
               offsetof(Impl_, item_) +
               sizeof(Impl_::quantity_));
}
LootItem::~LootItem() {
  // @@protoc_insertion_point(destructor:mmorpg.LootItem)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void LootItem::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.item_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void LootItem::Clear() {
// @@protoc_insertion_point(message_clear_start:mmorpg.LootItem)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.item_ != nullptr);
    _impl_.item_->Clear();
  }
  _impl_.quantity_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* LootItem::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2> LootItem::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(LootItem, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_LootItem_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // int32 quantity = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(LootItem, _impl_.quantity_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(LootItem, _impl_.quantity_)}},
    // .mmorpg.Item item = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(LootItem, _impl_.item_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .mmorpg.Item item = 1;
    {PROTOBUF_FIELD_OFFSET(LootItem, _impl_.item_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // int32 quantity = 2;
    {PROTOBUF_FIELD_OFFSET(LootItem, _impl_.quantity_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
  }}, {{
    {::_pbi::TcParser::GetTable<::mmorpg::Item>()},
  }}, {{
  }},
};

::uint8_t* LootItem::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mmorpg.LootItem)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .mmorpg.Item item = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        1, _Internal::item(this),
        _Internal::item(this).GetCachedSize(), target, stream);
  }

  // int32 quantity = 2;
  if (this->_internal_quantity() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<2>(
            stream, this->_internal_quantity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mmorpg.LootItem)
  return target;
}

::size_t LootItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mmorpg.LootItem)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .mmorpg.Item item = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size +=
        1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.item_);
  }

  // int32 quantity = 2;
  if (this->_internal_quantity() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_quantity());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData LootItem::_class_data_ = {
    LootItem::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* LootItem::GetClassData() const {
  return &_class_data_;
}

void LootItem::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<LootItem*>(&to_msg);
  auto& from = static_cast<const LootItem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:mmorpg.LootItem)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_item()->::mmorpg::Item::MergeFrom(
        from._internal_item());
  }
  if (from._internal_quantity() != 0) {
    _this->_internal_set_quantity(from._internal_quantity());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void LootItem::CopyFrom(const LootItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mmorpg.LootItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool LootItem::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* LootItem::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void LootItem::InternalSwap(LootItem* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LootItem, _impl_.quantity_)
      + sizeof(LootItem::_impl_.quantity_)
      - PROTOBUF_FIELD_OFFSET(LootItem, _impl_.item_)>(
          reinterpret_cast<char*>(&_impl_.item_),
          reinterpret_cast<char*>(&other->_impl_.item_));
}

::google::protobuf::Metadata LootItem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[24]);
}
// ===================================================================

CurrencyUpdate_CurrenciesEntry_DoNotUse::CurrencyUpdate_CurrenciesEntry_DoNotUse() {}
CurrencyUpdate_CurrenciesEntry_DoNotUse::CurrencyUpdate_CurrenciesEntry_DoNotUse(::google::protobuf::Arena* arena)
    : SuperType(arena) {}
::google::protobuf::Metadata CurrencyUpdate_CurrenciesEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[25]);
}
// ===================================================================

class CurrencyUpdate::_Internal {
 public:
};

CurrencyUpdate::CurrencyUpdate(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:mmorpg.CurrencyUpdate)
}
inline PROTOBUF_NDEBUG_INLINE CurrencyUpdate::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : currencies_{visibility, arena, from.currencies_},
        player_id_(arena, from.player_id_),
        _cached_size_{0} {}

CurrencyUpdate::CurrencyUpdate(
    ::google::protobuf::Arena* arena,
    const CurrencyUpdate& from)
    : ::google::protobuf::Message(arena) {
  CurrencyUpdate* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);

  // @@protoc_insertion_point(copy_constructor:mmorpg.CurrencyUpdate)
}
inline PROTOBUF_NDEBUG_INLINE CurrencyUpdate::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : currencies_{visibility, arena},
        player_id_(arena),
        _cached_size_{0} {}

inline void CurrencyUpdate::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
CurrencyUpdate::~CurrencyUpdate() {
  // @@protoc_insertion_point(destructor:mmorpg.CurrencyUpdate)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void CurrencyUpdate::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.player_id_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void CurrencyUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:mmorpg.CurrencyUpdate)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.currencies_.Clear();
  _impl_.player_id_.ClearToEmpty();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* CurrencyUpdate::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 2, 1, 49, 2> CurrencyUpdate::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_CurrencyUpdate_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // string player_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(CurrencyUpdate, _impl_.player_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string player_id = 1;
    {PROTOBUF_FIELD_OFFSET(CurrencyUpdate, _impl_.player_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // map<string, int64> currencies = 2;
    {PROTOBUF_FIELD_OFFSET(CurrencyUpdate, _impl_.currencies_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
  }}, {{
    {::_pbi::TcParser::GetMapAuxInfo<
        decltype(CurrencyUpdate()._impl_.currencies_)>(
        1, 0, 0, 9,
        3)},
  }}, {{
    "\25\11\12\0\0\0\0\0"
    "mmorpg.CurrencyUpdate"
    "player_id"
    "currencies"
  }},
};

::uint8_t* CurrencyUpdate::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mmorpg.CurrencyUpdate)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string player_id = 1;
  if (!this->_internal_player_id().empty()) {
    const std::string& _s = this->_internal_player_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.CurrencyUpdate.player_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // map<string, int64> currencies = 2;
  if (!_internal_currencies().empty()) {
    using MapType = ::google::protobuf::Map<std::string, ::int64_t>;
    using WireHelper = _pbi::MapEntryFuncs<std::string, ::int64_t,
                                   _pbi::WireFormatLite::TYPE_STRING,
                                   _pbi::WireFormatLite::TYPE_INT64>;
    const auto& field = _internal_currencies();

    if (stream->IsSerializationDeterministic() && field.size() > 1) {
      for (const auto& entry : ::google::protobuf::internal::MapSorterPtr<MapType>(field)) {
        target = WireHelper::InternalSerialize(
            2, entry.first, entry.second, target, stream);
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.CurrencyUpdate.currencies");
      }
    } else {
      for (const auto& entry : field) {
        target = WireHelper::InternalSerialize(
            2, entry.first, entry.second, target, stream);
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.CurrencyUpdate.currencies");
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mmorpg.CurrencyUpdate)
  return target;
}

::size_t CurrencyUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mmorpg.CurrencyUpdate)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, int64> currencies = 2;
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_currencies_size());
  for (const auto& entry : _internal_currencies()) {
    total_size += _pbi::MapEntryFuncs<std::string, ::int64_t,
                                   _pbi::WireFormatLite::TYPE_STRING,
                                   _pbi::WireFormatLite::TYPE_INT64>::ByteSizeLong(entry.first, entry.second);
  }
  // string player_id = 1;
  if (!this->_internal_player_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_player_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData CurrencyUpdate::_class_data_ = {
    CurrencyUpdate::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* CurrencyUpdate::GetClassData() const {
  return &_class_data_;
}

void CurrencyUpdate::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<CurrencyUpdate*>(&to_msg);
  auto& from = static_cast<const CurrencyUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:mmorpg.CurrencyUpdate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.currencies_.MergeFrom(from._impl_.currencies_);
  if (!from._internal_player_id().empty()) {
    _this->_internal_set_player_id(from._internal_player_id());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CurrencyUpdate::CopyFrom(const CurrencyUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mmorpg.CurrencyUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool CurrencyUpdate::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* CurrencyUpdate::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void CurrencyUpdate::InternalSwap(CurrencyUpdate* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.currencies_.InternalSwap(&other->_impl_.currencies_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.player_id_, &other->_impl_.player_id_, arena);
}

::google::protobuf::Metadata CurrencyUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[26]);
}
// ===================================================================

class AchievementUnlocked::_Internal {
 public:
  using HasBits = decltype(std::declval<AchievementUnlocked>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AchievementUnlocked, _impl_._has_bits_);
  static const ::google::protobuf::Timestamp& unlocked_at(const AchievementUnlocked* msg);
  static void set_has_unlocked_at(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::google::protobuf::Timestamp& AchievementUnlocked::_Internal::unlocked_at(const AchievementUnlocked* msg) {
  return *msg->_impl_.unlocked_at_;
}
void AchievementUnlocked::clear_unlocked_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.unlocked_at_ != nullptr) _impl_.unlocked_at_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
AchievementUnlocked::AchievementUnlocked(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:mmorpg.AchievementUnlocked)
}
inline PROTOBUF_NDEBUG_INLINE AchievementUnlocked::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        player_id_(arena, from.player_id_),
        achievement_id_(arena, from.achievement_id_),
        achievement_name_(arena, from.achievement_name_),
        description_(arena, from.description_) {}

AchievementUnlocked::AchievementUnlocked(
    ::google::protobuf::Arena* arena,
    const AchievementUnlocked& from)
    : ::google::protobuf::Message(arena) {
  AchievementUnlocked* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.unlocked_at_ = (cached_has_bits & 0x00000001u)
                ? CreateMaybeMessage<::google::protobuf::Timestamp>(arena, *from._impl_.unlocked_at_)
                : nullptr;
  _impl_.points_ = from._impl_.points_;

  // @@protoc_insertion_point(copy_constructor:mmorpg.AchievementUnlocked)
}
inline PROTOBUF_NDEBUG_INLINE AchievementUnlocked::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        player_id_(arena),
        achievement_id_(arena),
        achievement_name_(arena),
        description_(arena) {}

inline void AchievementUnlocked::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, unlocked_at_),
           0,
           offsetof(Impl_, points_) -
               offsetof(Impl_, unlocked_at_) +
               sizeof(Impl_::points_));
}
AchievementUnlocked::~AchievementUnlocked() {
  // @@protoc_insertion_point(destructor:mmorpg.AchievementUnlocked)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AchievementUnlocked::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.player_id_.Destroy();
  _impl_.achievement_id_.Destroy();
  _impl_.achievement_name_.Destroy();
  _impl_.description_.Destroy();
  delete _impl_.unlocked_at_;
  _impl_.~Impl_();
}

PROTOBUF_NOINLINE void AchievementUnlocked::Clear() {
// @@protoc_insertion_point(message_clear_start:mmorpg.AchievementUnlocked)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.player_id_.ClearToEmpty();
  _impl_.achievement_id_.ClearToEmpty();
  _impl_.achievement_name_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.unlocked_at_ != nullptr);
    _impl_.unlocked_at_->Clear();
  }
  _impl_.points_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* AchievementUnlocked::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 6, 1, 85, 2> AchievementUnlocked::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AchievementUnlocked, _impl_._has_bits_),
    0, // no _extensions_
    6, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967232,  // skipmap
    offsetof(decltype(_table_), field_entries),
    6,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_AchievementUnlocked_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string player_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(AchievementUnlocked, _impl_.player_id_)}},
    // string achievement_id = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(AchievementUnlocked, _impl_.achievement_id_)}},
    // string achievement_name = 3;
    {::_pbi::TcParser::FastUS1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(AchievementUnlocked, _impl_.achievement_name_)}},
    // string description = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(AchievementUnlocked, _impl_.description_)}},
    // int32 points = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AchievementUnlocked, _impl_.points_), 63>(),
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(AchievementUnlocked, _impl_.points_)}},
    // .google.protobuf.Timestamp unlocked_at = 6;
    {::_pbi::TcParser::FastMtS1,
     {50, 0, 0, PROTOBUF_FIELD_OFFSET(AchievementUnlocked, _impl_.unlocked_at_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string player_id = 1;
    {PROTOBUF_FIELD_OFFSET(AchievementUnlocked, _impl_.player_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string achievement_id = 2;
    {PROTOBUF_FIELD_OFFSET(AchievementUnlocked, _impl_.achievement_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string achievement_name = 3;
    {PROTOBUF_FIELD_OFFSET(AchievementUnlocked, _impl_.achievement_name_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string description = 4;
    {PROTOBUF_FIELD_OFFSET(AchievementUnlocked, _impl_.description_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // int32 points = 5;
    {PROTOBUF_FIELD_OFFSET(AchievementUnlocked, _impl_.points_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // .google.protobuf.Timestamp unlocked_at = 6;
    {PROTOBUF_FIELD_OFFSET(AchievementUnlocked, _impl_.unlocked_at_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
  }}, {{
    "\32\11\16\20\13\0\0\0"
    "mmorpg.AchievementUnlocked"
    "player_id"
    "achievement_id"
    "achievement_name"
    "description"
  }},
};

::uint8_t* AchievementUnlocked::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:mmorpg.AchievementUnlocked)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string player_id = 1;
  if (!this->_internal_player_id().empty()) {
    const std::string& _s = this->_internal_player_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.AchievementUnlocked.player_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // string achievement_id = 2;
  if (!this->_internal_achievement_id().empty()) {
    const std::string& _s = this->_internal_achievement_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.AchievementUnlocked.achievement_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // string achievement_name = 3;
  if (!this->_internal_achievement_name().empty()) {
    const std::string& _s = this->_internal_achievement_name();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.AchievementUnlocked.achievement_name");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // string description = 4;
  if (!this->_internal_description().empty()) {
    const std::string& _s = this->_internal_description();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "mmorpg.AchievementUnlocked.description");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // int32 points = 5;
  if (this->_internal_points() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<5>(
            stream, this->_internal_points(), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // .google.protobuf.Timestamp unlocked_at = 6;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        6, _Internal::unlocked_at(this),
        _Internal::unlocked_at(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mmorpg.AchievementUnlocked)
  return target;
}

::size_t AchievementUnlocked::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:mmorpg.AchievementUnlocked)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string player_id = 1;
  if (!this->_internal_player_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_player_id());
  }

  // string achievement_id = 2;
  if (!this->_internal_achievement_id().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_achievement_id());
  }

  // string achievement_name = 3;
  if (!this->_internal_achievement_name().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_achievement_name());
  }

  // string description = 4;
  if (!this->_internal_description().empty()) {
    total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                    this->_internal_description());
  }

  // .google.protobuf.Timestamp unlocked_at = 6;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size +=
        1 + ::google::protobuf::internal::WireFormatLite::MessageSize(*_impl_.unlocked_at_);
  }

  // int32 points = 5;
  if (this->_internal_points() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_points());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData AchievementUnlocked::_class_data_ = {
    AchievementUnlocked::MergeImpl,
    nullptr,  // OnDemandRegisterArenaDtor
};
const ::google::protobuf::Message::ClassData* AchievementUnlocked::GetClassData() const {
  return &_class_data_;
}

void AchievementUnlocked::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<AchievementUnlocked*>(&to_msg);
  auto& from = static_cast<const AchievementUnlocked&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:mmorpg.AchievementUnlocked)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_player_id().empty()) {
    _this->_internal_set_player_id(from._internal_player_id());
  }
  if (!from._internal_achievement_id().empty()) {
    _this->_internal_set_achievement_id(from._internal_achievement_id());
  }
  if (!from._internal_achievement_name().empty()) {
    _this->_internal_set_achievement_name(from._internal_achievement_name());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_unlocked_at()->::google::protobuf::Timestamp::MergeFrom(
        from._internal_unlocked_at());
  }
  if (from._internal_points() != 0) {
    _this->_internal_set_points(from._internal_points());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AchievementUnlocked::CopyFrom(const AchievementUnlocked& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mmorpg.AchievementUnlocked)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool AchievementUnlocked::IsInitialized() const {
  return true;
}

::_pbi::CachedSize* AchievementUnlocked::AccessCachedSize() const {
  return &_impl_._cached_size_;
}
void AchievementUnlocked::InternalSwap(AchievementUnlocked* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.player_id_, &other->_impl_.player_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.achievement_id_, &other->_impl_.achievement_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.achievement_name_, &other->_impl_.achievement_name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.description_, &other->_impl_.description_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AchievementUnlocked, _impl_.points_)
      + sizeof(AchievementUnlocked::_impl_.points_)
      - PROTOBUF_FIELD_OFFSET(AchievementUnlocked, _impl_.unlocked_at_)>(
          reinterpret_cast<char*>(&_impl_.unlocked_at_),
          reinterpret_cast<char*>(&other->_impl_.unlocked_at_));
}

::google::protobuf::Metadata AchievementUnlocked::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_game_2eproto_getter, &descriptor_table_game_2eproto_once,
      file_level_metadata_game_2eproto[27]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace mmorpg
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
