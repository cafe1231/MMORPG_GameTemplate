// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: world.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_world_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_world_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field_inl.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
#include "base.pb.h"
#include "character.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_world_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_world_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_world_2eproto;
namespace mmorpg {
class AreaUpdate;
struct AreaUpdateDefaultTypeInternal;
extern AreaUpdateDefaultTypeInternal _AreaUpdate_default_instance_;
class DamageEvent;
struct DamageEventDefaultTypeInternal;
extern DamageEventDefaultTypeInternal _DamageEvent_default_instance_;
class DeathEvent;
struct DeathEventDefaultTypeInternal;
extern DeathEventDefaultTypeInternal _DeathEvent_default_instance_;
class EmoteEvent;
struct EmoteEventDefaultTypeInternal;
extern EmoteEventDefaultTypeInternal _EmoteEvent_default_instance_;
class EntityDespawn;
struct EntityDespawnDefaultTypeInternal;
extern EntityDespawnDefaultTypeInternal _EntityDespawn_default_instance_;
class EntityEvent;
struct EntityEventDefaultTypeInternal;
extern EntityEventDefaultTypeInternal _EntityEvent_default_instance_;
class EntitySpawn;
struct EntitySpawnDefaultTypeInternal;
extern EntitySpawnDefaultTypeInternal _EntitySpawn_default_instance_;
class HealEvent;
struct HealEventDefaultTypeInternal;
extern HealEventDefaultTypeInternal _HealEvent_default_instance_;
class InterestUpdateRequest;
struct InterestUpdateRequestDefaultTypeInternal;
extern InterestUpdateRequestDefaultTypeInternal _InterestUpdateRequest_default_instance_;
class LevelUpEvent;
struct LevelUpEventDefaultTypeInternal;
extern LevelUpEventDefaultTypeInternal _LevelUpEvent_default_instance_;
class NPCState;
struct NPCStateDefaultTypeInternal;
extern NPCStateDefaultTypeInternal _NPCState_default_instance_;
class PlayerPositionUpdate;
struct PlayerPositionUpdateDefaultTypeInternal;
extern PlayerPositionUpdateDefaultTypeInternal _PlayerPositionUpdate_default_instance_;
class PlayerState;
struct PlayerStateDefaultTypeInternal;
extern PlayerStateDefaultTypeInternal _PlayerState_default_instance_;
class PlayerState_VisibleEquipmentEntry_DoNotUse;
struct PlayerState_VisibleEquipmentEntry_DoNotUseDefaultTypeInternal;
extern PlayerState_VisibleEquipmentEntry_DoNotUseDefaultTypeInternal _PlayerState_VisibleEquipmentEntry_DoNotUse_default_instance_;
class SoundEvent;
struct SoundEventDefaultTypeInternal;
extern SoundEventDefaultTypeInternal _SoundEvent_default_instance_;
class StatusEffect;
struct StatusEffectDefaultTypeInternal;
extern StatusEffectDefaultTypeInternal _StatusEffect_default_instance_;
class VisualEffectEvent;
struct VisualEffectEventDefaultTypeInternal;
extern VisualEffectEventDefaultTypeInternal _VisualEffectEvent_default_instance_;
class WorldEnterRequest;
struct WorldEnterRequestDefaultTypeInternal;
extern WorldEnterRequestDefaultTypeInternal _WorldEnterRequest_default_instance_;
class WorldEnterResponse;
struct WorldEnterResponseDefaultTypeInternal;
extern WorldEnterResponseDefaultTypeInternal _WorldEnterResponse_default_instance_;
class WorldLeaveRequest;
struct WorldLeaveRequestDefaultTypeInternal;
extern WorldLeaveRequestDefaultTypeInternal _WorldLeaveRequest_default_instance_;
class WorldLeaveResponse;
struct WorldLeaveResponseDefaultTypeInternal;
extern WorldLeaveResponseDefaultTypeInternal _WorldLeaveResponse_default_instance_;
class WorldObject;
struct WorldObjectDefaultTypeInternal;
extern WorldObjectDefaultTypeInternal _WorldObject_default_instance_;
class WorldObject_PropertiesEntry_DoNotUse;
struct WorldObject_PropertiesEntry_DoNotUseDefaultTypeInternal;
extern WorldObject_PropertiesEntry_DoNotUseDefaultTypeInternal _WorldObject_PropertiesEntry_DoNotUse_default_instance_;
class ZoneChangeRequest;
struct ZoneChangeRequestDefaultTypeInternal;
extern ZoneChangeRequestDefaultTypeInternal _ZoneChangeRequest_default_instance_;
class ZoneChangeResponse;
struct ZoneChangeResponseDefaultTypeInternal;
extern ZoneChangeResponseDefaultTypeInternal _ZoneChangeResponse_default_instance_;
}  // namespace mmorpg
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace mmorpg {
enum EntityType : int {
  ENTITY_TYPE_UNSPECIFIED = 0,
  ENTITY_TYPE_PLAYER = 1,
  ENTITY_TYPE_NPC = 2,
  ENTITY_TYPE_OBJECT = 3,
  ENTITY_TYPE_ITEM = 4,
  ENTITY_TYPE_PROJECTILE = 5,
  EntityType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EntityType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool EntityType_IsValid(int value);
extern const uint32_t EntityType_internal_data_[];
constexpr EntityType EntityType_MIN = static_cast<EntityType>(0);
constexpr EntityType EntityType_MAX = static_cast<EntityType>(5);
constexpr int EntityType_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
EntityType_descriptor();
template <typename T>
const std::string& EntityType_Name(T value) {
  static_assert(std::is_same<T, EntityType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EntityType_Name().");
  return EntityType_Name(static_cast<EntityType>(value));
}
template <>
inline const std::string& EntityType_Name(EntityType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EntityType_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool EntityType_Parse(absl::string_view name, EntityType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EntityType>(
      EntityType_descriptor(), name, value);
}
enum DamageType : int {
  DAMAGE_TYPE_UNSPECIFIED = 0,
  DAMAGE_TYPE_PHYSICAL = 1,
  DAMAGE_TYPE_MAGICAL = 2,
  DAMAGE_TYPE_FIRE = 3,
  DAMAGE_TYPE_FROST = 4,
  DAMAGE_TYPE_LIGHTNING = 5,
  DAMAGE_TYPE_POISON = 6,
  DAMAGE_TYPE_HOLY = 7,
  DAMAGE_TYPE_SHADOW = 8,
  DamageType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DamageType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DamageType_IsValid(int value);
extern const uint32_t DamageType_internal_data_[];
constexpr DamageType DamageType_MIN = static_cast<DamageType>(0);
constexpr DamageType DamageType_MAX = static_cast<DamageType>(8);
constexpr int DamageType_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
DamageType_descriptor();
template <typename T>
const std::string& DamageType_Name(T value) {
  static_assert(std::is_same<T, DamageType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DamageType_Name().");
  return DamageType_Name(static_cast<DamageType>(value));
}
template <>
inline const std::string& DamageType_Name(DamageType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DamageType_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool DamageType_Parse(absl::string_view name, DamageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DamageType>(
      DamageType_descriptor(), name, value);
}
enum CombatState : int {
  COMBAT_STATE_UNSPECIFIED = 0,
  COMBAT_STATE_OUT_OF_COMBAT = 1,
  COMBAT_STATE_IN_COMBAT = 2,
  COMBAT_STATE_EVADING = 3,
  COMBAT_STATE_DEAD = 4,
  CombatState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CombatState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CombatState_IsValid(int value);
extern const uint32_t CombatState_internal_data_[];
constexpr CombatState CombatState_MIN = static_cast<CombatState>(0);
constexpr CombatState CombatState_MAX = static_cast<CombatState>(4);
constexpr int CombatState_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
CombatState_descriptor();
template <typename T>
const std::string& CombatState_Name(T value) {
  static_assert(std::is_same<T, CombatState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CombatState_Name().");
  return CombatState_Name(static_cast<CombatState>(value));
}
template <>
inline const std::string& CombatState_Name(CombatState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CombatState_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool CombatState_Parse(absl::string_view name, CombatState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CombatState>(
      CombatState_descriptor(), name, value);
}
enum NPCBehaviorState : int {
  NPC_BEHAVIOR_UNSPECIFIED = 0,
  NPC_BEHAVIOR_IDLE = 1,
  NPC_BEHAVIOR_PATROLLING = 2,
  NPC_BEHAVIOR_CHASING = 3,
  NPC_BEHAVIOR_ATTACKING = 4,
  NPC_BEHAVIOR_FLEEING = 5,
  NPC_BEHAVIOR_RETURNING = 6,
  NPC_BEHAVIOR_INTERACTING = 7,
  NPCBehaviorState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NPCBehaviorState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NPCBehaviorState_IsValid(int value);
extern const uint32_t NPCBehaviorState_internal_data_[];
constexpr NPCBehaviorState NPCBehaviorState_MIN = static_cast<NPCBehaviorState>(0);
constexpr NPCBehaviorState NPCBehaviorState_MAX = static_cast<NPCBehaviorState>(7);
constexpr int NPCBehaviorState_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
NPCBehaviorState_descriptor();
template <typename T>
const std::string& NPCBehaviorState_Name(T value) {
  static_assert(std::is_same<T, NPCBehaviorState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to NPCBehaviorState_Name().");
  return NPCBehaviorState_Name(static_cast<NPCBehaviorState>(value));
}
template <>
inline const std::string& NPCBehaviorState_Name(NPCBehaviorState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NPCBehaviorState_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool NPCBehaviorState_Parse(absl::string_view name, NPCBehaviorState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NPCBehaviorState>(
      NPCBehaviorState_descriptor(), name, value);
}
enum MovementFlag : int {
  MOVEMENT_FLAG_NONE = 0,
  MOVEMENT_FLAG_FORWARD = 1,
  MOVEMENT_FLAG_BACKWARD = 2,
  MOVEMENT_FLAG_LEFT = 4,
  MOVEMENT_FLAG_RIGHT = 8,
  MOVEMENT_FLAG_JUMPING = 16,
  MOVEMENT_FLAG_FALLING = 32,
  MOVEMENT_FLAG_SWIMMING = 64,
  MOVEMENT_FLAG_FLYING = 128,
  MOVEMENT_FLAG_SPRINTING = 256,
  MOVEMENT_FLAG_SNEAKING = 512,
  MovementFlag_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MovementFlag_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MovementFlag_IsValid(int value);
extern const uint32_t MovementFlag_internal_data_[];
constexpr MovementFlag MovementFlag_MIN = static_cast<MovementFlag>(0);
constexpr MovementFlag MovementFlag_MAX = static_cast<MovementFlag>(512);
constexpr int MovementFlag_ARRAYSIZE = 512 + 1;
const ::google::protobuf::EnumDescriptor*
MovementFlag_descriptor();
template <typename T>
const std::string& MovementFlag_Name(T value) {
  static_assert(std::is_same<T, MovementFlag>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MovementFlag_Name().");
  return ::google::protobuf::internal::NameOfEnum(MovementFlag_descriptor(), value);
}
inline bool MovementFlag_Parse(absl::string_view name, MovementFlag* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MovementFlag>(
      MovementFlag_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class WorldObject_PropertiesEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          WorldObject_PropertiesEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      WorldObject_PropertiesEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  WorldObject_PropertiesEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WorldObject_PropertiesEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit WorldObject_PropertiesEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const WorldObject_PropertiesEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const WorldObject_PropertiesEntry_DoNotUse*>(
        &_WorldObject_PropertiesEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "mmorpg.WorldObject.PropertiesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "mmorpg.WorldObject.PropertiesEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class WorldLeaveResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.WorldLeaveResponse) */ {
 public:
  inline WorldLeaveResponse() : WorldLeaveResponse(nullptr) {}
  ~WorldLeaveResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WorldLeaveResponse(::google::protobuf::internal::ConstantInitialized);

  inline WorldLeaveResponse(const WorldLeaveResponse& from)
      : WorldLeaveResponse(nullptr, from) {}
  WorldLeaveResponse(WorldLeaveResponse&& from) noexcept
    : WorldLeaveResponse() {
    *this = ::std::move(from);
  }

  inline WorldLeaveResponse& operator=(const WorldLeaveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorldLeaveResponse& operator=(WorldLeaveResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorldLeaveResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorldLeaveResponse* internal_default_instance() {
    return reinterpret_cast<const WorldLeaveResponse*>(
               &_WorldLeaveResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(WorldLeaveResponse& a, WorldLeaveResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WorldLeaveResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorldLeaveResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorldLeaveResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorldLeaveResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorldLeaveResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WorldLeaveResponse& from) {
    WorldLeaveResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WorldLeaveResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.WorldLeaveResponse";
  }
  protected:
  explicit WorldLeaveResponse(::google::protobuf::Arena* arena);
  WorldLeaveResponse(::google::protobuf::Arena* arena, const WorldLeaveResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.WorldLeaveResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    bool success_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_world_2eproto;
};// -------------------------------------------------------------------

class WorldLeaveRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.WorldLeaveRequest) */ {
 public:
  inline WorldLeaveRequest() : WorldLeaveRequest(nullptr) {}
  ~WorldLeaveRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WorldLeaveRequest(::google::protobuf::internal::ConstantInitialized);

  inline WorldLeaveRequest(const WorldLeaveRequest& from)
      : WorldLeaveRequest(nullptr, from) {}
  WorldLeaveRequest(WorldLeaveRequest&& from) noexcept
    : WorldLeaveRequest() {
    *this = ::std::move(from);
  }

  inline WorldLeaveRequest& operator=(const WorldLeaveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorldLeaveRequest& operator=(WorldLeaveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorldLeaveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorldLeaveRequest* internal_default_instance() {
    return reinterpret_cast<const WorldLeaveRequest*>(
               &_WorldLeaveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(WorldLeaveRequest& a, WorldLeaveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WorldLeaveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorldLeaveRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorldLeaveRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorldLeaveRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorldLeaveRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WorldLeaveRequest& from) {
    WorldLeaveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WorldLeaveRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.WorldLeaveRequest";
  }
  protected:
  explicit WorldLeaveRequest(::google::protobuf::Arena* arena);
  WorldLeaveRequest(::google::protobuf::Arena* arena, const WorldLeaveRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kReasonFieldNumber = 2,
  };
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // string reason = 2;
  void clear_reason() ;
  const std::string& reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* value);

  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(
      const std::string& value);
  std::string* _internal_mutable_reason();

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.WorldLeaveRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::google::protobuf::internal::ArenaStringPtr reason_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_world_2eproto;
};// -------------------------------------------------------------------

class StatusEffect final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.StatusEffect) */ {
 public:
  inline StatusEffect() : StatusEffect(nullptr) {}
  ~StatusEffect() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StatusEffect(::google::protobuf::internal::ConstantInitialized);

  inline StatusEffect(const StatusEffect& from)
      : StatusEffect(nullptr, from) {}
  StatusEffect(StatusEffect&& from) noexcept
    : StatusEffect() {
    *this = ::std::move(from);
  }

  inline StatusEffect& operator=(const StatusEffect& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusEffect& operator=(StatusEffect&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusEffect& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusEffect* internal_default_instance() {
    return reinterpret_cast<const StatusEffect*>(
               &_StatusEffect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(StatusEffect& a, StatusEffect& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusEffect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusEffect* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusEffect* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusEffect>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StatusEffect& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StatusEffect& from) {
    StatusEffect::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StatusEffect* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.StatusEffect";
  }
  protected:
  explicit StatusEffect(::google::protobuf::Arena* arena);
  StatusEffect(::google::protobuf::Arena* arena, const StatusEffect& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEffectIdFieldNumber = 1,
    kEffectTypeFieldNumber = 2,
    kIconIdFieldNumber = 3,
    kSourceIdFieldNumber = 6,
    kDurationFieldNumber = 4,
    kStacksFieldNumber = 5,
  };
  // string effect_id = 1;
  void clear_effect_id() ;
  const std::string& effect_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_effect_id(Arg_&& arg, Args_... args);
  std::string* mutable_effect_id();
  PROTOBUF_NODISCARD std::string* release_effect_id();
  void set_allocated_effect_id(std::string* value);

  private:
  const std::string& _internal_effect_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_effect_id(
      const std::string& value);
  std::string* _internal_mutable_effect_id();

  public:
  // string effect_type = 2;
  void clear_effect_type() ;
  const std::string& effect_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_effect_type(Arg_&& arg, Args_... args);
  std::string* mutable_effect_type();
  PROTOBUF_NODISCARD std::string* release_effect_type();
  void set_allocated_effect_type(std::string* value);

  private:
  const std::string& _internal_effect_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_effect_type(
      const std::string& value);
  std::string* _internal_mutable_effect_type();

  public:
  // string icon_id = 3;
  void clear_icon_id() ;
  const std::string& icon_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_icon_id(Arg_&& arg, Args_... args);
  std::string* mutable_icon_id();
  PROTOBUF_NODISCARD std::string* release_icon_id();
  void set_allocated_icon_id(std::string* value);

  private:
  const std::string& _internal_icon_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_icon_id(
      const std::string& value);
  std::string* _internal_mutable_icon_id();

  public:
  // string source_id = 6;
  void clear_source_id() ;
  const std::string& source_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source_id(Arg_&& arg, Args_... args);
  std::string* mutable_source_id();
  PROTOBUF_NODISCARD std::string* release_source_id();
  void set_allocated_source_id(std::string* value);

  private:
  const std::string& _internal_source_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_id(
      const std::string& value);
  std::string* _internal_mutable_source_id();

  public:
  // float duration = 4;
  void clear_duration() ;
  float duration() const;
  void set_duration(float value);

  private:
  float _internal_duration() const;
  void _internal_set_duration(float value);

  public:
  // int32 stacks = 5;
  void clear_stacks() ;
  ::int32_t stacks() const;
  void set_stacks(::int32_t value);

  private:
  ::int32_t _internal_stacks() const;
  void _internal_set_stacks(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.StatusEffect)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      64, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr effect_id_;
    ::google::protobuf::internal::ArenaStringPtr effect_type_;
    ::google::protobuf::internal::ArenaStringPtr icon_id_;
    ::google::protobuf::internal::ArenaStringPtr source_id_;
    float duration_;
    ::int32_t stacks_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_world_2eproto;
};// -------------------------------------------------------------------

class PlayerState_VisibleEquipmentEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<
          PlayerState_VisibleEquipmentEntry_DoNotUse, std::string, std::string,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
          ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType = ::google::protobuf::internal::MapEntry<
      PlayerState_VisibleEquipmentEntry_DoNotUse, std::string, std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  PlayerState_VisibleEquipmentEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerState_VisibleEquipmentEntry_DoNotUse(
      ::google::protobuf::internal::ConstantInitialized);
  explicit PlayerState_VisibleEquipmentEntry_DoNotUse(::google::protobuf::Arena* arena);
  static const PlayerState_VisibleEquipmentEntry_DoNotUse* internal_default_instance() {
    return reinterpret_cast<const PlayerState_VisibleEquipmentEntry_DoNotUse*>(
        &_PlayerState_VisibleEquipmentEntry_DoNotUse_default_instance_);
  }
  static bool ValidateKey(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "mmorpg.PlayerState.VisibleEquipmentEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::google::protobuf::internal::WireFormatLite::PARSE, "mmorpg.PlayerState.VisibleEquipmentEntry.value");
 }
  ::google::protobuf::Metadata GetMetadata() const final;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class LevelUpEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.LevelUpEvent) */ {
 public:
  inline LevelUpEvent() : LevelUpEvent(nullptr) {}
  ~LevelUpEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LevelUpEvent(::google::protobuf::internal::ConstantInitialized);

  inline LevelUpEvent(const LevelUpEvent& from)
      : LevelUpEvent(nullptr, from) {}
  LevelUpEvent(LevelUpEvent&& from) noexcept
    : LevelUpEvent() {
    *this = ::std::move(from);
  }

  inline LevelUpEvent& operator=(const LevelUpEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LevelUpEvent& operator=(LevelUpEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LevelUpEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const LevelUpEvent* internal_default_instance() {
    return reinterpret_cast<const LevelUpEvent*>(
               &_LevelUpEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(LevelUpEvent& a, LevelUpEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(LevelUpEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LevelUpEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LevelUpEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LevelUpEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LevelUpEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LevelUpEvent& from) {
    LevelUpEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LevelUpEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.LevelUpEvent";
  }
  protected:
  explicit LevelUpEvent(::google::protobuf::Arena* arena);
  LevelUpEvent(::google::protobuf::Arena* arena, const LevelUpEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kNewLevelFieldNumber = 2,
    kStatPointsGainedFieldNumber = 3,
    kSkillPointsGainedFieldNumber = 4,
  };
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // int32 new_level = 2;
  void clear_new_level() ;
  ::int32_t new_level() const;
  void set_new_level(::int32_t value);

  private:
  ::int32_t _internal_new_level() const;
  void _internal_set_new_level(::int32_t value);

  public:
  // int32 stat_points_gained = 3;
  void clear_stat_points_gained() ;
  ::int32_t stat_points_gained() const;
  void set_stat_points_gained(::int32_t value);

  private:
  ::int32_t _internal_stat_points_gained() const;
  void _internal_set_stat_points_gained(::int32_t value);

  public:
  // int32 skill_points_gained = 4;
  void clear_skill_points_gained() ;
  ::int32_t skill_points_gained() const;
  void set_skill_points_gained(::int32_t value);

  private:
  ::int32_t _internal_skill_points_gained() const;
  void _internal_set_skill_points_gained(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.LevelUpEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      37, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::int32_t new_level_;
    ::int32_t stat_points_gained_;
    ::int32_t skill_points_gained_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_world_2eproto;
};// -------------------------------------------------------------------

class InterestUpdateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.InterestUpdateRequest) */ {
 public:
  inline InterestUpdateRequest() : InterestUpdateRequest(nullptr) {}
  ~InterestUpdateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InterestUpdateRequest(::google::protobuf::internal::ConstantInitialized);

  inline InterestUpdateRequest(const InterestUpdateRequest& from)
      : InterestUpdateRequest(nullptr, from) {}
  InterestUpdateRequest(InterestUpdateRequest&& from) noexcept
    : InterestUpdateRequest() {
    *this = ::std::move(from);
  }

  inline InterestUpdateRequest& operator=(const InterestUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterestUpdateRequest& operator=(InterestUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterestUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InterestUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const InterestUpdateRequest*>(
               &_InterestUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(InterestUpdateRequest& a, InterestUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InterestUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterestUpdateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterestUpdateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterestUpdateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InterestUpdateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InterestUpdateRequest& from) {
    InterestUpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InterestUpdateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.InterestUpdateRequest";
  }
  protected:
  explicit InterestUpdateRequest(::google::protobuf::Arena* arena);
  InterestUpdateRequest(::google::protobuf::Arena* arena, const InterestUpdateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInterestFiltersFieldNumber = 3,
    kPlayerIdFieldNumber = 1,
    kViewDistanceFieldNumber = 2,
  };
  // repeated string interest_filters = 3;
  int interest_filters_size() const;
  private:
  int _internal_interest_filters_size() const;

  public:
  void clear_interest_filters() ;
  const std::string& interest_filters(int index) const;
  std::string* mutable_interest_filters(int index);
  void set_interest_filters(int index, const std::string& value);
  void set_interest_filters(int index, std::string&& value);
  void set_interest_filters(int index, const char* value);
  void set_interest_filters(int index, const char* value, std::size_t size);
  void set_interest_filters(int index, absl::string_view value);
  std::string* add_interest_filters();
  void add_interest_filters(const std::string& value);
  void add_interest_filters(std::string&& value);
  void add_interest_filters(const char* value);
  void add_interest_filters(const char* value, std::size_t size);
  void add_interest_filters(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& interest_filters() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_interest_filters();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_interest_filters() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_interest_filters();

  public:
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // float view_distance = 2;
  void clear_view_distance() ;
  float view_distance() const;
  void set_view_distance(float value);

  private:
  float _internal_view_distance() const;
  void _internal_set_view_distance(float value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.InterestUpdateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      62, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> interest_filters_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    float view_distance_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_world_2eproto;
};// -------------------------------------------------------------------

class HealEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.HealEvent) */ {
 public:
  inline HealEvent() : HealEvent(nullptr) {}
  ~HealEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HealEvent(::google::protobuf::internal::ConstantInitialized);

  inline HealEvent(const HealEvent& from)
      : HealEvent(nullptr, from) {}
  HealEvent(HealEvent&& from) noexcept
    : HealEvent() {
    *this = ::std::move(from);
  }

  inline HealEvent& operator=(const HealEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealEvent& operator=(HealEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealEvent* internal_default_instance() {
    return reinterpret_cast<const HealEvent*>(
               &_HealEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(HealEvent& a, HealEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(HealEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HealEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HealEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HealEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const HealEvent& from) {
    HealEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HealEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.HealEvent";
  }
  protected:
  explicit HealEvent(::google::protobuf::Arena* arena);
  HealEvent(::google::protobuf::Arena* arena, const HealEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIdFieldNumber = 1,
    kTargetIdFieldNumber = 2,
    kHealTypeFieldNumber = 4,
    kHealAmountFieldNumber = 3,
    kIsCriticalFieldNumber = 5,
  };
  // string source_id = 1;
  void clear_source_id() ;
  const std::string& source_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source_id(Arg_&& arg, Args_... args);
  std::string* mutable_source_id();
  PROTOBUF_NODISCARD std::string* release_source_id();
  void set_allocated_source_id(std::string* value);

  private:
  const std::string& _internal_source_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_id(
      const std::string& value);
  std::string* _internal_mutable_source_id();

  public:
  // string target_id = 2;
  void clear_target_id() ;
  const std::string& target_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_id(Arg_&& arg, Args_... args);
  std::string* mutable_target_id();
  PROTOBUF_NODISCARD std::string* release_target_id();
  void set_allocated_target_id(std::string* value);

  private:
  const std::string& _internal_target_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_id(
      const std::string& value);
  std::string* _internal_mutable_target_id();

  public:
  // string heal_type = 4;
  void clear_heal_type() ;
  const std::string& heal_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_heal_type(Arg_&& arg, Args_... args);
  std::string* mutable_heal_type();
  PROTOBUF_NODISCARD std::string* release_heal_type();
  void set_allocated_heal_type(std::string* value);

  private:
  const std::string& _internal_heal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_heal_type(
      const std::string& value);
  std::string* _internal_mutable_heal_type();

  public:
  // int32 heal_amount = 3;
  void clear_heal_amount() ;
  ::int32_t heal_amount() const;
  void set_heal_amount(::int32_t value);

  private:
  ::int32_t _internal_heal_amount() const;
  void _internal_set_heal_amount(::int32_t value);

  public:
  // bool is_critical = 5;
  void clear_is_critical() ;
  bool is_critical() const;
  void set_is_critical(bool value);

  private:
  bool _internal_is_critical() const;
  void _internal_set_is_critical(bool value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.HealEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      52, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr source_id_;
    ::google::protobuf::internal::ArenaStringPtr target_id_;
    ::google::protobuf::internal::ArenaStringPtr heal_type_;
    ::int32_t heal_amount_;
    bool is_critical_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_world_2eproto;
};// -------------------------------------------------------------------

class EntityDespawn final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.EntityDespawn) */ {
 public:
  inline EntityDespawn() : EntityDespawn(nullptr) {}
  ~EntityDespawn() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EntityDespawn(::google::protobuf::internal::ConstantInitialized);

  inline EntityDespawn(const EntityDespawn& from)
      : EntityDespawn(nullptr, from) {}
  EntityDespawn(EntityDespawn&& from) noexcept
    : EntityDespawn() {
    *this = ::std::move(from);
  }

  inline EntityDespawn& operator=(const EntityDespawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityDespawn& operator=(EntityDespawn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntityDespawn& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntityDespawn* internal_default_instance() {
    return reinterpret_cast<const EntityDespawn*>(
               &_EntityDespawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(EntityDespawn& a, EntityDespawn& b) {
    a.Swap(&b);
  }
  inline void Swap(EntityDespawn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityDespawn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntityDespawn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EntityDespawn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EntityDespawn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EntityDespawn& from) {
    EntityDespawn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EntityDespawn* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.EntityDespawn";
  }
  protected:
  explicit EntityDespawn(::google::protobuf::Arena* arena);
  EntityDespawn(::google::protobuf::Arena* arena, const EntityDespawn& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityIdFieldNumber = 1,
    kReasonFieldNumber = 3,
    kEntityTypeFieldNumber = 2,
  };
  // string entity_id = 1;
  void clear_entity_id() ;
  const std::string& entity_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  std::string* mutable_entity_id();
  PROTOBUF_NODISCARD std::string* release_entity_id();
  void set_allocated_entity_id(std::string* value);

  private:
  const std::string& _internal_entity_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(
      const std::string& value);
  std::string* _internal_mutable_entity_id();

  public:
  // string reason = 3;
  void clear_reason() ;
  const std::string& reason() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_reason(Arg_&& arg, Args_... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* value);

  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(
      const std::string& value);
  std::string* _internal_mutable_reason();

  public:
  // .mmorpg.EntityType entity_type = 2;
  void clear_entity_type() ;
  ::mmorpg::EntityType entity_type() const;
  void set_entity_type(::mmorpg::EntityType value);

  private:
  ::mmorpg::EntityType _internal_entity_type() const;
  void _internal_set_entity_type(::mmorpg::EntityType value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.EntityDespawn)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    ::google::protobuf::internal::ArenaStringPtr reason_;
    int entity_type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_world_2eproto;
};// -------------------------------------------------------------------

class EmoteEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.EmoteEvent) */ {
 public:
  inline EmoteEvent() : EmoteEvent(nullptr) {}
  ~EmoteEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EmoteEvent(::google::protobuf::internal::ConstantInitialized);

  inline EmoteEvent(const EmoteEvent& from)
      : EmoteEvent(nullptr, from) {}
  EmoteEvent(EmoteEvent&& from) noexcept
    : EmoteEvent() {
    *this = ::std::move(from);
  }

  inline EmoteEvent& operator=(const EmoteEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmoteEvent& operator=(EmoteEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmoteEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmoteEvent* internal_default_instance() {
    return reinterpret_cast<const EmoteEvent*>(
               &_EmoteEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(EmoteEvent& a, EmoteEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(EmoteEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmoteEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmoteEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmoteEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EmoteEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EmoteEvent& from) {
    EmoteEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EmoteEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.EmoteEvent";
  }
  protected:
  explicit EmoteEvent(::google::protobuf::Arena* arena);
  EmoteEvent(::google::protobuf::Arena* arena, const EmoteEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityIdFieldNumber = 1,
    kEmoteIdFieldNumber = 2,
    kTargetIdFieldNumber = 3,
  };
  // string entity_id = 1;
  void clear_entity_id() ;
  const std::string& entity_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  std::string* mutable_entity_id();
  PROTOBUF_NODISCARD std::string* release_entity_id();
  void set_allocated_entity_id(std::string* value);

  private:
  const std::string& _internal_entity_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(
      const std::string& value);
  std::string* _internal_mutable_entity_id();

  public:
  // string emote_id = 2;
  void clear_emote_id() ;
  const std::string& emote_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_emote_id(Arg_&& arg, Args_... args);
  std::string* mutable_emote_id();
  PROTOBUF_NODISCARD std::string* release_emote_id();
  void set_allocated_emote_id(std::string* value);

  private:
  const std::string& _internal_emote_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_emote_id(
      const std::string& value);
  std::string* _internal_mutable_emote_id();

  public:
  // string target_id = 3;
  void clear_target_id() ;
  const std::string& target_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_id(Arg_&& arg, Args_... args);
  std::string* mutable_target_id();
  PROTOBUF_NODISCARD std::string* release_target_id();
  void set_allocated_target_id(std::string* value);

  private:
  const std::string& _internal_target_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_id(
      const std::string& value);
  std::string* _internal_mutable_target_id();

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.EmoteEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      52, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    ::google::protobuf::internal::ArenaStringPtr emote_id_;
    ::google::protobuf::internal::ArenaStringPtr target_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_world_2eproto;
};// -------------------------------------------------------------------

class DamageEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.DamageEvent) */ {
 public:
  inline DamageEvent() : DamageEvent(nullptr) {}
  ~DamageEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DamageEvent(::google::protobuf::internal::ConstantInitialized);

  inline DamageEvent(const DamageEvent& from)
      : DamageEvent(nullptr, from) {}
  DamageEvent(DamageEvent&& from) noexcept
    : DamageEvent() {
    *this = ::std::move(from);
  }

  inline DamageEvent& operator=(const DamageEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DamageEvent& operator=(DamageEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DamageEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const DamageEvent* internal_default_instance() {
    return reinterpret_cast<const DamageEvent*>(
               &_DamageEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DamageEvent& a, DamageEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(DamageEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DamageEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DamageEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DamageEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DamageEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DamageEvent& from) {
    DamageEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DamageEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.DamageEvent";
  }
  protected:
  explicit DamageEvent(::google::protobuf::Arena* arena);
  DamageEvent(::google::protobuf::Arena* arena, const DamageEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIdFieldNumber = 1,
    kTargetIdFieldNumber = 2,
    kDamageFieldNumber = 3,
    kDamageTypeFieldNumber = 4,
    kIsCriticalFieldNumber = 5,
    kIsBlockedFieldNumber = 6,
    kIsDodgedFieldNumber = 7,
  };
  // string source_id = 1;
  void clear_source_id() ;
  const std::string& source_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source_id(Arg_&& arg, Args_... args);
  std::string* mutable_source_id();
  PROTOBUF_NODISCARD std::string* release_source_id();
  void set_allocated_source_id(std::string* value);

  private:
  const std::string& _internal_source_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_id(
      const std::string& value);
  std::string* _internal_mutable_source_id();

  public:
  // string target_id = 2;
  void clear_target_id() ;
  const std::string& target_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_id(Arg_&& arg, Args_... args);
  std::string* mutable_target_id();
  PROTOBUF_NODISCARD std::string* release_target_id();
  void set_allocated_target_id(std::string* value);

  private:
  const std::string& _internal_target_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_id(
      const std::string& value);
  std::string* _internal_mutable_target_id();

  public:
  // int32 damage = 3;
  void clear_damage() ;
  ::int32_t damage() const;
  void set_damage(::int32_t value);

  private:
  ::int32_t _internal_damage() const;
  void _internal_set_damage(::int32_t value);

  public:
  // .mmorpg.DamageType damage_type = 4;
  void clear_damage_type() ;
  ::mmorpg::DamageType damage_type() const;
  void set_damage_type(::mmorpg::DamageType value);

  private:
  ::mmorpg::DamageType _internal_damage_type() const;
  void _internal_set_damage_type(::mmorpg::DamageType value);

  public:
  // bool is_critical = 5;
  void clear_is_critical() ;
  bool is_critical() const;
  void set_is_critical(bool value);

  private:
  bool _internal_is_critical() const;
  void _internal_set_is_critical(bool value);

  public:
  // bool is_blocked = 6;
  void clear_is_blocked() ;
  bool is_blocked() const;
  void set_is_blocked(bool value);

  private:
  bool _internal_is_blocked() const;
  void _internal_set_is_blocked(bool value);

  public:
  // bool is_dodged = 7;
  void clear_is_dodged() ;
  bool is_dodged() const;
  void set_is_dodged(bool value);

  private:
  bool _internal_is_dodged() const;
  void _internal_set_is_dodged(bool value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.DamageEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr source_id_;
    ::google::protobuf::internal::ArenaStringPtr target_id_;
    ::int32_t damage_;
    int damage_type_;
    bool is_critical_;
    bool is_blocked_;
    bool is_dodged_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_world_2eproto;
};// -------------------------------------------------------------------

class ZoneChangeResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.ZoneChangeResponse) */ {
 public:
  inline ZoneChangeResponse() : ZoneChangeResponse(nullptr) {}
  ~ZoneChangeResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ZoneChangeResponse(::google::protobuf::internal::ConstantInitialized);

  inline ZoneChangeResponse(const ZoneChangeResponse& from)
      : ZoneChangeResponse(nullptr, from) {}
  ZoneChangeResponse(ZoneChangeResponse&& from) noexcept
    : ZoneChangeResponse() {
    *this = ::std::move(from);
  }

  inline ZoneChangeResponse& operator=(const ZoneChangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ZoneChangeResponse& operator=(ZoneChangeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ZoneChangeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ZoneChangeResponse* internal_default_instance() {
    return reinterpret_cast<const ZoneChangeResponse*>(
               &_ZoneChangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ZoneChangeResponse& a, ZoneChangeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ZoneChangeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ZoneChangeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ZoneChangeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ZoneChangeResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ZoneChangeResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ZoneChangeResponse& from) {
    ZoneChangeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ZoneChangeResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.ZoneChangeResponse";
  }
  protected:
  explicit ZoneChangeResponse(::google::protobuf::Arena* arena);
  ZoneChangeResponse(::google::protobuf::Arena* arena, const ZoneChangeResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewZoneIdFieldNumber = 2,
    kWorldServerUrlFieldNumber = 3,
    kWorldTokenFieldNumber = 4,
    kErrorMessageFieldNumber = 6,
    kSpawnTransformFieldNumber = 5,
    kSuccessFieldNumber = 1,
    kErrorCodeFieldNumber = 7,
  };
  // string new_zone_id = 2;
  void clear_new_zone_id() ;
  const std::string& new_zone_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_new_zone_id(Arg_&& arg, Args_... args);
  std::string* mutable_new_zone_id();
  PROTOBUF_NODISCARD std::string* release_new_zone_id();
  void set_allocated_new_zone_id(std::string* value);

  private:
  const std::string& _internal_new_zone_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_zone_id(
      const std::string& value);
  std::string* _internal_mutable_new_zone_id();

  public:
  // string world_server_url = 3;
  void clear_world_server_url() ;
  const std::string& world_server_url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_world_server_url(Arg_&& arg, Args_... args);
  std::string* mutable_world_server_url();
  PROTOBUF_NODISCARD std::string* release_world_server_url();
  void set_allocated_world_server_url(std::string* value);

  private:
  const std::string& _internal_world_server_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_world_server_url(
      const std::string& value);
  std::string* _internal_mutable_world_server_url();

  public:
  // string world_token = 4;
  void clear_world_token() ;
  const std::string& world_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_world_token(Arg_&& arg, Args_... args);
  std::string* mutable_world_token();
  PROTOBUF_NODISCARD std::string* release_world_token();
  void set_allocated_world_token(std::string* value);

  private:
  const std::string& _internal_world_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_world_token(
      const std::string& value);
  std::string* _internal_mutable_world_token();

  public:
  // string error_message = 6;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // .mmorpg.Transform spawn_transform = 5;
  bool has_spawn_transform() const;
  void clear_spawn_transform() ;
  const ::mmorpg::Transform& spawn_transform() const;
  PROTOBUF_NODISCARD ::mmorpg::Transform* release_spawn_transform();
  ::mmorpg::Transform* mutable_spawn_transform();
  void set_allocated_spawn_transform(::mmorpg::Transform* value);
  void unsafe_arena_set_allocated_spawn_transform(::mmorpg::Transform* value);
  ::mmorpg::Transform* unsafe_arena_release_spawn_transform();

  private:
  const ::mmorpg::Transform& _internal_spawn_transform() const;
  ::mmorpg::Transform* _internal_mutable_spawn_transform();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // .mmorpg.ErrorCode error_code = 7;
  void clear_error_code() ;
  ::mmorpg::ErrorCode error_code() const;
  void set_error_code(::mmorpg::ErrorCode value);

  private:
  ::mmorpg::ErrorCode _internal_error_code() const;
  void _internal_set_error_code(::mmorpg::ErrorCode value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.ZoneChangeResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      85, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr new_zone_id_;
    ::google::protobuf::internal::ArenaStringPtr world_server_url_;
    ::google::protobuf::internal::ArenaStringPtr world_token_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    ::mmorpg::Transform* spawn_transform_;
    bool success_;
    int error_code_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_world_2eproto;
};// -------------------------------------------------------------------

class ZoneChangeRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.ZoneChangeRequest) */ {
 public:
  inline ZoneChangeRequest() : ZoneChangeRequest(nullptr) {}
  ~ZoneChangeRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ZoneChangeRequest(::google::protobuf::internal::ConstantInitialized);

  inline ZoneChangeRequest(const ZoneChangeRequest& from)
      : ZoneChangeRequest(nullptr, from) {}
  ZoneChangeRequest(ZoneChangeRequest&& from) noexcept
    : ZoneChangeRequest() {
    *this = ::std::move(from);
  }

  inline ZoneChangeRequest& operator=(const ZoneChangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ZoneChangeRequest& operator=(ZoneChangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ZoneChangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ZoneChangeRequest* internal_default_instance() {
    return reinterpret_cast<const ZoneChangeRequest*>(
               &_ZoneChangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ZoneChangeRequest& a, ZoneChangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ZoneChangeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ZoneChangeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ZoneChangeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ZoneChangeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ZoneChangeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ZoneChangeRequest& from) {
    ZoneChangeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ZoneChangeRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.ZoneChangeRequest";
  }
  protected:
  explicit ZoneChangeRequest(::google::protobuf::Arena* arena);
  ZoneChangeRequest(::google::protobuf::Arena* arena, const ZoneChangeRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kTargetZoneIdFieldNumber = 2,
    kTargetTransformFieldNumber = 3,
  };
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // string target_zone_id = 2;
  void clear_target_zone_id() ;
  const std::string& target_zone_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_zone_id(Arg_&& arg, Args_... args);
  std::string* mutable_target_zone_id();
  PROTOBUF_NODISCARD std::string* release_target_zone_id();
  void set_allocated_target_zone_id(std::string* value);

  private:
  const std::string& _internal_target_zone_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_zone_id(
      const std::string& value);
  std::string* _internal_mutable_target_zone_id();

  public:
  // .mmorpg.Transform target_transform = 3;
  bool has_target_transform() const;
  void clear_target_transform() ;
  const ::mmorpg::Transform& target_transform() const;
  PROTOBUF_NODISCARD ::mmorpg::Transform* release_target_transform();
  ::mmorpg::Transform* mutable_target_transform();
  void set_allocated_target_transform(::mmorpg::Transform* value);
  void unsafe_arena_set_allocated_target_transform(::mmorpg::Transform* value);
  ::mmorpg::Transform* unsafe_arena_release_target_transform();

  private:
  const ::mmorpg::Transform& _internal_target_transform() const;
  ::mmorpg::Transform* _internal_mutable_target_transform();

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.ZoneChangeRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      56, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::google::protobuf::internal::ArenaStringPtr target_zone_id_;
    ::mmorpg::Transform* target_transform_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_world_2eproto;
};// -------------------------------------------------------------------

class WorldObject final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.WorldObject) */ {
 public:
  inline WorldObject() : WorldObject(nullptr) {}
  ~WorldObject() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WorldObject(::google::protobuf::internal::ConstantInitialized);

  inline WorldObject(const WorldObject& from)
      : WorldObject(nullptr, from) {}
  WorldObject(WorldObject&& from) noexcept
    : WorldObject() {
    *this = ::std::move(from);
  }

  inline WorldObject& operator=(const WorldObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorldObject& operator=(WorldObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorldObject& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorldObject* internal_default_instance() {
    return reinterpret_cast<const WorldObject*>(
               &_WorldObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(WorldObject& a, WorldObject& b) {
    a.Swap(&b);
  }
  inline void Swap(WorldObject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorldObject* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorldObject* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorldObject>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorldObject& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WorldObject& from) {
    WorldObject::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WorldObject* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.WorldObject";
  }
  protected:
  explicit WorldObject(::google::protobuf::Arena* arena);
  WorldObject(::google::protobuf::Arena* arena, const WorldObject& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 7,
    kAllowedLootersFieldNumber = 9,
    kObjectIdFieldNumber = 1,
    kObjectTypeFieldNumber = 2,
    kInteractionTypeFieldNumber = 5,
    kTransformFieldNumber = 3,
    kInteractionRangeFieldNumber = 6,
    kIsInteractableFieldNumber = 4,
    kIsLootableFieldNumber = 8,
  };
  // map<string, string> properties = 7;
  int properties_size() const;
  private:
  int _internal_properties_size() const;

  public:
  void clear_properties() ;
  const ::google::protobuf::Map<std::string, std::string>& properties() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_properties();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_properties() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_properties();

  public:
  // repeated string allowed_looters = 9;
  int allowed_looters_size() const;
  private:
  int _internal_allowed_looters_size() const;

  public:
  void clear_allowed_looters() ;
  const std::string& allowed_looters(int index) const;
  std::string* mutable_allowed_looters(int index);
  void set_allowed_looters(int index, const std::string& value);
  void set_allowed_looters(int index, std::string&& value);
  void set_allowed_looters(int index, const char* value);
  void set_allowed_looters(int index, const char* value, std::size_t size);
  void set_allowed_looters(int index, absl::string_view value);
  std::string* add_allowed_looters();
  void add_allowed_looters(const std::string& value);
  void add_allowed_looters(std::string&& value);
  void add_allowed_looters(const char* value);
  void add_allowed_looters(const char* value, std::size_t size);
  void add_allowed_looters(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& allowed_looters() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_allowed_looters();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_allowed_looters() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_allowed_looters();

  public:
  // string object_id = 1;
  void clear_object_id() ;
  const std::string& object_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_object_id(Arg_&& arg, Args_... args);
  std::string* mutable_object_id();
  PROTOBUF_NODISCARD std::string* release_object_id();
  void set_allocated_object_id(std::string* value);

  private:
  const std::string& _internal_object_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object_id(
      const std::string& value);
  std::string* _internal_mutable_object_id();

  public:
  // string object_type = 2;
  void clear_object_type() ;
  const std::string& object_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_object_type(Arg_&& arg, Args_... args);
  std::string* mutable_object_type();
  PROTOBUF_NODISCARD std::string* release_object_type();
  void set_allocated_object_type(std::string* value);

  private:
  const std::string& _internal_object_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_object_type(
      const std::string& value);
  std::string* _internal_mutable_object_type();

  public:
  // string interaction_type = 5;
  void clear_interaction_type() ;
  const std::string& interaction_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_interaction_type(Arg_&& arg, Args_... args);
  std::string* mutable_interaction_type();
  PROTOBUF_NODISCARD std::string* release_interaction_type();
  void set_allocated_interaction_type(std::string* value);

  private:
  const std::string& _internal_interaction_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interaction_type(
      const std::string& value);
  std::string* _internal_mutable_interaction_type();

  public:
  // .mmorpg.Transform transform = 3;
  bool has_transform() const;
  void clear_transform() ;
  const ::mmorpg::Transform& transform() const;
  PROTOBUF_NODISCARD ::mmorpg::Transform* release_transform();
  ::mmorpg::Transform* mutable_transform();
  void set_allocated_transform(::mmorpg::Transform* value);
  void unsafe_arena_set_allocated_transform(::mmorpg::Transform* value);
  ::mmorpg::Transform* unsafe_arena_release_transform();

  private:
  const ::mmorpg::Transform& _internal_transform() const;
  ::mmorpg::Transform* _internal_mutable_transform();

  public:
  // float interaction_range = 6;
  void clear_interaction_range() ;
  float interaction_range() const;
  void set_interaction_range(float value);

  private:
  float _internal_interaction_range() const;
  void _internal_set_interaction_range(float value);

  public:
  // bool is_interactable = 4;
  void clear_is_interactable() ;
  bool is_interactable() const;
  void set_is_interactable(bool value);

  private:
  bool _internal_is_interactable() const;
  void _internal_set_is_interactable(bool value);

  public:
  // bool is_lootable = 8;
  void clear_is_lootable() ;
  bool is_lootable() const;
  void set_is_lootable(bool value);

  private:
  bool _internal_is_lootable() const;
  void _internal_set_is_lootable(bool value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.WorldObject)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 2,
      96, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::MapField<WorldObject_PropertiesEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        properties_;
    ::google::protobuf::RepeatedPtrField<std::string> allowed_looters_;
    ::google::protobuf::internal::ArenaStringPtr object_id_;
    ::google::protobuf::internal::ArenaStringPtr object_type_;
    ::google::protobuf::internal::ArenaStringPtr interaction_type_;
    ::mmorpg::Transform* transform_;
    float interaction_range_;
    bool is_interactable_;
    bool is_lootable_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_world_2eproto;
};// -------------------------------------------------------------------

class WorldEnterResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.WorldEnterResponse) */ {
 public:
  inline WorldEnterResponse() : WorldEnterResponse(nullptr) {}
  ~WorldEnterResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WorldEnterResponse(::google::protobuf::internal::ConstantInitialized);

  inline WorldEnterResponse(const WorldEnterResponse& from)
      : WorldEnterResponse(nullptr, from) {}
  WorldEnterResponse(WorldEnterResponse&& from) noexcept
    : WorldEnterResponse() {
    *this = ::std::move(from);
  }

  inline WorldEnterResponse& operator=(const WorldEnterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorldEnterResponse& operator=(WorldEnterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorldEnterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorldEnterResponse* internal_default_instance() {
    return reinterpret_cast<const WorldEnterResponse*>(
               &_WorldEnterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(WorldEnterResponse& a, WorldEnterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WorldEnterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorldEnterResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorldEnterResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorldEnterResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorldEnterResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WorldEnterResponse& from) {
    WorldEnterResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WorldEnterResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.WorldEnterResponse";
  }
  protected:
  explicit WorldEnterResponse(::google::protobuf::Arena* arena);
  WorldEnterResponse(::google::protobuf::Arena* arena, const WorldEnterResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 2,
    kZoneIdFieldNumber = 3,
    kErrorMessageFieldNumber = 7,
    kSpawnTransformFieldNumber = 4,
    kServerTimeFieldNumber = 5,
    kSuccessFieldNumber = 1,
    kTickRateFieldNumber = 6,
    kErrorCodeFieldNumber = 8,
  };
  // string player_id = 2;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // string zone_id = 3;
  void clear_zone_id() ;
  const std::string& zone_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_zone_id(Arg_&& arg, Args_... args);
  std::string* mutable_zone_id();
  PROTOBUF_NODISCARD std::string* release_zone_id();
  void set_allocated_zone_id(std::string* value);

  private:
  const std::string& _internal_zone_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_zone_id(
      const std::string& value);
  std::string* _internal_mutable_zone_id();

  public:
  // string error_message = 7;
  void clear_error_message() ;
  const std::string& error_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_message(Arg_&& arg, Args_... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* value);

  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(
      const std::string& value);
  std::string* _internal_mutable_error_message();

  public:
  // .mmorpg.Transform spawn_transform = 4;
  bool has_spawn_transform() const;
  void clear_spawn_transform() ;
  const ::mmorpg::Transform& spawn_transform() const;
  PROTOBUF_NODISCARD ::mmorpg::Transform* release_spawn_transform();
  ::mmorpg::Transform* mutable_spawn_transform();
  void set_allocated_spawn_transform(::mmorpg::Transform* value);
  void unsafe_arena_set_allocated_spawn_transform(::mmorpg::Transform* value);
  ::mmorpg::Transform* unsafe_arena_release_spawn_transform();

  private:
  const ::mmorpg::Transform& _internal_spawn_transform() const;
  ::mmorpg::Transform* _internal_mutable_spawn_transform();

  public:
  // .google.protobuf.Timestamp server_time = 5;
  bool has_server_time() const;
  void clear_server_time() ;
  const ::google::protobuf::Timestamp& server_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_server_time();
  ::google::protobuf::Timestamp* mutable_server_time();
  void set_allocated_server_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_server_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_server_time();

  private:
  const ::google::protobuf::Timestamp& _internal_server_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_server_time();

  public:
  // bool success = 1;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // int32 tick_rate = 6;
  void clear_tick_rate() ;
  ::int32_t tick_rate() const;
  void set_tick_rate(::int32_t value);

  private:
  ::int32_t _internal_tick_rate() const;
  void _internal_set_tick_rate(::int32_t value);

  public:
  // .mmorpg.ErrorCode error_code = 8;
  void clear_error_code() ;
  ::mmorpg::ErrorCode error_code() const;
  void set_error_code(::mmorpg::ErrorCode value);

  private:
  ::mmorpg::ErrorCode _internal_error_code() const;
  void _internal_set_error_code(::mmorpg::ErrorCode value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.WorldEnterResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 2,
      71, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::google::protobuf::internal::ArenaStringPtr zone_id_;
    ::google::protobuf::internal::ArenaStringPtr error_message_;
    ::mmorpg::Transform* spawn_transform_;
    ::google::protobuf::Timestamp* server_time_;
    bool success_;
    ::int32_t tick_rate_;
    int error_code_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_world_2eproto;
};// -------------------------------------------------------------------

class WorldEnterRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.WorldEnterRequest) */ {
 public:
  inline WorldEnterRequest() : WorldEnterRequest(nullptr) {}
  ~WorldEnterRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WorldEnterRequest(::google::protobuf::internal::ConstantInitialized);

  inline WorldEnterRequest(const WorldEnterRequest& from)
      : WorldEnterRequest(nullptr, from) {}
  WorldEnterRequest(WorldEnterRequest&& from) noexcept
    : WorldEnterRequest() {
    *this = ::std::move(from);
  }

  inline WorldEnterRequest& operator=(const WorldEnterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorldEnterRequest& operator=(WorldEnterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorldEnterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorldEnterRequest* internal_default_instance() {
    return reinterpret_cast<const WorldEnterRequest*>(
               &_WorldEnterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(WorldEnterRequest& a, WorldEnterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WorldEnterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorldEnterRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorldEnterRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorldEnterRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WorldEnterRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WorldEnterRequest& from) {
    WorldEnterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WorldEnterRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.WorldEnterRequest";
  }
  protected:
  explicit WorldEnterRequest(::google::protobuf::Arena* arena);
  WorldEnterRequest(::google::protobuf::Arena* arena, const WorldEnterRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharacterIdFieldNumber = 1,
    kWorldTokenFieldNumber = 2,
    kZoneIdFieldNumber = 4,
    kSpawnTransformFieldNumber = 3,
  };
  // string character_id = 1;
  void clear_character_id() ;
  const std::string& character_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_character_id(Arg_&& arg, Args_... args);
  std::string* mutable_character_id();
  PROTOBUF_NODISCARD std::string* release_character_id();
  void set_allocated_character_id(std::string* value);

  private:
  const std::string& _internal_character_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_character_id(
      const std::string& value);
  std::string* _internal_mutable_character_id();

  public:
  // string world_token = 2;
  void clear_world_token() ;
  const std::string& world_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_world_token(Arg_&& arg, Args_... args);
  std::string* mutable_world_token();
  PROTOBUF_NODISCARD std::string* release_world_token();
  void set_allocated_world_token(std::string* value);

  private:
  const std::string& _internal_world_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_world_token(
      const std::string& value);
  std::string* _internal_mutable_world_token();

  public:
  // string zone_id = 4;
  void clear_zone_id() ;
  const std::string& zone_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_zone_id(Arg_&& arg, Args_... args);
  std::string* mutable_zone_id();
  PROTOBUF_NODISCARD std::string* release_zone_id();
  void set_allocated_zone_id(std::string* value);

  private:
  const std::string& _internal_zone_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_zone_id(
      const std::string& value);
  std::string* _internal_mutable_zone_id();

  public:
  // .mmorpg.Transform spawn_transform = 3;
  bool has_spawn_transform() const;
  void clear_spawn_transform() ;
  const ::mmorpg::Transform& spawn_transform() const;
  PROTOBUF_NODISCARD ::mmorpg::Transform* release_spawn_transform();
  ::mmorpg::Transform* mutable_spawn_transform();
  void set_allocated_spawn_transform(::mmorpg::Transform* value);
  void unsafe_arena_set_allocated_spawn_transform(::mmorpg::Transform* value);
  ::mmorpg::Transform* unsafe_arena_release_spawn_transform();

  private:
  const ::mmorpg::Transform& _internal_spawn_transform() const;
  ::mmorpg::Transform* _internal_mutable_spawn_transform();

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.WorldEnterRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      63, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr character_id_;
    ::google::protobuf::internal::ArenaStringPtr world_token_;
    ::google::protobuf::internal::ArenaStringPtr zone_id_;
    ::mmorpg::Transform* spawn_transform_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_world_2eproto;
};// -------------------------------------------------------------------

class VisualEffectEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.VisualEffectEvent) */ {
 public:
  inline VisualEffectEvent() : VisualEffectEvent(nullptr) {}
  ~VisualEffectEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VisualEffectEvent(::google::protobuf::internal::ConstantInitialized);

  inline VisualEffectEvent(const VisualEffectEvent& from)
      : VisualEffectEvent(nullptr, from) {}
  VisualEffectEvent(VisualEffectEvent&& from) noexcept
    : VisualEffectEvent() {
    *this = ::std::move(from);
  }

  inline VisualEffectEvent& operator=(const VisualEffectEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisualEffectEvent& operator=(VisualEffectEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisualEffectEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisualEffectEvent* internal_default_instance() {
    return reinterpret_cast<const VisualEffectEvent*>(
               &_VisualEffectEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(VisualEffectEvent& a, VisualEffectEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(VisualEffectEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisualEffectEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisualEffectEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisualEffectEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VisualEffectEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VisualEffectEvent& from) {
    VisualEffectEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VisualEffectEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.VisualEffectEvent";
  }
  protected:
  explicit VisualEffectEvent(::google::protobuf::Arena* arena);
  VisualEffectEvent(::google::protobuf::Arena* arena, const VisualEffectEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEffectIdFieldNumber = 1,
    kAttachToEntityFieldNumber = 5,
    kLocationFieldNumber = 2,
    kDurationFieldNumber = 3,
    kScaleFieldNumber = 4,
  };
  // string effect_id = 1;
  void clear_effect_id() ;
  const std::string& effect_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_effect_id(Arg_&& arg, Args_... args);
  std::string* mutable_effect_id();
  PROTOBUF_NODISCARD std::string* release_effect_id();
  void set_allocated_effect_id(std::string* value);

  private:
  const std::string& _internal_effect_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_effect_id(
      const std::string& value);
  std::string* _internal_mutable_effect_id();

  public:
  // string attach_to_entity = 5;
  void clear_attach_to_entity() ;
  const std::string& attach_to_entity() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_attach_to_entity(Arg_&& arg, Args_... args);
  std::string* mutable_attach_to_entity();
  PROTOBUF_NODISCARD std::string* release_attach_to_entity();
  void set_allocated_attach_to_entity(std::string* value);

  private:
  const std::string& _internal_attach_to_entity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attach_to_entity(
      const std::string& value);
  std::string* _internal_mutable_attach_to_entity();

  public:
  // .mmorpg.Transform location = 2;
  bool has_location() const;
  void clear_location() ;
  const ::mmorpg::Transform& location() const;
  PROTOBUF_NODISCARD ::mmorpg::Transform* release_location();
  ::mmorpg::Transform* mutable_location();
  void set_allocated_location(::mmorpg::Transform* value);
  void unsafe_arena_set_allocated_location(::mmorpg::Transform* value);
  ::mmorpg::Transform* unsafe_arena_release_location();

  private:
  const ::mmorpg::Transform& _internal_location() const;
  ::mmorpg::Transform* _internal_mutable_location();

  public:
  // float duration = 3;
  void clear_duration() ;
  float duration() const;
  void set_duration(float value);

  private:
  float _internal_duration() const;
  void _internal_set_duration(float value);

  public:
  // float scale = 4;
  void clear_scale() ;
  float scale() const;
  void set_scale(float value);

  private:
  float _internal_scale() const;
  void _internal_set_scale(float value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.VisualEffectEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      58, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr effect_id_;
    ::google::protobuf::internal::ArenaStringPtr attach_to_entity_;
    ::mmorpg::Transform* location_;
    float duration_;
    float scale_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_world_2eproto;
};// -------------------------------------------------------------------

class SoundEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.SoundEvent) */ {
 public:
  inline SoundEvent() : SoundEvent(nullptr) {}
  ~SoundEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SoundEvent(::google::protobuf::internal::ConstantInitialized);

  inline SoundEvent(const SoundEvent& from)
      : SoundEvent(nullptr, from) {}
  SoundEvent(SoundEvent&& from) noexcept
    : SoundEvent() {
    *this = ::std::move(from);
  }

  inline SoundEvent& operator=(const SoundEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SoundEvent& operator=(SoundEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SoundEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SoundEvent* internal_default_instance() {
    return reinterpret_cast<const SoundEvent*>(
               &_SoundEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SoundEvent& a, SoundEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SoundEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SoundEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SoundEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SoundEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SoundEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SoundEvent& from) {
    SoundEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SoundEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.SoundEvent";
  }
  protected:
  explicit SoundEvent(::google::protobuf::Arena* arena);
  SoundEvent(::google::protobuf::Arena* arena, const SoundEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSoundIdFieldNumber = 1,
    kLocationFieldNumber = 2,
    kVolumeFieldNumber = 3,
    kRangeFieldNumber = 4,
  };
  // string sound_id = 1;
  void clear_sound_id() ;
  const std::string& sound_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sound_id(Arg_&& arg, Args_... args);
  std::string* mutable_sound_id();
  PROTOBUF_NODISCARD std::string* release_sound_id();
  void set_allocated_sound_id(std::string* value);

  private:
  const std::string& _internal_sound_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sound_id(
      const std::string& value);
  std::string* _internal_mutable_sound_id();

  public:
  // .mmorpg.Transform location = 2;
  bool has_location() const;
  void clear_location() ;
  const ::mmorpg::Transform& location() const;
  PROTOBUF_NODISCARD ::mmorpg::Transform* release_location();
  ::mmorpg::Transform* mutable_location();
  void set_allocated_location(::mmorpg::Transform* value);
  void unsafe_arena_set_allocated_location(::mmorpg::Transform* value);
  ::mmorpg::Transform* unsafe_arena_release_location();

  private:
  const ::mmorpg::Transform& _internal_location() const;
  ::mmorpg::Transform* _internal_mutable_location();

  public:
  // float volume = 3;
  void clear_volume() ;
  float volume() const;
  void set_volume(float value);

  private:
  float _internal_volume() const;
  void _internal_set_volume(float value);

  public:
  // float range = 4;
  void clear_range() ;
  float range() const;
  void set_range(float value);

  private:
  float _internal_range() const;
  void _internal_set_range(float value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.SoundEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      34, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr sound_id_;
    ::mmorpg::Transform* location_;
    float volume_;
    float range_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_world_2eproto;
};// -------------------------------------------------------------------

class PlayerState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.PlayerState) */ {
 public:
  inline PlayerState() : PlayerState(nullptr) {}
  ~PlayerState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerState(::google::protobuf::internal::ConstantInitialized);

  inline PlayerState(const PlayerState& from)
      : PlayerState(nullptr, from) {}
  PlayerState(PlayerState&& from) noexcept
    : PlayerState() {
    *this = ::std::move(from);
  }

  inline PlayerState& operator=(const PlayerState& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerState& operator=(PlayerState&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerState& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerState* internal_default_instance() {
    return reinterpret_cast<const PlayerState*>(
               &_PlayerState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PlayerState& a, PlayerState& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlayerState& from) {
    PlayerState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerState* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.PlayerState";
  }
  protected:
  explicit PlayerState(::google::protobuf::Arena* arena);
  PlayerState(::google::protobuf::Arena* arena, const PlayerState& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kStatusEffectsFieldNumber = 12,
    kVisibleEquipmentFieldNumber = 16,
    kPlayerIdFieldNumber = 1,
    kCharacterNameFieldNumber = 2,
    kCurrentAnimationFieldNumber = 14,
    kTransformFieldNumber = 5,
    kVelocityFieldNumber = 6,
    kClassFieldNumber = 3,
    kLevelFieldNumber = 4,
    kMovementFlagsFieldNumber = 7,
    kHealthFieldNumber = 8,
    kMaxHealthFieldNumber = 9,
    kManaFieldNumber = 10,
    kMaxManaFieldNumber = 11,
    kCombatStateFieldNumber = 13,
    kAnimationTimeFieldNumber = 15,
  };
  // repeated .mmorpg.StatusEffect status_effects = 12;
  int status_effects_size() const;
  private:
  int _internal_status_effects_size() const;

  public:
  void clear_status_effects() ;
  ::mmorpg::StatusEffect* mutable_status_effects(int index);
  ::google::protobuf::RepeatedPtrField< ::mmorpg::StatusEffect >*
      mutable_status_effects();
  private:
  const ::google::protobuf::RepeatedPtrField<::mmorpg::StatusEffect>& _internal_status_effects() const;
  ::google::protobuf::RepeatedPtrField<::mmorpg::StatusEffect>* _internal_mutable_status_effects();
  public:
  const ::mmorpg::StatusEffect& status_effects(int index) const;
  ::mmorpg::StatusEffect* add_status_effects();
  const ::google::protobuf::RepeatedPtrField< ::mmorpg::StatusEffect >&
      status_effects() const;
  // map<string, string> visible_equipment = 16;
  int visible_equipment_size() const;
  private:
  int _internal_visible_equipment_size() const;

  public:
  void clear_visible_equipment() ;
  const ::google::protobuf::Map<std::string, std::string>& visible_equipment() const;
  ::google::protobuf::Map<std::string, std::string>* mutable_visible_equipment();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_visible_equipment() const;
  ::google::protobuf::Map<std::string, std::string>* _internal_mutable_visible_equipment();

  public:
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // string character_name = 2;
  void clear_character_name() ;
  const std::string& character_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_character_name(Arg_&& arg, Args_... args);
  std::string* mutable_character_name();
  PROTOBUF_NODISCARD std::string* release_character_name();
  void set_allocated_character_name(std::string* value);

  private:
  const std::string& _internal_character_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_character_name(
      const std::string& value);
  std::string* _internal_mutable_character_name();

  public:
  // string current_animation = 14;
  void clear_current_animation() ;
  const std::string& current_animation() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_current_animation(Arg_&& arg, Args_... args);
  std::string* mutable_current_animation();
  PROTOBUF_NODISCARD std::string* release_current_animation();
  void set_allocated_current_animation(std::string* value);

  private:
  const std::string& _internal_current_animation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_animation(
      const std::string& value);
  std::string* _internal_mutable_current_animation();

  public:
  // .mmorpg.Transform transform = 5;
  bool has_transform() const;
  void clear_transform() ;
  const ::mmorpg::Transform& transform() const;
  PROTOBUF_NODISCARD ::mmorpg::Transform* release_transform();
  ::mmorpg::Transform* mutable_transform();
  void set_allocated_transform(::mmorpg::Transform* value);
  void unsafe_arena_set_allocated_transform(::mmorpg::Transform* value);
  ::mmorpg::Transform* unsafe_arena_release_transform();

  private:
  const ::mmorpg::Transform& _internal_transform() const;
  ::mmorpg::Transform* _internal_mutable_transform();

  public:
  // .mmorpg.Vector3 velocity = 6;
  bool has_velocity() const;
  void clear_velocity() ;
  const ::mmorpg::Vector3& velocity() const;
  PROTOBUF_NODISCARD ::mmorpg::Vector3* release_velocity();
  ::mmorpg::Vector3* mutable_velocity();
  void set_allocated_velocity(::mmorpg::Vector3* value);
  void unsafe_arena_set_allocated_velocity(::mmorpg::Vector3* value);
  ::mmorpg::Vector3* unsafe_arena_release_velocity();

  private:
  const ::mmorpg::Vector3& _internal_velocity() const;
  ::mmorpg::Vector3* _internal_mutable_velocity();

  public:
  // .mmorpg.CharacterClass class = 3;
  void clear_class_() ;
  ::mmorpg::CharacterClass class_() const;
  void set_class_(::mmorpg::CharacterClass value);

  private:
  ::mmorpg::CharacterClass _internal_class_() const;
  void _internal_set_class_(::mmorpg::CharacterClass value);

  public:
  // int32 level = 4;
  void clear_level() ;
  ::int32_t level() const;
  void set_level(::int32_t value);

  private:
  ::int32_t _internal_level() const;
  void _internal_set_level(::int32_t value);

  public:
  // uint32 movement_flags = 7;
  void clear_movement_flags() ;
  ::uint32_t movement_flags() const;
  void set_movement_flags(::uint32_t value);

  private:
  ::uint32_t _internal_movement_flags() const;
  void _internal_set_movement_flags(::uint32_t value);

  public:
  // int32 health = 8;
  void clear_health() ;
  ::int32_t health() const;
  void set_health(::int32_t value);

  private:
  ::int32_t _internal_health() const;
  void _internal_set_health(::int32_t value);

  public:
  // int32 max_health = 9;
  void clear_max_health() ;
  ::int32_t max_health() const;
  void set_max_health(::int32_t value);

  private:
  ::int32_t _internal_max_health() const;
  void _internal_set_max_health(::int32_t value);

  public:
  // int32 mana = 10;
  void clear_mana() ;
  ::int32_t mana() const;
  void set_mana(::int32_t value);

  private:
  ::int32_t _internal_mana() const;
  void _internal_set_mana(::int32_t value);

  public:
  // int32 max_mana = 11;
  void clear_max_mana() ;
  ::int32_t max_mana() const;
  void set_max_mana(::int32_t value);

  private:
  ::int32_t _internal_max_mana() const;
  void _internal_set_max_mana(::int32_t value);

  public:
  // .mmorpg.CombatState combat_state = 13;
  void clear_combat_state() ;
  ::mmorpg::CombatState combat_state() const;
  void set_combat_state(::mmorpg::CombatState value);

  private:
  ::mmorpg::CombatState _internal_combat_state() const;
  void _internal_set_combat_state(::mmorpg::CombatState value);

  public:
  // float animation_time = 15;
  void clear_animation_time() ;
  float animation_time() const;
  void set_animation_time(float value);

  private:
  float _internal_animation_time() const;
  void _internal_set_animation_time(float value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.PlayerState)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 16, 4,
      100, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::mmorpg::StatusEffect > status_effects_;
    ::google::protobuf::internal::MapField<PlayerState_VisibleEquipmentEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        visible_equipment_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::google::protobuf::internal::ArenaStringPtr character_name_;
    ::google::protobuf::internal::ArenaStringPtr current_animation_;
    ::mmorpg::Transform* transform_;
    ::mmorpg::Vector3* velocity_;
    int class__;
    ::int32_t level_;
    ::uint32_t movement_flags_;
    ::int32_t health_;
    ::int32_t max_health_;
    ::int32_t mana_;
    ::int32_t max_mana_;
    int combat_state_;
    float animation_time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_world_2eproto;
};// -------------------------------------------------------------------

class PlayerPositionUpdate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.PlayerPositionUpdate) */ {
 public:
  inline PlayerPositionUpdate() : PlayerPositionUpdate(nullptr) {}
  ~PlayerPositionUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerPositionUpdate(::google::protobuf::internal::ConstantInitialized);

  inline PlayerPositionUpdate(const PlayerPositionUpdate& from)
      : PlayerPositionUpdate(nullptr, from) {}
  PlayerPositionUpdate(PlayerPositionUpdate&& from) noexcept
    : PlayerPositionUpdate() {
    *this = ::std::move(from);
  }

  inline PlayerPositionUpdate& operator=(const PlayerPositionUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerPositionUpdate& operator=(PlayerPositionUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerPositionUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerPositionUpdate* internal_default_instance() {
    return reinterpret_cast<const PlayerPositionUpdate*>(
               &_PlayerPositionUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PlayerPositionUpdate& a, PlayerPositionUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerPositionUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerPositionUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerPositionUpdate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerPositionUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerPositionUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlayerPositionUpdate& from) {
    PlayerPositionUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerPositionUpdate* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.PlayerPositionUpdate";
  }
  protected:
  explicit PlayerPositionUpdate(::google::protobuf::Arena* arena);
  PlayerPositionUpdate(::google::protobuf::Arena* arena, const PlayerPositionUpdate& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kTransformFieldNumber = 2,
    kVelocityFieldNumber = 3,
    kAccelerationFieldNumber = 4,
    kTimestampFieldNumber = 6,
    kMovementFlagsFieldNumber = 5,
    kSequenceFieldNumber = 7,
  };
  // string player_id = 1;
  void clear_player_id() ;
  const std::string& player_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_player_id(Arg_&& arg, Args_... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* value);

  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(
      const std::string& value);
  std::string* _internal_mutable_player_id();

  public:
  // .mmorpg.Transform transform = 2;
  bool has_transform() const;
  void clear_transform() ;
  const ::mmorpg::Transform& transform() const;
  PROTOBUF_NODISCARD ::mmorpg::Transform* release_transform();
  ::mmorpg::Transform* mutable_transform();
  void set_allocated_transform(::mmorpg::Transform* value);
  void unsafe_arena_set_allocated_transform(::mmorpg::Transform* value);
  ::mmorpg::Transform* unsafe_arena_release_transform();

  private:
  const ::mmorpg::Transform& _internal_transform() const;
  ::mmorpg::Transform* _internal_mutable_transform();

  public:
  // .mmorpg.Vector3 velocity = 3;
  bool has_velocity() const;
  void clear_velocity() ;
  const ::mmorpg::Vector3& velocity() const;
  PROTOBUF_NODISCARD ::mmorpg::Vector3* release_velocity();
  ::mmorpg::Vector3* mutable_velocity();
  void set_allocated_velocity(::mmorpg::Vector3* value);
  void unsafe_arena_set_allocated_velocity(::mmorpg::Vector3* value);
  ::mmorpg::Vector3* unsafe_arena_release_velocity();

  private:
  const ::mmorpg::Vector3& _internal_velocity() const;
  ::mmorpg::Vector3* _internal_mutable_velocity();

  public:
  // .mmorpg.Vector3 acceleration = 4;
  bool has_acceleration() const;
  void clear_acceleration() ;
  const ::mmorpg::Vector3& acceleration() const;
  PROTOBUF_NODISCARD ::mmorpg::Vector3* release_acceleration();
  ::mmorpg::Vector3* mutable_acceleration();
  void set_allocated_acceleration(::mmorpg::Vector3* value);
  void unsafe_arena_set_allocated_acceleration(::mmorpg::Vector3* value);
  ::mmorpg::Vector3* unsafe_arena_release_acceleration();

  private:
  const ::mmorpg::Vector3& _internal_acceleration() const;
  ::mmorpg::Vector3* _internal_mutable_acceleration();

  public:
  // .google.protobuf.Timestamp timestamp = 6;
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::google::protobuf::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_timestamp();

  public:
  // uint32 movement_flags = 5;
  void clear_movement_flags() ;
  ::uint32_t movement_flags() const;
  void set_movement_flags(::uint32_t value);

  private:
  ::uint32_t _internal_movement_flags() const;
  void _internal_set_movement_flags(::uint32_t value);

  public:
  // uint32 sequence = 7;
  void clear_sequence() ;
  ::uint32_t sequence() const;
  void set_sequence(::uint32_t value);

  private:
  ::uint32_t _internal_sequence() const;
  void _internal_set_sequence(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.PlayerPositionUpdate)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 4,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr player_id_;
    ::mmorpg::Transform* transform_;
    ::mmorpg::Vector3* velocity_;
    ::mmorpg::Vector3* acceleration_;
    ::google::protobuf::Timestamp* timestamp_;
    ::uint32_t movement_flags_;
    ::uint32_t sequence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_world_2eproto;
};// -------------------------------------------------------------------

class NPCState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.NPCState) */ {
 public:
  inline NPCState() : NPCState(nullptr) {}
  ~NPCState() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NPCState(::google::protobuf::internal::ConstantInitialized);

  inline NPCState(const NPCState& from)
      : NPCState(nullptr, from) {}
  NPCState(NPCState&& from) noexcept
    : NPCState() {
    *this = ::std::move(from);
  }

  inline NPCState& operator=(const NPCState& from) {
    CopyFrom(from);
    return *this;
  }
  inline NPCState& operator=(NPCState&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NPCState& default_instance() {
    return *internal_default_instance();
  }
  static inline const NPCState* internal_default_instance() {
    return reinterpret_cast<const NPCState*>(
               &_NPCState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(NPCState& a, NPCState& b) {
    a.Swap(&b);
  }
  inline void Swap(NPCState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NPCState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NPCState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NPCState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NPCState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NPCState& from) {
    NPCState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NPCState* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.NPCState";
  }
  protected:
  explicit NPCState(::google::protobuf::Arena* arena);
  NPCState(::google::protobuf::Arena* arena, const NPCState& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusEffectsFieldNumber = 11,
    kNpcIdFieldNumber = 1,
    kNpcTypeFieldNumber = 2,
    kDisplayNameFieldNumber = 3,
    kTargetIdFieldNumber = 10,
    kCurrentAnimationFieldNumber = 15,
    kTransformFieldNumber = 4,
    kVelocityFieldNumber = 5,
    kHealthFieldNumber = 6,
    kMaxHealthFieldNumber = 7,
    kLevelFieldNumber = 8,
    kBehaviorStateFieldNumber = 9,
    kIsHostileFieldNumber = 12,
    kIsQuestGiverFieldNumber = 13,
    kIsVendorFieldNumber = 14,
    kAnimationTimeFieldNumber = 16,
  };
  // repeated .mmorpg.StatusEffect status_effects = 11;
  int status_effects_size() const;
  private:
  int _internal_status_effects_size() const;

  public:
  void clear_status_effects() ;
  ::mmorpg::StatusEffect* mutable_status_effects(int index);
  ::google::protobuf::RepeatedPtrField< ::mmorpg::StatusEffect >*
      mutable_status_effects();
  private:
  const ::google::protobuf::RepeatedPtrField<::mmorpg::StatusEffect>& _internal_status_effects() const;
  ::google::protobuf::RepeatedPtrField<::mmorpg::StatusEffect>* _internal_mutable_status_effects();
  public:
  const ::mmorpg::StatusEffect& status_effects(int index) const;
  ::mmorpg::StatusEffect* add_status_effects();
  const ::google::protobuf::RepeatedPtrField< ::mmorpg::StatusEffect >&
      status_effects() const;
  // string npc_id = 1;
  void clear_npc_id() ;
  const std::string& npc_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_npc_id(Arg_&& arg, Args_... args);
  std::string* mutable_npc_id();
  PROTOBUF_NODISCARD std::string* release_npc_id();
  void set_allocated_npc_id(std::string* value);

  private:
  const std::string& _internal_npc_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_npc_id(
      const std::string& value);
  std::string* _internal_mutable_npc_id();

  public:
  // string npc_type = 2;
  void clear_npc_type() ;
  const std::string& npc_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_npc_type(Arg_&& arg, Args_... args);
  std::string* mutable_npc_type();
  PROTOBUF_NODISCARD std::string* release_npc_type();
  void set_allocated_npc_type(std::string* value);

  private:
  const std::string& _internal_npc_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_npc_type(
      const std::string& value);
  std::string* _internal_mutable_npc_type();

  public:
  // string display_name = 3;
  void clear_display_name() ;
  const std::string& display_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_display_name(Arg_&& arg, Args_... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* value);

  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(
      const std::string& value);
  std::string* _internal_mutable_display_name();

  public:
  // string target_id = 10;
  void clear_target_id() ;
  const std::string& target_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_target_id(Arg_&& arg, Args_... args);
  std::string* mutable_target_id();
  PROTOBUF_NODISCARD std::string* release_target_id();
  void set_allocated_target_id(std::string* value);

  private:
  const std::string& _internal_target_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_id(
      const std::string& value);
  std::string* _internal_mutable_target_id();

  public:
  // string current_animation = 15;
  void clear_current_animation() ;
  const std::string& current_animation() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_current_animation(Arg_&& arg, Args_... args);
  std::string* mutable_current_animation();
  PROTOBUF_NODISCARD std::string* release_current_animation();
  void set_allocated_current_animation(std::string* value);

  private:
  const std::string& _internal_current_animation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_animation(
      const std::string& value);
  std::string* _internal_mutable_current_animation();

  public:
  // .mmorpg.Transform transform = 4;
  bool has_transform() const;
  void clear_transform() ;
  const ::mmorpg::Transform& transform() const;
  PROTOBUF_NODISCARD ::mmorpg::Transform* release_transform();
  ::mmorpg::Transform* mutable_transform();
  void set_allocated_transform(::mmorpg::Transform* value);
  void unsafe_arena_set_allocated_transform(::mmorpg::Transform* value);
  ::mmorpg::Transform* unsafe_arena_release_transform();

  private:
  const ::mmorpg::Transform& _internal_transform() const;
  ::mmorpg::Transform* _internal_mutable_transform();

  public:
  // .mmorpg.Vector3 velocity = 5;
  bool has_velocity() const;
  void clear_velocity() ;
  const ::mmorpg::Vector3& velocity() const;
  PROTOBUF_NODISCARD ::mmorpg::Vector3* release_velocity();
  ::mmorpg::Vector3* mutable_velocity();
  void set_allocated_velocity(::mmorpg::Vector3* value);
  void unsafe_arena_set_allocated_velocity(::mmorpg::Vector3* value);
  ::mmorpg::Vector3* unsafe_arena_release_velocity();

  private:
  const ::mmorpg::Vector3& _internal_velocity() const;
  ::mmorpg::Vector3* _internal_mutable_velocity();

  public:
  // int32 health = 6;
  void clear_health() ;
  ::int32_t health() const;
  void set_health(::int32_t value);

  private:
  ::int32_t _internal_health() const;
  void _internal_set_health(::int32_t value);

  public:
  // int32 max_health = 7;
  void clear_max_health() ;
  ::int32_t max_health() const;
  void set_max_health(::int32_t value);

  private:
  ::int32_t _internal_max_health() const;
  void _internal_set_max_health(::int32_t value);

  public:
  // int32 level = 8;
  void clear_level() ;
  ::int32_t level() const;
  void set_level(::int32_t value);

  private:
  ::int32_t _internal_level() const;
  void _internal_set_level(::int32_t value);

  public:
  // .mmorpg.NPCBehaviorState behavior_state = 9;
  void clear_behavior_state() ;
  ::mmorpg::NPCBehaviorState behavior_state() const;
  void set_behavior_state(::mmorpg::NPCBehaviorState value);

  private:
  ::mmorpg::NPCBehaviorState _internal_behavior_state() const;
  void _internal_set_behavior_state(::mmorpg::NPCBehaviorState value);

  public:
  // bool is_hostile = 12;
  void clear_is_hostile() ;
  bool is_hostile() const;
  void set_is_hostile(bool value);

  private:
  bool _internal_is_hostile() const;
  void _internal_set_is_hostile(bool value);

  public:
  // bool is_quest_giver = 13;
  void clear_is_quest_giver() ;
  bool is_quest_giver() const;
  void set_is_quest_giver(bool value);

  private:
  bool _internal_is_quest_giver() const;
  void _internal_set_is_quest_giver(bool value);

  public:
  // bool is_vendor = 14;
  void clear_is_vendor() ;
  bool is_vendor() const;
  void set_is_vendor(bool value);

  private:
  bool _internal_is_vendor() const;
  void _internal_set_is_vendor(bool value);

  public:
  // float animation_time = 16;
  void clear_animation_time() ;
  float animation_time() const;
  void set_animation_time(float value);

  private:
  float _internal_animation_time() const;
  void _internal_set_animation_time(float value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.NPCState)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 16, 3,
      92, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::mmorpg::StatusEffect > status_effects_;
    ::google::protobuf::internal::ArenaStringPtr npc_id_;
    ::google::protobuf::internal::ArenaStringPtr npc_type_;
    ::google::protobuf::internal::ArenaStringPtr display_name_;
    ::google::protobuf::internal::ArenaStringPtr target_id_;
    ::google::protobuf::internal::ArenaStringPtr current_animation_;
    ::mmorpg::Transform* transform_;
    ::mmorpg::Vector3* velocity_;
    ::int32_t health_;
    ::int32_t max_health_;
    ::int32_t level_;
    int behavior_state_;
    bool is_hostile_;
    bool is_quest_giver_;
    bool is_vendor_;
    float animation_time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_world_2eproto;
};// -------------------------------------------------------------------

class DeathEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.DeathEvent) */ {
 public:
  inline DeathEvent() : DeathEvent(nullptr) {}
  ~DeathEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeathEvent(::google::protobuf::internal::ConstantInitialized);

  inline DeathEvent(const DeathEvent& from)
      : DeathEvent(nullptr, from) {}
  DeathEvent(DeathEvent&& from) noexcept
    : DeathEvent() {
    *this = ::std::move(from);
  }

  inline DeathEvent& operator=(const DeathEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeathEvent& operator=(DeathEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeathEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeathEvent* internal_default_instance() {
    return reinterpret_cast<const DeathEvent*>(
               &_DeathEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(DeathEvent& a, DeathEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(DeathEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeathEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeathEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeathEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeathEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DeathEvent& from) {
    DeathEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DeathEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.DeathEvent";
  }
  protected:
  explicit DeathEvent(::google::protobuf::Arena* arena);
  DeathEvent(::google::protobuf::Arena* arena, const DeathEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityIdFieldNumber = 1,
    kKillerIdFieldNumber = 2,
    kDeathTypeFieldNumber = 3,
    kDeathLocationFieldNumber = 4,
  };
  // string entity_id = 1;
  void clear_entity_id() ;
  const std::string& entity_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  std::string* mutable_entity_id();
  PROTOBUF_NODISCARD std::string* release_entity_id();
  void set_allocated_entity_id(std::string* value);

  private:
  const std::string& _internal_entity_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(
      const std::string& value);
  std::string* _internal_mutable_entity_id();

  public:
  // string killer_id = 2;
  void clear_killer_id() ;
  const std::string& killer_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_killer_id(Arg_&& arg, Args_... args);
  std::string* mutable_killer_id();
  PROTOBUF_NODISCARD std::string* release_killer_id();
  void set_allocated_killer_id(std::string* value);

  private:
  const std::string& _internal_killer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_killer_id(
      const std::string& value);
  std::string* _internal_mutable_killer_id();

  public:
  // string death_type = 3;
  void clear_death_type() ;
  const std::string& death_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_death_type(Arg_&& arg, Args_... args);
  std::string* mutable_death_type();
  PROTOBUF_NODISCARD std::string* release_death_type();
  void set_allocated_death_type(std::string* value);

  private:
  const std::string& _internal_death_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_death_type(
      const std::string& value);
  std::string* _internal_mutable_death_type();

  public:
  // .mmorpg.Transform death_location = 4;
  bool has_death_location() const;
  void clear_death_location() ;
  const ::mmorpg::Transform& death_location() const;
  PROTOBUF_NODISCARD ::mmorpg::Transform* release_death_location();
  ::mmorpg::Transform* mutable_death_location();
  void set_allocated_death_location(::mmorpg::Transform* value);
  void unsafe_arena_set_allocated_death_location(::mmorpg::Transform* value);
  ::mmorpg::Transform* unsafe_arena_release_death_location();

  private:
  const ::mmorpg::Transform& _internal_death_location() const;
  ::mmorpg::Transform* _internal_mutable_death_location();

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.DeathEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      54, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    ::google::protobuf::internal::ArenaStringPtr killer_id_;
    ::google::protobuf::internal::ArenaStringPtr death_type_;
    ::mmorpg::Transform* death_location_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_world_2eproto;
};// -------------------------------------------------------------------

class EntitySpawn final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.EntitySpawn) */ {
 public:
  inline EntitySpawn() : EntitySpawn(nullptr) {}
  ~EntitySpawn() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EntitySpawn(::google::protobuf::internal::ConstantInitialized);

  inline EntitySpawn(const EntitySpawn& from)
      : EntitySpawn(nullptr, from) {}
  EntitySpawn(EntitySpawn&& from) noexcept
    : EntitySpawn() {
    *this = ::std::move(from);
  }

  inline EntitySpawn& operator=(const EntitySpawn& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntitySpawn& operator=(EntitySpawn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntitySpawn& default_instance() {
    return *internal_default_instance();
  }
  enum EntityCase {
    kPlayer = 1,
    kNpc = 2,
    kObject = 3,
    ENTITY_NOT_SET = 0,
  };

  static inline const EntitySpawn* internal_default_instance() {
    return reinterpret_cast<const EntitySpawn*>(
               &_EntitySpawn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EntitySpawn& a, EntitySpawn& b) {
    a.Swap(&b);
  }
  inline void Swap(EntitySpawn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntitySpawn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntitySpawn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EntitySpawn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EntitySpawn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EntitySpawn& from) {
    EntitySpawn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EntitySpawn* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.EntitySpawn";
  }
  protected:
  explicit EntitySpawn(::google::protobuf::Arena* arena);
  EntitySpawn(::google::protobuf::Arena* arena, const EntitySpawn& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 1,
    kNpcFieldNumber = 2,
    kObjectFieldNumber = 3,
  };
  // .mmorpg.PlayerState player = 1;
  bool has_player() const;
  private:
  bool _internal_has_player() const;

  public:
  void clear_player() ;
  const ::mmorpg::PlayerState& player() const;
  PROTOBUF_NODISCARD ::mmorpg::PlayerState* release_player();
  ::mmorpg::PlayerState* mutable_player();
  void set_allocated_player(::mmorpg::PlayerState* value);
  void unsafe_arena_set_allocated_player(::mmorpg::PlayerState* value);
  ::mmorpg::PlayerState* unsafe_arena_release_player();

  private:
  const ::mmorpg::PlayerState& _internal_player() const;
  ::mmorpg::PlayerState* _internal_mutable_player();

  public:
  // .mmorpg.NPCState npc = 2;
  bool has_npc() const;
  private:
  bool _internal_has_npc() const;

  public:
  void clear_npc() ;
  const ::mmorpg::NPCState& npc() const;
  PROTOBUF_NODISCARD ::mmorpg::NPCState* release_npc();
  ::mmorpg::NPCState* mutable_npc();
  void set_allocated_npc(::mmorpg::NPCState* value);
  void unsafe_arena_set_allocated_npc(::mmorpg::NPCState* value);
  ::mmorpg::NPCState* unsafe_arena_release_npc();

  private:
  const ::mmorpg::NPCState& _internal_npc() const;
  ::mmorpg::NPCState* _internal_mutable_npc();

  public:
  // .mmorpg.WorldObject object = 3;
  bool has_object() const;
  private:
  bool _internal_has_object() const;

  public:
  void clear_object() ;
  const ::mmorpg::WorldObject& object() const;
  PROTOBUF_NODISCARD ::mmorpg::WorldObject* release_object();
  ::mmorpg::WorldObject* mutable_object();
  void set_allocated_object(::mmorpg::WorldObject* value);
  void unsafe_arena_set_allocated_object(::mmorpg::WorldObject* value);
  ::mmorpg::WorldObject* unsafe_arena_release_object();

  private:
  const ::mmorpg::WorldObject& _internal_object() const;
  ::mmorpg::WorldObject* _internal_mutable_object();

  public:
  void clear_entity();
  EntityCase entity_case() const;
  // @@protoc_insertion_point(class_scope:mmorpg.EntitySpawn)
 private:
  class _Internal;
  void set_has_player();
  void set_has_npc();
  void set_has_object();

  inline bool has_entity() const;
  inline void clear_has_entity();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union EntityUnion {
      constexpr EntityUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::mmorpg::PlayerState* player_;
      ::mmorpg::NPCState* npc_;
      ::mmorpg::WorldObject* object_;
    } entity_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_world_2eproto;
};// -------------------------------------------------------------------

class EntityEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.EntityEvent) */ {
 public:
  inline EntityEvent() : EntityEvent(nullptr) {}
  ~EntityEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EntityEvent(::google::protobuf::internal::ConstantInitialized);

  inline EntityEvent(const EntityEvent& from)
      : EntityEvent(nullptr, from) {}
  EntityEvent(EntityEvent&& from) noexcept
    : EntityEvent() {
    *this = ::std::move(from);
  }

  inline EntityEvent& operator=(const EntityEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityEvent& operator=(EntityEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntityEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventDataCase {
    kDamage = 4,
    kHeal = 5,
    kDeath = 6,
    kLevelUp = 7,
    kEmote = 8,
    kSound = 9,
    kVisualEffect = 10,
    EVENT_DATA_NOT_SET = 0,
  };

  static inline const EntityEvent* internal_default_instance() {
    return reinterpret_cast<const EntityEvent*>(
               &_EntityEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(EntityEvent& a, EntityEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(EntityEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntityEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EntityEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EntityEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EntityEvent& from) {
    EntityEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EntityEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.EntityEvent";
  }
  protected:
  explicit EntityEvent(::google::protobuf::Arena* arena);
  EntityEvent(::google::protobuf::Arena* arena, const EntityEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityIdFieldNumber = 1,
    kEventTypeFieldNumber = 2,
    kTimestampFieldNumber = 3,
    kDamageFieldNumber = 4,
    kHealFieldNumber = 5,
    kDeathFieldNumber = 6,
    kLevelUpFieldNumber = 7,
    kEmoteFieldNumber = 8,
    kSoundFieldNumber = 9,
    kVisualEffectFieldNumber = 10,
  };
  // string entity_id = 1;
  void clear_entity_id() ;
  const std::string& entity_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_entity_id(Arg_&& arg, Args_... args);
  std::string* mutable_entity_id();
  PROTOBUF_NODISCARD std::string* release_entity_id();
  void set_allocated_entity_id(std::string* value);

  private:
  const std::string& _internal_entity_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_entity_id(
      const std::string& value);
  std::string* _internal_mutable_entity_id();

  public:
  // string event_type = 2;
  void clear_event_type() ;
  const std::string& event_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_event_type(Arg_&& arg, Args_... args);
  std::string* mutable_event_type();
  PROTOBUF_NODISCARD std::string* release_event_type();
  void set_allocated_event_type(std::string* value);

  private:
  const std::string& _internal_event_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_type(
      const std::string& value);
  std::string* _internal_mutable_event_type();

  public:
  // .google.protobuf.Timestamp timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::google::protobuf::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  ::google::protobuf::Timestamp* _internal_mutable_timestamp();

  public:
  // .mmorpg.DamageEvent damage = 4;
  bool has_damage() const;
  private:
  bool _internal_has_damage() const;

  public:
  void clear_damage() ;
  const ::mmorpg::DamageEvent& damage() const;
  PROTOBUF_NODISCARD ::mmorpg::DamageEvent* release_damage();
  ::mmorpg::DamageEvent* mutable_damage();
  void set_allocated_damage(::mmorpg::DamageEvent* value);
  void unsafe_arena_set_allocated_damage(::mmorpg::DamageEvent* value);
  ::mmorpg::DamageEvent* unsafe_arena_release_damage();

  private:
  const ::mmorpg::DamageEvent& _internal_damage() const;
  ::mmorpg::DamageEvent* _internal_mutable_damage();

  public:
  // .mmorpg.HealEvent heal = 5;
  bool has_heal() const;
  private:
  bool _internal_has_heal() const;

  public:
  void clear_heal() ;
  const ::mmorpg::HealEvent& heal() const;
  PROTOBUF_NODISCARD ::mmorpg::HealEvent* release_heal();
  ::mmorpg::HealEvent* mutable_heal();
  void set_allocated_heal(::mmorpg::HealEvent* value);
  void unsafe_arena_set_allocated_heal(::mmorpg::HealEvent* value);
  ::mmorpg::HealEvent* unsafe_arena_release_heal();

  private:
  const ::mmorpg::HealEvent& _internal_heal() const;
  ::mmorpg::HealEvent* _internal_mutable_heal();

  public:
  // .mmorpg.DeathEvent death = 6;
  bool has_death() const;
  private:
  bool _internal_has_death() const;

  public:
  void clear_death() ;
  const ::mmorpg::DeathEvent& death() const;
  PROTOBUF_NODISCARD ::mmorpg::DeathEvent* release_death();
  ::mmorpg::DeathEvent* mutable_death();
  void set_allocated_death(::mmorpg::DeathEvent* value);
  void unsafe_arena_set_allocated_death(::mmorpg::DeathEvent* value);
  ::mmorpg::DeathEvent* unsafe_arena_release_death();

  private:
  const ::mmorpg::DeathEvent& _internal_death() const;
  ::mmorpg::DeathEvent* _internal_mutable_death();

  public:
  // .mmorpg.LevelUpEvent level_up = 7;
  bool has_level_up() const;
  private:
  bool _internal_has_level_up() const;

  public:
  void clear_level_up() ;
  const ::mmorpg::LevelUpEvent& level_up() const;
  PROTOBUF_NODISCARD ::mmorpg::LevelUpEvent* release_level_up();
  ::mmorpg::LevelUpEvent* mutable_level_up();
  void set_allocated_level_up(::mmorpg::LevelUpEvent* value);
  void unsafe_arena_set_allocated_level_up(::mmorpg::LevelUpEvent* value);
  ::mmorpg::LevelUpEvent* unsafe_arena_release_level_up();

  private:
  const ::mmorpg::LevelUpEvent& _internal_level_up() const;
  ::mmorpg::LevelUpEvent* _internal_mutable_level_up();

  public:
  // .mmorpg.EmoteEvent emote = 8;
  bool has_emote() const;
  private:
  bool _internal_has_emote() const;

  public:
  void clear_emote() ;
  const ::mmorpg::EmoteEvent& emote() const;
  PROTOBUF_NODISCARD ::mmorpg::EmoteEvent* release_emote();
  ::mmorpg::EmoteEvent* mutable_emote();
  void set_allocated_emote(::mmorpg::EmoteEvent* value);
  void unsafe_arena_set_allocated_emote(::mmorpg::EmoteEvent* value);
  ::mmorpg::EmoteEvent* unsafe_arena_release_emote();

  private:
  const ::mmorpg::EmoteEvent& _internal_emote() const;
  ::mmorpg::EmoteEvent* _internal_mutable_emote();

  public:
  // .mmorpg.SoundEvent sound = 9;
  bool has_sound() const;
  private:
  bool _internal_has_sound() const;

  public:
  void clear_sound() ;
  const ::mmorpg::SoundEvent& sound() const;
  PROTOBUF_NODISCARD ::mmorpg::SoundEvent* release_sound();
  ::mmorpg::SoundEvent* mutable_sound();
  void set_allocated_sound(::mmorpg::SoundEvent* value);
  void unsafe_arena_set_allocated_sound(::mmorpg::SoundEvent* value);
  ::mmorpg::SoundEvent* unsafe_arena_release_sound();

  private:
  const ::mmorpg::SoundEvent& _internal_sound() const;
  ::mmorpg::SoundEvent* _internal_mutable_sound();

  public:
  // .mmorpg.VisualEffectEvent visual_effect = 10;
  bool has_visual_effect() const;
  private:
  bool _internal_has_visual_effect() const;

  public:
  void clear_visual_effect() ;
  const ::mmorpg::VisualEffectEvent& visual_effect() const;
  PROTOBUF_NODISCARD ::mmorpg::VisualEffectEvent* release_visual_effect();
  ::mmorpg::VisualEffectEvent* mutable_visual_effect();
  void set_allocated_visual_effect(::mmorpg::VisualEffectEvent* value);
  void unsafe_arena_set_allocated_visual_effect(::mmorpg::VisualEffectEvent* value);
  ::mmorpg::VisualEffectEvent* unsafe_arena_release_visual_effect();

  private:
  const ::mmorpg::VisualEffectEvent& _internal_visual_effect() const;
  ::mmorpg::VisualEffectEvent* _internal_mutable_visual_effect();

  public:
  void clear_event_data();
  EventDataCase event_data_case() const;
  // @@protoc_insertion_point(class_scope:mmorpg.EntityEvent)
 private:
  class _Internal;
  void set_has_damage();
  void set_has_heal();
  void set_has_death();
  void set_has_level_up();
  void set_has_emote();
  void set_has_sound();
  void set_has_visual_effect();

  inline bool has_event_data() const;
  inline void clear_has_event_data();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 10, 8,
      54, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr entity_id_;
    ::google::protobuf::internal::ArenaStringPtr event_type_;
    ::google::protobuf::Timestamp* timestamp_;
    union EventDataUnion {
      constexpr EventDataUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::mmorpg::DamageEvent* damage_;
      ::mmorpg::HealEvent* heal_;
      ::mmorpg::DeathEvent* death_;
      ::mmorpg::LevelUpEvent* level_up_;
      ::mmorpg::EmoteEvent* emote_;
      ::mmorpg::SoundEvent* sound_;
      ::mmorpg::VisualEffectEvent* visual_effect_;
    } event_data_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_world_2eproto;
};// -------------------------------------------------------------------

class AreaUpdate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mmorpg.AreaUpdate) */ {
 public:
  inline AreaUpdate() : AreaUpdate(nullptr) {}
  ~AreaUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AreaUpdate(::google::protobuf::internal::ConstantInitialized);

  inline AreaUpdate(const AreaUpdate& from)
      : AreaUpdate(nullptr, from) {}
  AreaUpdate(AreaUpdate&& from) noexcept
    : AreaUpdate() {
    *this = ::std::move(from);
  }

  inline AreaUpdate& operator=(const AreaUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline AreaUpdate& operator=(AreaUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AreaUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const AreaUpdate* internal_default_instance() {
    return reinterpret_cast<const AreaUpdate*>(
               &_AreaUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AreaUpdate& a, AreaUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(AreaUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AreaUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AreaUpdate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AreaUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AreaUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AreaUpdate& from) {
    AreaUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AreaUpdate* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "mmorpg.AreaUpdate";
  }
  protected:
  explicit AreaUpdate(::google::protobuf::Arena* arena);
  AreaUpdate(::google::protobuf::Arena* arena, const AreaUpdate& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
    kNpcsFieldNumber = 2,
    kObjectsFieldNumber = 3,
    kEventsFieldNumber = 4,
    kServerTimeFieldNumber = 5,
    kTickFieldNumber = 6,
  };
  // repeated .mmorpg.PlayerState players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;

  public:
  void clear_players() ;
  ::mmorpg::PlayerState* mutable_players(int index);
  ::google::protobuf::RepeatedPtrField< ::mmorpg::PlayerState >*
      mutable_players();
  private:
  const ::google::protobuf::RepeatedPtrField<::mmorpg::PlayerState>& _internal_players() const;
  ::google::protobuf::RepeatedPtrField<::mmorpg::PlayerState>* _internal_mutable_players();
  public:
  const ::mmorpg::PlayerState& players(int index) const;
  ::mmorpg::PlayerState* add_players();
  const ::google::protobuf::RepeatedPtrField< ::mmorpg::PlayerState >&
      players() const;
  // repeated .mmorpg.NPCState npcs = 2;
  int npcs_size() const;
  private:
  int _internal_npcs_size() const;

  public:
  void clear_npcs() ;
  ::mmorpg::NPCState* mutable_npcs(int index);
  ::google::protobuf::RepeatedPtrField< ::mmorpg::NPCState >*
      mutable_npcs();
  private:
  const ::google::protobuf::RepeatedPtrField<::mmorpg::NPCState>& _internal_npcs() const;
  ::google::protobuf::RepeatedPtrField<::mmorpg::NPCState>* _internal_mutable_npcs();
  public:
  const ::mmorpg::NPCState& npcs(int index) const;
  ::mmorpg::NPCState* add_npcs();
  const ::google::protobuf::RepeatedPtrField< ::mmorpg::NPCState >&
      npcs() const;
  // repeated .mmorpg.WorldObject objects = 3;
  int objects_size() const;
  private:
  int _internal_objects_size() const;

  public:
  void clear_objects() ;
  ::mmorpg::WorldObject* mutable_objects(int index);
  ::google::protobuf::RepeatedPtrField< ::mmorpg::WorldObject >*
      mutable_objects();
  private:
  const ::google::protobuf::RepeatedPtrField<::mmorpg::WorldObject>& _internal_objects() const;
  ::google::protobuf::RepeatedPtrField<::mmorpg::WorldObject>* _internal_mutable_objects();
  public:
  const ::mmorpg::WorldObject& objects(int index) const;
  ::mmorpg::WorldObject* add_objects();
  const ::google::protobuf::RepeatedPtrField< ::mmorpg::WorldObject >&
      objects() const;
  // repeated .mmorpg.EntityEvent events = 4;
  int events_size() const;
  private:
  int _internal_events_size() const;

  public:
  void clear_events() ;
  ::mmorpg::EntityEvent* mutable_events(int index);
  ::google::protobuf::RepeatedPtrField< ::mmorpg::EntityEvent >*
      mutable_events();
  private:
  const ::google::protobuf::RepeatedPtrField<::mmorpg::EntityEvent>& _internal_events() const;
  ::google::protobuf::RepeatedPtrField<::mmorpg::EntityEvent>* _internal_mutable_events();
  public:
  const ::mmorpg::EntityEvent& events(int index) const;
  ::mmorpg::EntityEvent* add_events();
  const ::google::protobuf::RepeatedPtrField< ::mmorpg::EntityEvent >&
      events() const;
  // .google.protobuf.Timestamp server_time = 5;
  bool has_server_time() const;
  void clear_server_time() ;
  const ::google::protobuf::Timestamp& server_time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_server_time();
  ::google::protobuf::Timestamp* mutable_server_time();
  void set_allocated_server_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_server_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_server_time();

  private:
  const ::google::protobuf::Timestamp& _internal_server_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_server_time();

  public:
  // uint32 tick = 6;
  void clear_tick() ;
  ::uint32_t tick() const;
  void set_tick(::uint32_t value);

  private:
  ::uint32_t _internal_tick() const;
  void _internal_set_tick(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:mmorpg.AreaUpdate)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 5,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::mmorpg::PlayerState > players_;
    ::google::protobuf::RepeatedPtrField< ::mmorpg::NPCState > npcs_;
    ::google::protobuf::RepeatedPtrField< ::mmorpg::WorldObject > objects_;
    ::google::protobuf::RepeatedPtrField< ::mmorpg::EntityEvent > events_;
    ::google::protobuf::Timestamp* server_time_;
    ::uint32_t tick_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_world_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// WorldEnterRequest

// string character_id = 1;
inline void WorldEnterRequest::clear_character_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.character_id_.ClearToEmpty();
}
inline const std::string& WorldEnterRequest::character_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.WorldEnterRequest.character_id)
  return _internal_character_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorldEnterRequest::set_character_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.character_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.WorldEnterRequest.character_id)
}
inline std::string* WorldEnterRequest::mutable_character_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_character_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.WorldEnterRequest.character_id)
  return _s;
}
inline const std::string& WorldEnterRequest::_internal_character_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.character_id_.Get();
}
inline void WorldEnterRequest::_internal_set_character_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.character_id_.Set(value, GetArena());
}
inline std::string* WorldEnterRequest::_internal_mutable_character_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.character_id_.Mutable( GetArena());
}
inline std::string* WorldEnterRequest::release_character_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.WorldEnterRequest.character_id)
  return _impl_.character_id_.Release();
}
inline void WorldEnterRequest::set_allocated_character_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.character_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.character_id_.IsDefault()) {
          _impl_.character_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.WorldEnterRequest.character_id)
}

// string world_token = 2;
inline void WorldEnterRequest::clear_world_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.world_token_.ClearToEmpty();
}
inline const std::string& WorldEnterRequest::world_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.WorldEnterRequest.world_token)
  return _internal_world_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorldEnterRequest::set_world_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.world_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.WorldEnterRequest.world_token)
}
inline std::string* WorldEnterRequest::mutable_world_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_world_token();
  // @@protoc_insertion_point(field_mutable:mmorpg.WorldEnterRequest.world_token)
  return _s;
}
inline const std::string& WorldEnterRequest::_internal_world_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.world_token_.Get();
}
inline void WorldEnterRequest::_internal_set_world_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.world_token_.Set(value, GetArena());
}
inline std::string* WorldEnterRequest::_internal_mutable_world_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.world_token_.Mutable( GetArena());
}
inline std::string* WorldEnterRequest::release_world_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.WorldEnterRequest.world_token)
  return _impl_.world_token_.Release();
}
inline void WorldEnterRequest::set_allocated_world_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.world_token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.world_token_.IsDefault()) {
          _impl_.world_token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.WorldEnterRequest.world_token)
}

// .mmorpg.Transform spawn_transform = 3;
inline bool WorldEnterRequest::has_spawn_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.spawn_transform_ != nullptr);
  return value;
}
inline const ::mmorpg::Transform& WorldEnterRequest::_internal_spawn_transform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::mmorpg::Transform* p = _impl_.spawn_transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::mmorpg::Transform&>(::mmorpg::_Transform_default_instance_);
}
inline const ::mmorpg::Transform& WorldEnterRequest::spawn_transform() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.WorldEnterRequest.spawn_transform)
  return _internal_spawn_transform();
}
inline void WorldEnterRequest::unsafe_arena_set_allocated_spawn_transform(::mmorpg::Transform* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.spawn_transform_);
  }
  _impl_.spawn_transform_ = reinterpret_cast<::mmorpg::Transform*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.WorldEnterRequest.spawn_transform)
}
inline ::mmorpg::Transform* WorldEnterRequest::release_spawn_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Transform* released = _impl_.spawn_transform_;
  _impl_.spawn_transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::mmorpg::Transform* WorldEnterRequest::unsafe_arena_release_spawn_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.WorldEnterRequest.spawn_transform)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Transform* temp = _impl_.spawn_transform_;
  _impl_.spawn_transform_ = nullptr;
  return temp;
}
inline ::mmorpg::Transform* WorldEnterRequest::_internal_mutable_spawn_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.spawn_transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::mmorpg::Transform>(GetArena());
    _impl_.spawn_transform_ = reinterpret_cast<::mmorpg::Transform*>(p);
  }
  return _impl_.spawn_transform_;
}
inline ::mmorpg::Transform* WorldEnterRequest::mutable_spawn_transform() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::Transform* _msg = _internal_mutable_spawn_transform();
  // @@protoc_insertion_point(field_mutable:mmorpg.WorldEnterRequest.spawn_transform)
  return _msg;
}
inline void WorldEnterRequest::set_allocated_spawn_transform(::mmorpg::Transform* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.spawn_transform_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.spawn_transform_ = reinterpret_cast<::mmorpg::Transform*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.WorldEnterRequest.spawn_transform)
}

// string zone_id = 4;
inline void WorldEnterRequest::clear_zone_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.zone_id_.ClearToEmpty();
}
inline const std::string& WorldEnterRequest::zone_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.WorldEnterRequest.zone_id)
  return _internal_zone_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorldEnterRequest::set_zone_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.zone_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.WorldEnterRequest.zone_id)
}
inline std::string* WorldEnterRequest::mutable_zone_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_zone_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.WorldEnterRequest.zone_id)
  return _s;
}
inline const std::string& WorldEnterRequest::_internal_zone_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.zone_id_.Get();
}
inline void WorldEnterRequest::_internal_set_zone_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.zone_id_.Set(value, GetArena());
}
inline std::string* WorldEnterRequest::_internal_mutable_zone_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.zone_id_.Mutable( GetArena());
}
inline std::string* WorldEnterRequest::release_zone_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.WorldEnterRequest.zone_id)
  return _impl_.zone_id_.Release();
}
inline void WorldEnterRequest::set_allocated_zone_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.zone_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.zone_id_.IsDefault()) {
          _impl_.zone_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.WorldEnterRequest.zone_id)
}

// -------------------------------------------------------------------

// WorldEnterResponse

// bool success = 1;
inline void WorldEnterResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool WorldEnterResponse::success() const {
  // @@protoc_insertion_point(field_get:mmorpg.WorldEnterResponse.success)
  return _internal_success();
}
inline void WorldEnterResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:mmorpg.WorldEnterResponse.success)
}
inline bool WorldEnterResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void WorldEnterResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string player_id = 2;
inline void WorldEnterResponse::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& WorldEnterResponse::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.WorldEnterResponse.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorldEnterResponse::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.WorldEnterResponse.player_id)
}
inline std::string* WorldEnterResponse::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.WorldEnterResponse.player_id)
  return _s;
}
inline const std::string& WorldEnterResponse::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void WorldEnterResponse::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* WorldEnterResponse::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* WorldEnterResponse::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.WorldEnterResponse.player_id)
  return _impl_.player_id_.Release();
}
inline void WorldEnterResponse::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.WorldEnterResponse.player_id)
}

// string zone_id = 3;
inline void WorldEnterResponse::clear_zone_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.zone_id_.ClearToEmpty();
}
inline const std::string& WorldEnterResponse::zone_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.WorldEnterResponse.zone_id)
  return _internal_zone_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorldEnterResponse::set_zone_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.zone_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.WorldEnterResponse.zone_id)
}
inline std::string* WorldEnterResponse::mutable_zone_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_zone_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.WorldEnterResponse.zone_id)
  return _s;
}
inline const std::string& WorldEnterResponse::_internal_zone_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.zone_id_.Get();
}
inline void WorldEnterResponse::_internal_set_zone_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.zone_id_.Set(value, GetArena());
}
inline std::string* WorldEnterResponse::_internal_mutable_zone_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.zone_id_.Mutable( GetArena());
}
inline std::string* WorldEnterResponse::release_zone_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.WorldEnterResponse.zone_id)
  return _impl_.zone_id_.Release();
}
inline void WorldEnterResponse::set_allocated_zone_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.zone_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.zone_id_.IsDefault()) {
          _impl_.zone_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.WorldEnterResponse.zone_id)
}

// .mmorpg.Transform spawn_transform = 4;
inline bool WorldEnterResponse::has_spawn_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.spawn_transform_ != nullptr);
  return value;
}
inline const ::mmorpg::Transform& WorldEnterResponse::_internal_spawn_transform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::mmorpg::Transform* p = _impl_.spawn_transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::mmorpg::Transform&>(::mmorpg::_Transform_default_instance_);
}
inline const ::mmorpg::Transform& WorldEnterResponse::spawn_transform() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.WorldEnterResponse.spawn_transform)
  return _internal_spawn_transform();
}
inline void WorldEnterResponse::unsafe_arena_set_allocated_spawn_transform(::mmorpg::Transform* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.spawn_transform_);
  }
  _impl_.spawn_transform_ = reinterpret_cast<::mmorpg::Transform*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.WorldEnterResponse.spawn_transform)
}
inline ::mmorpg::Transform* WorldEnterResponse::release_spawn_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Transform* released = _impl_.spawn_transform_;
  _impl_.spawn_transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::mmorpg::Transform* WorldEnterResponse::unsafe_arena_release_spawn_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.WorldEnterResponse.spawn_transform)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Transform* temp = _impl_.spawn_transform_;
  _impl_.spawn_transform_ = nullptr;
  return temp;
}
inline ::mmorpg::Transform* WorldEnterResponse::_internal_mutable_spawn_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.spawn_transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::mmorpg::Transform>(GetArena());
    _impl_.spawn_transform_ = reinterpret_cast<::mmorpg::Transform*>(p);
  }
  return _impl_.spawn_transform_;
}
inline ::mmorpg::Transform* WorldEnterResponse::mutable_spawn_transform() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::Transform* _msg = _internal_mutable_spawn_transform();
  // @@protoc_insertion_point(field_mutable:mmorpg.WorldEnterResponse.spawn_transform)
  return _msg;
}
inline void WorldEnterResponse::set_allocated_spawn_transform(::mmorpg::Transform* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.spawn_transform_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.spawn_transform_ = reinterpret_cast<::mmorpg::Transform*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.WorldEnterResponse.spawn_transform)
}

// .google.protobuf.Timestamp server_time = 5;
inline bool WorldEnterResponse::has_server_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.server_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& WorldEnterResponse::_internal_server_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.server_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& WorldEnterResponse::server_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.WorldEnterResponse.server_time)
  return _internal_server_time();
}
inline void WorldEnterResponse::unsafe_arena_set_allocated_server_time(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.server_time_);
  }
  _impl_.server_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.WorldEnterResponse.server_time)
}
inline ::google::protobuf::Timestamp* WorldEnterResponse::release_server_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.server_time_;
  _impl_.server_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* WorldEnterResponse::unsafe_arena_release_server_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.WorldEnterResponse.server_time)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.server_time_;
  _impl_.server_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* WorldEnterResponse::_internal_mutable_server_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.server_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.server_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.server_time_;
}
inline ::google::protobuf::Timestamp* WorldEnterResponse::mutable_server_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_server_time();
  // @@protoc_insertion_point(field_mutable:mmorpg.WorldEnterResponse.server_time)
  return _msg;
}
inline void WorldEnterResponse::set_allocated_server_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.server_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.server_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.WorldEnterResponse.server_time)
}

// int32 tick_rate = 6;
inline void WorldEnterResponse::clear_tick_rate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tick_rate_ = 0;
}
inline ::int32_t WorldEnterResponse::tick_rate() const {
  // @@protoc_insertion_point(field_get:mmorpg.WorldEnterResponse.tick_rate)
  return _internal_tick_rate();
}
inline void WorldEnterResponse::set_tick_rate(::int32_t value) {
  _internal_set_tick_rate(value);
  // @@protoc_insertion_point(field_set:mmorpg.WorldEnterResponse.tick_rate)
}
inline ::int32_t WorldEnterResponse::_internal_tick_rate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tick_rate_;
}
inline void WorldEnterResponse::_internal_set_tick_rate(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tick_rate_ = value;
}

// string error_message = 7;
inline void WorldEnterResponse::clear_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& WorldEnterResponse::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.WorldEnterResponse.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorldEnterResponse::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.WorldEnterResponse.error_message)
}
inline std::string* WorldEnterResponse::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:mmorpg.WorldEnterResponse.error_message)
  return _s;
}
inline const std::string& WorldEnterResponse::_internal_error_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_message_.Get();
}
inline void WorldEnterResponse::_internal_set_error_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* WorldEnterResponse::_internal_mutable_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* WorldEnterResponse::release_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.WorldEnterResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void WorldEnterResponse::set_allocated_error_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_message_.IsDefault()) {
          _impl_.error_message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.WorldEnterResponse.error_message)
}

// .mmorpg.ErrorCode error_code = 8;
inline void WorldEnterResponse::clear_error_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_code_ = 0;
}
inline ::mmorpg::ErrorCode WorldEnterResponse::error_code() const {
  // @@protoc_insertion_point(field_get:mmorpg.WorldEnterResponse.error_code)
  return _internal_error_code();
}
inline void WorldEnterResponse::set_error_code(::mmorpg::ErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:mmorpg.WorldEnterResponse.error_code)
}
inline ::mmorpg::ErrorCode WorldEnterResponse::_internal_error_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::ErrorCode>(_impl_.error_code_);
}
inline void WorldEnterResponse::_internal_set_error_code(::mmorpg::ErrorCode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_code_ = value;
}

// -------------------------------------------------------------------

// WorldLeaveRequest

// string player_id = 1;
inline void WorldLeaveRequest::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& WorldLeaveRequest::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.WorldLeaveRequest.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorldLeaveRequest::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.WorldLeaveRequest.player_id)
}
inline std::string* WorldLeaveRequest::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.WorldLeaveRequest.player_id)
  return _s;
}
inline const std::string& WorldLeaveRequest::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void WorldLeaveRequest::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* WorldLeaveRequest::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* WorldLeaveRequest::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.WorldLeaveRequest.player_id)
  return _impl_.player_id_.Release();
}
inline void WorldLeaveRequest::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.WorldLeaveRequest.player_id)
}

// string reason = 2;
inline void WorldLeaveRequest::clear_reason() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reason_.ClearToEmpty();
}
inline const std::string& WorldLeaveRequest::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.WorldLeaveRequest.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorldLeaveRequest::set_reason(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.WorldLeaveRequest.reason)
}
inline std::string* WorldLeaveRequest::mutable_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:mmorpg.WorldLeaveRequest.reason)
  return _s;
}
inline const std::string& WorldLeaveRequest::_internal_reason() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reason_.Get();
}
inline void WorldLeaveRequest::_internal_set_reason(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reason_.Set(value, GetArena());
}
inline std::string* WorldLeaveRequest::_internal_mutable_reason() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.reason_.Mutable( GetArena());
}
inline std::string* WorldLeaveRequest::release_reason() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.WorldLeaveRequest.reason)
  return _impl_.reason_.Release();
}
inline void WorldLeaveRequest::set_allocated_reason(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reason_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reason_.IsDefault()) {
          _impl_.reason_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.WorldLeaveRequest.reason)
}

// -------------------------------------------------------------------

// WorldLeaveResponse

// bool success = 1;
inline void WorldLeaveResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool WorldLeaveResponse::success() const {
  // @@protoc_insertion_point(field_get:mmorpg.WorldLeaveResponse.success)
  return _internal_success();
}
inline void WorldLeaveResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:mmorpg.WorldLeaveResponse.success)
}
inline bool WorldLeaveResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void WorldLeaveResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string message = 2;
inline void WorldLeaveResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& WorldLeaveResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.WorldLeaveResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorldLeaveResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.WorldLeaveResponse.message)
}
inline std::string* WorldLeaveResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:mmorpg.WorldLeaveResponse.message)
  return _s;
}
inline const std::string& WorldLeaveResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void WorldLeaveResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* WorldLeaveResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* WorldLeaveResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.WorldLeaveResponse.message)
  return _impl_.message_.Release();
}
inline void WorldLeaveResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.WorldLeaveResponse.message)
}

// -------------------------------------------------------------------

// PlayerPositionUpdate

// string player_id = 1;
inline void PlayerPositionUpdate::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& PlayerPositionUpdate::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.PlayerPositionUpdate.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerPositionUpdate::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.PlayerPositionUpdate.player_id)
}
inline std::string* PlayerPositionUpdate::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.PlayerPositionUpdate.player_id)
  return _s;
}
inline const std::string& PlayerPositionUpdate::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void PlayerPositionUpdate::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* PlayerPositionUpdate::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* PlayerPositionUpdate::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.PlayerPositionUpdate.player_id)
  return _impl_.player_id_.Release();
}
inline void PlayerPositionUpdate::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.PlayerPositionUpdate.player_id)
}

// .mmorpg.Transform transform = 2;
inline bool PlayerPositionUpdate::has_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transform_ != nullptr);
  return value;
}
inline const ::mmorpg::Transform& PlayerPositionUpdate::_internal_transform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::mmorpg::Transform* p = _impl_.transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::mmorpg::Transform&>(::mmorpg::_Transform_default_instance_);
}
inline const ::mmorpg::Transform& PlayerPositionUpdate::transform() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.PlayerPositionUpdate.transform)
  return _internal_transform();
}
inline void PlayerPositionUpdate::unsafe_arena_set_allocated_transform(::mmorpg::Transform* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transform_);
  }
  _impl_.transform_ = reinterpret_cast<::mmorpg::Transform*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.PlayerPositionUpdate.transform)
}
inline ::mmorpg::Transform* PlayerPositionUpdate::release_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Transform* released = _impl_.transform_;
  _impl_.transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::mmorpg::Transform* PlayerPositionUpdate::unsafe_arena_release_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.PlayerPositionUpdate.transform)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Transform* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
  return temp;
}
inline ::mmorpg::Transform* PlayerPositionUpdate::_internal_mutable_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::mmorpg::Transform>(GetArena());
    _impl_.transform_ = reinterpret_cast<::mmorpg::Transform*>(p);
  }
  return _impl_.transform_;
}
inline ::mmorpg::Transform* PlayerPositionUpdate::mutable_transform() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::Transform* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:mmorpg.PlayerPositionUpdate.transform)
  return _msg;
}
inline void PlayerPositionUpdate::set_allocated_transform(::mmorpg::Transform* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transform_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.transform_ = reinterpret_cast<::mmorpg::Transform*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.PlayerPositionUpdate.transform)
}

// .mmorpg.Vector3 velocity = 3;
inline bool PlayerPositionUpdate::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline const ::mmorpg::Vector3& PlayerPositionUpdate::_internal_velocity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::mmorpg::Vector3* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::mmorpg::Vector3&>(::mmorpg::_Vector3_default_instance_);
}
inline const ::mmorpg::Vector3& PlayerPositionUpdate::velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.PlayerPositionUpdate.velocity)
  return _internal_velocity();
}
inline void PlayerPositionUpdate::unsafe_arena_set_allocated_velocity(::mmorpg::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = reinterpret_cast<::mmorpg::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.PlayerPositionUpdate.velocity)
}
inline ::mmorpg::Vector3* PlayerPositionUpdate::release_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::mmorpg::Vector3* released = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::mmorpg::Vector3* PlayerPositionUpdate::unsafe_arena_release_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.PlayerPositionUpdate.velocity)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::mmorpg::Vector3* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::mmorpg::Vector3* PlayerPositionUpdate::_internal_mutable_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::mmorpg::Vector3>(GetArena());
    _impl_.velocity_ = reinterpret_cast<::mmorpg::Vector3*>(p);
  }
  return _impl_.velocity_;
}
inline ::mmorpg::Vector3* PlayerPositionUpdate::mutable_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::Vector3* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:mmorpg.PlayerPositionUpdate.velocity)
  return _msg;
}
inline void PlayerPositionUpdate::set_allocated_velocity(::mmorpg::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.velocity_ = reinterpret_cast<::mmorpg::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.PlayerPositionUpdate.velocity)
}

// .mmorpg.Vector3 acceleration = 4;
inline bool PlayerPositionUpdate::has_acceleration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.acceleration_ != nullptr);
  return value;
}
inline const ::mmorpg::Vector3& PlayerPositionUpdate::_internal_acceleration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::mmorpg::Vector3* p = _impl_.acceleration_;
  return p != nullptr ? *p : reinterpret_cast<const ::mmorpg::Vector3&>(::mmorpg::_Vector3_default_instance_);
}
inline const ::mmorpg::Vector3& PlayerPositionUpdate::acceleration() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.PlayerPositionUpdate.acceleration)
  return _internal_acceleration();
}
inline void PlayerPositionUpdate::unsafe_arena_set_allocated_acceleration(::mmorpg::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.acceleration_);
  }
  _impl_.acceleration_ = reinterpret_cast<::mmorpg::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.PlayerPositionUpdate.acceleration)
}
inline ::mmorpg::Vector3* PlayerPositionUpdate::release_acceleration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::mmorpg::Vector3* released = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::mmorpg::Vector3* PlayerPositionUpdate::unsafe_arena_release_acceleration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.PlayerPositionUpdate.acceleration)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::mmorpg::Vector3* temp = _impl_.acceleration_;
  _impl_.acceleration_ = nullptr;
  return temp;
}
inline ::mmorpg::Vector3* PlayerPositionUpdate::_internal_mutable_acceleration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::mmorpg::Vector3>(GetArena());
    _impl_.acceleration_ = reinterpret_cast<::mmorpg::Vector3*>(p);
  }
  return _impl_.acceleration_;
}
inline ::mmorpg::Vector3* PlayerPositionUpdate::mutable_acceleration() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::Vector3* _msg = _internal_mutable_acceleration();
  // @@protoc_insertion_point(field_mutable:mmorpg.PlayerPositionUpdate.acceleration)
  return _msg;
}
inline void PlayerPositionUpdate::set_allocated_acceleration(::mmorpg::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.acceleration_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.acceleration_ = reinterpret_cast<::mmorpg::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.PlayerPositionUpdate.acceleration)
}

// uint32 movement_flags = 5;
inline void PlayerPositionUpdate::clear_movement_flags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.movement_flags_ = 0u;
}
inline ::uint32_t PlayerPositionUpdate::movement_flags() const {
  // @@protoc_insertion_point(field_get:mmorpg.PlayerPositionUpdate.movement_flags)
  return _internal_movement_flags();
}
inline void PlayerPositionUpdate::set_movement_flags(::uint32_t value) {
  _internal_set_movement_flags(value);
  // @@protoc_insertion_point(field_set:mmorpg.PlayerPositionUpdate.movement_flags)
}
inline ::uint32_t PlayerPositionUpdate::_internal_movement_flags() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.movement_flags_;
}
inline void PlayerPositionUpdate::_internal_set_movement_flags(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.movement_flags_ = value;
}

// .google.protobuf.Timestamp timestamp = 6;
inline bool PlayerPositionUpdate::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& PlayerPositionUpdate::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& PlayerPositionUpdate::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.PlayerPositionUpdate.timestamp)
  return _internal_timestamp();
}
inline void PlayerPositionUpdate::unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.PlayerPositionUpdate.timestamp)
}
inline ::google::protobuf::Timestamp* PlayerPositionUpdate::release_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* PlayerPositionUpdate::unsafe_arena_release_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.PlayerPositionUpdate.timestamp)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::google::protobuf::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* PlayerPositionUpdate::_internal_mutable_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::google::protobuf::Timestamp* PlayerPositionUpdate::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:mmorpg.PlayerPositionUpdate.timestamp)
  return _msg;
}
inline void PlayerPositionUpdate::set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.PlayerPositionUpdate.timestamp)
}

// uint32 sequence = 7;
inline void PlayerPositionUpdate::clear_sequence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sequence_ = 0u;
}
inline ::uint32_t PlayerPositionUpdate::sequence() const {
  // @@protoc_insertion_point(field_get:mmorpg.PlayerPositionUpdate.sequence)
  return _internal_sequence();
}
inline void PlayerPositionUpdate::set_sequence(::uint32_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:mmorpg.PlayerPositionUpdate.sequence)
}
inline ::uint32_t PlayerPositionUpdate::_internal_sequence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sequence_;
}
inline void PlayerPositionUpdate::_internal_set_sequence(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sequence_ = value;
}

// -------------------------------------------------------------------

// AreaUpdate

// repeated .mmorpg.PlayerState players = 1;
inline int AreaUpdate::_internal_players_size() const {
  return _internal_players().size();
}
inline int AreaUpdate::players_size() const {
  return _internal_players_size();
}
inline void AreaUpdate::clear_players() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.players_.Clear();
}
inline ::mmorpg::PlayerState* AreaUpdate::mutable_players(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.AreaUpdate.players)
  return _internal_mutable_players()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::PlayerState>* AreaUpdate::mutable_players()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.AreaUpdate.players)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_players();
}
inline const ::mmorpg::PlayerState& AreaUpdate::players(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.AreaUpdate.players)
  return _internal_players().Get(index);
}
inline ::mmorpg::PlayerState* AreaUpdate::add_players() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::mmorpg::PlayerState* _add = _internal_mutable_players()->Add();
  // @@protoc_insertion_point(field_add:mmorpg.AreaUpdate.players)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::PlayerState>& AreaUpdate::players() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.AreaUpdate.players)
  return _internal_players();
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::PlayerState>&
AreaUpdate::_internal_players() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.players_;
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::PlayerState>*
AreaUpdate::_internal_mutable_players() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.players_;
}

// repeated .mmorpg.NPCState npcs = 2;
inline int AreaUpdate::_internal_npcs_size() const {
  return _internal_npcs().size();
}
inline int AreaUpdate::npcs_size() const {
  return _internal_npcs_size();
}
inline void AreaUpdate::clear_npcs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.npcs_.Clear();
}
inline ::mmorpg::NPCState* AreaUpdate::mutable_npcs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.AreaUpdate.npcs)
  return _internal_mutable_npcs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::NPCState>* AreaUpdate::mutable_npcs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.AreaUpdate.npcs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_npcs();
}
inline const ::mmorpg::NPCState& AreaUpdate::npcs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.AreaUpdate.npcs)
  return _internal_npcs().Get(index);
}
inline ::mmorpg::NPCState* AreaUpdate::add_npcs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::mmorpg::NPCState* _add = _internal_mutable_npcs()->Add();
  // @@protoc_insertion_point(field_add:mmorpg.AreaUpdate.npcs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::NPCState>& AreaUpdate::npcs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.AreaUpdate.npcs)
  return _internal_npcs();
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::NPCState>&
AreaUpdate::_internal_npcs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.npcs_;
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::NPCState>*
AreaUpdate::_internal_mutable_npcs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.npcs_;
}

// repeated .mmorpg.WorldObject objects = 3;
inline int AreaUpdate::_internal_objects_size() const {
  return _internal_objects().size();
}
inline int AreaUpdate::objects_size() const {
  return _internal_objects_size();
}
inline void AreaUpdate::clear_objects() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objects_.Clear();
}
inline ::mmorpg::WorldObject* AreaUpdate::mutable_objects(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.AreaUpdate.objects)
  return _internal_mutable_objects()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::WorldObject>* AreaUpdate::mutable_objects()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.AreaUpdate.objects)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_objects();
}
inline const ::mmorpg::WorldObject& AreaUpdate::objects(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.AreaUpdate.objects)
  return _internal_objects().Get(index);
}
inline ::mmorpg::WorldObject* AreaUpdate::add_objects() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::mmorpg::WorldObject* _add = _internal_mutable_objects()->Add();
  // @@protoc_insertion_point(field_add:mmorpg.AreaUpdate.objects)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::WorldObject>& AreaUpdate::objects() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.AreaUpdate.objects)
  return _internal_objects();
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::WorldObject>&
AreaUpdate::_internal_objects() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objects_;
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::WorldObject>*
AreaUpdate::_internal_mutable_objects() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.objects_;
}

// repeated .mmorpg.EntityEvent events = 4;
inline int AreaUpdate::_internal_events_size() const {
  return _internal_events().size();
}
inline int AreaUpdate::events_size() const {
  return _internal_events_size();
}
inline void AreaUpdate::clear_events() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.events_.Clear();
}
inline ::mmorpg::EntityEvent* AreaUpdate::mutable_events(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.AreaUpdate.events)
  return _internal_mutable_events()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::EntityEvent>* AreaUpdate::mutable_events()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.AreaUpdate.events)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_events();
}
inline const ::mmorpg::EntityEvent& AreaUpdate::events(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.AreaUpdate.events)
  return _internal_events().Get(index);
}
inline ::mmorpg::EntityEvent* AreaUpdate::add_events() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::mmorpg::EntityEvent* _add = _internal_mutable_events()->Add();
  // @@protoc_insertion_point(field_add:mmorpg.AreaUpdate.events)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::EntityEvent>& AreaUpdate::events() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.AreaUpdate.events)
  return _internal_events();
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::EntityEvent>&
AreaUpdate::_internal_events() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.events_;
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::EntityEvent>*
AreaUpdate::_internal_mutable_events() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.events_;
}

// .google.protobuf.Timestamp server_time = 5;
inline bool AreaUpdate::has_server_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.server_time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& AreaUpdate::_internal_server_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.server_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& AreaUpdate::server_time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.AreaUpdate.server_time)
  return _internal_server_time();
}
inline void AreaUpdate::unsafe_arena_set_allocated_server_time(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.server_time_);
  }
  _impl_.server_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.AreaUpdate.server_time)
}
inline ::google::protobuf::Timestamp* AreaUpdate::release_server_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.server_time_;
  _impl_.server_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* AreaUpdate::unsafe_arena_release_server_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.AreaUpdate.server_time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.server_time_;
  _impl_.server_time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* AreaUpdate::_internal_mutable_server_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.server_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.server_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.server_time_;
}
inline ::google::protobuf::Timestamp* AreaUpdate::mutable_server_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_server_time();
  // @@protoc_insertion_point(field_mutable:mmorpg.AreaUpdate.server_time)
  return _msg;
}
inline void AreaUpdate::set_allocated_server_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.server_time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.server_time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.AreaUpdate.server_time)
}

// uint32 tick = 6;
inline void AreaUpdate::clear_tick() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tick_ = 0u;
}
inline ::uint32_t AreaUpdate::tick() const {
  // @@protoc_insertion_point(field_get:mmorpg.AreaUpdate.tick)
  return _internal_tick();
}
inline void AreaUpdate::set_tick(::uint32_t value) {
  _internal_set_tick(value);
  // @@protoc_insertion_point(field_set:mmorpg.AreaUpdate.tick)
}
inline ::uint32_t AreaUpdate::_internal_tick() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tick_;
}
inline void AreaUpdate::_internal_set_tick(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tick_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PlayerState

// string player_id = 1;
inline void PlayerState::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& PlayerState::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.PlayerState.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerState::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.PlayerState.player_id)
}
inline std::string* PlayerState::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.PlayerState.player_id)
  return _s;
}
inline const std::string& PlayerState::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void PlayerState::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* PlayerState::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* PlayerState::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.PlayerState.player_id)
  return _impl_.player_id_.Release();
}
inline void PlayerState::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.PlayerState.player_id)
}

// string character_name = 2;
inline void PlayerState::clear_character_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.character_name_.ClearToEmpty();
}
inline const std::string& PlayerState::character_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.PlayerState.character_name)
  return _internal_character_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerState::set_character_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.character_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.PlayerState.character_name)
}
inline std::string* PlayerState::mutable_character_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_character_name();
  // @@protoc_insertion_point(field_mutable:mmorpg.PlayerState.character_name)
  return _s;
}
inline const std::string& PlayerState::_internal_character_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.character_name_.Get();
}
inline void PlayerState::_internal_set_character_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.character_name_.Set(value, GetArena());
}
inline std::string* PlayerState::_internal_mutable_character_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.character_name_.Mutable( GetArena());
}
inline std::string* PlayerState::release_character_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.PlayerState.character_name)
  return _impl_.character_name_.Release();
}
inline void PlayerState::set_allocated_character_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.character_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.character_name_.IsDefault()) {
          _impl_.character_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.PlayerState.character_name)
}

// .mmorpg.CharacterClass class = 3;
inline void PlayerState::clear_class_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.class__ = 0;
}
inline ::mmorpg::CharacterClass PlayerState::class_() const {
  // @@protoc_insertion_point(field_get:mmorpg.PlayerState.class)
  return _internal_class_();
}
inline void PlayerState::set_class_(::mmorpg::CharacterClass value) {
  _internal_set_class_(value);
  // @@protoc_insertion_point(field_set:mmorpg.PlayerState.class)
}
inline ::mmorpg::CharacterClass PlayerState::_internal_class_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::CharacterClass>(_impl_.class__);
}
inline void PlayerState::_internal_set_class_(::mmorpg::CharacterClass value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.class__ = value;
}

// int32 level = 4;
inline void PlayerState::clear_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = 0;
}
inline ::int32_t PlayerState::level() const {
  // @@protoc_insertion_point(field_get:mmorpg.PlayerState.level)
  return _internal_level();
}
inline void PlayerState::set_level(::int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:mmorpg.PlayerState.level)
}
inline ::int32_t PlayerState::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.level_;
}
inline void PlayerState::_internal_set_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.level_ = value;
}

// .mmorpg.Transform transform = 5;
inline bool PlayerState::has_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transform_ != nullptr);
  return value;
}
inline const ::mmorpg::Transform& PlayerState::_internal_transform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::mmorpg::Transform* p = _impl_.transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::mmorpg::Transform&>(::mmorpg::_Transform_default_instance_);
}
inline const ::mmorpg::Transform& PlayerState::transform() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.PlayerState.transform)
  return _internal_transform();
}
inline void PlayerState::unsafe_arena_set_allocated_transform(::mmorpg::Transform* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transform_);
  }
  _impl_.transform_ = reinterpret_cast<::mmorpg::Transform*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.PlayerState.transform)
}
inline ::mmorpg::Transform* PlayerState::release_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Transform* released = _impl_.transform_;
  _impl_.transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::mmorpg::Transform* PlayerState::unsafe_arena_release_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.PlayerState.transform)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Transform* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
  return temp;
}
inline ::mmorpg::Transform* PlayerState::_internal_mutable_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::mmorpg::Transform>(GetArena());
    _impl_.transform_ = reinterpret_cast<::mmorpg::Transform*>(p);
  }
  return _impl_.transform_;
}
inline ::mmorpg::Transform* PlayerState::mutable_transform() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::Transform* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:mmorpg.PlayerState.transform)
  return _msg;
}
inline void PlayerState::set_allocated_transform(::mmorpg::Transform* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transform_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.transform_ = reinterpret_cast<::mmorpg::Transform*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.PlayerState.transform)
}

// .mmorpg.Vector3 velocity = 6;
inline bool PlayerState::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline const ::mmorpg::Vector3& PlayerState::_internal_velocity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::mmorpg::Vector3* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::mmorpg::Vector3&>(::mmorpg::_Vector3_default_instance_);
}
inline const ::mmorpg::Vector3& PlayerState::velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.PlayerState.velocity)
  return _internal_velocity();
}
inline void PlayerState::unsafe_arena_set_allocated_velocity(::mmorpg::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = reinterpret_cast<::mmorpg::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.PlayerState.velocity)
}
inline ::mmorpg::Vector3* PlayerState::release_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::mmorpg::Vector3* released = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::mmorpg::Vector3* PlayerState::unsafe_arena_release_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.PlayerState.velocity)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::mmorpg::Vector3* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::mmorpg::Vector3* PlayerState::_internal_mutable_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::mmorpg::Vector3>(GetArena());
    _impl_.velocity_ = reinterpret_cast<::mmorpg::Vector3*>(p);
  }
  return _impl_.velocity_;
}
inline ::mmorpg::Vector3* PlayerState::mutable_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::Vector3* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:mmorpg.PlayerState.velocity)
  return _msg;
}
inline void PlayerState::set_allocated_velocity(::mmorpg::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.velocity_ = reinterpret_cast<::mmorpg::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.PlayerState.velocity)
}

// uint32 movement_flags = 7;
inline void PlayerState::clear_movement_flags() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.movement_flags_ = 0u;
}
inline ::uint32_t PlayerState::movement_flags() const {
  // @@protoc_insertion_point(field_get:mmorpg.PlayerState.movement_flags)
  return _internal_movement_flags();
}
inline void PlayerState::set_movement_flags(::uint32_t value) {
  _internal_set_movement_flags(value);
  // @@protoc_insertion_point(field_set:mmorpg.PlayerState.movement_flags)
}
inline ::uint32_t PlayerState::_internal_movement_flags() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.movement_flags_;
}
inline void PlayerState::_internal_set_movement_flags(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.movement_flags_ = value;
}

// int32 health = 8;
inline void PlayerState::clear_health() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.health_ = 0;
}
inline ::int32_t PlayerState::health() const {
  // @@protoc_insertion_point(field_get:mmorpg.PlayerState.health)
  return _internal_health();
}
inline void PlayerState::set_health(::int32_t value) {
  _internal_set_health(value);
  // @@protoc_insertion_point(field_set:mmorpg.PlayerState.health)
}
inline ::int32_t PlayerState::_internal_health() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.health_;
}
inline void PlayerState::_internal_set_health(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.health_ = value;
}

// int32 max_health = 9;
inline void PlayerState::clear_max_health() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_health_ = 0;
}
inline ::int32_t PlayerState::max_health() const {
  // @@protoc_insertion_point(field_get:mmorpg.PlayerState.max_health)
  return _internal_max_health();
}
inline void PlayerState::set_max_health(::int32_t value) {
  _internal_set_max_health(value);
  // @@protoc_insertion_point(field_set:mmorpg.PlayerState.max_health)
}
inline ::int32_t PlayerState::_internal_max_health() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_health_;
}
inline void PlayerState::_internal_set_max_health(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_health_ = value;
}

// int32 mana = 10;
inline void PlayerState::clear_mana() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mana_ = 0;
}
inline ::int32_t PlayerState::mana() const {
  // @@protoc_insertion_point(field_get:mmorpg.PlayerState.mana)
  return _internal_mana();
}
inline void PlayerState::set_mana(::int32_t value) {
  _internal_set_mana(value);
  // @@protoc_insertion_point(field_set:mmorpg.PlayerState.mana)
}
inline ::int32_t PlayerState::_internal_mana() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mana_;
}
inline void PlayerState::_internal_set_mana(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mana_ = value;
}

// int32 max_mana = 11;
inline void PlayerState::clear_max_mana() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_mana_ = 0;
}
inline ::int32_t PlayerState::max_mana() const {
  // @@protoc_insertion_point(field_get:mmorpg.PlayerState.max_mana)
  return _internal_max_mana();
}
inline void PlayerState::set_max_mana(::int32_t value) {
  _internal_set_max_mana(value);
  // @@protoc_insertion_point(field_set:mmorpg.PlayerState.max_mana)
}
inline ::int32_t PlayerState::_internal_max_mana() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_mana_;
}
inline void PlayerState::_internal_set_max_mana(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_mana_ = value;
}

// repeated .mmorpg.StatusEffect status_effects = 12;
inline int PlayerState::_internal_status_effects_size() const {
  return _internal_status_effects().size();
}
inline int PlayerState::status_effects_size() const {
  return _internal_status_effects_size();
}
inline void PlayerState::clear_status_effects() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_effects_.Clear();
}
inline ::mmorpg::StatusEffect* PlayerState::mutable_status_effects(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.PlayerState.status_effects)
  return _internal_mutable_status_effects()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::StatusEffect>* PlayerState::mutable_status_effects()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.PlayerState.status_effects)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_status_effects();
}
inline const ::mmorpg::StatusEffect& PlayerState::status_effects(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.PlayerState.status_effects)
  return _internal_status_effects().Get(index);
}
inline ::mmorpg::StatusEffect* PlayerState::add_status_effects() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::mmorpg::StatusEffect* _add = _internal_mutable_status_effects()->Add();
  // @@protoc_insertion_point(field_add:mmorpg.PlayerState.status_effects)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::StatusEffect>& PlayerState::status_effects() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.PlayerState.status_effects)
  return _internal_status_effects();
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::StatusEffect>&
PlayerState::_internal_status_effects() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.status_effects_;
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::StatusEffect>*
PlayerState::_internal_mutable_status_effects() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.status_effects_;
}

// .mmorpg.CombatState combat_state = 13;
inline void PlayerState::clear_combat_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.combat_state_ = 0;
}
inline ::mmorpg::CombatState PlayerState::combat_state() const {
  // @@protoc_insertion_point(field_get:mmorpg.PlayerState.combat_state)
  return _internal_combat_state();
}
inline void PlayerState::set_combat_state(::mmorpg::CombatState value) {
  _internal_set_combat_state(value);
  // @@protoc_insertion_point(field_set:mmorpg.PlayerState.combat_state)
}
inline ::mmorpg::CombatState PlayerState::_internal_combat_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::CombatState>(_impl_.combat_state_);
}
inline void PlayerState::_internal_set_combat_state(::mmorpg::CombatState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.combat_state_ = value;
}

// string current_animation = 14;
inline void PlayerState::clear_current_animation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.current_animation_.ClearToEmpty();
}
inline const std::string& PlayerState::current_animation() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.PlayerState.current_animation)
  return _internal_current_animation();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerState::set_current_animation(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.current_animation_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.PlayerState.current_animation)
}
inline std::string* PlayerState::mutable_current_animation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_current_animation();
  // @@protoc_insertion_point(field_mutable:mmorpg.PlayerState.current_animation)
  return _s;
}
inline const std::string& PlayerState::_internal_current_animation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.current_animation_.Get();
}
inline void PlayerState::_internal_set_current_animation(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.current_animation_.Set(value, GetArena());
}
inline std::string* PlayerState::_internal_mutable_current_animation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.current_animation_.Mutable( GetArena());
}
inline std::string* PlayerState::release_current_animation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.PlayerState.current_animation)
  return _impl_.current_animation_.Release();
}
inline void PlayerState::set_allocated_current_animation(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.current_animation_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.current_animation_.IsDefault()) {
          _impl_.current_animation_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.PlayerState.current_animation)
}

// float animation_time = 15;
inline void PlayerState::clear_animation_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.animation_time_ = 0;
}
inline float PlayerState::animation_time() const {
  // @@protoc_insertion_point(field_get:mmorpg.PlayerState.animation_time)
  return _internal_animation_time();
}
inline void PlayerState::set_animation_time(float value) {
  _internal_set_animation_time(value);
  // @@protoc_insertion_point(field_set:mmorpg.PlayerState.animation_time)
}
inline float PlayerState::_internal_animation_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.animation_time_;
}
inline void PlayerState::_internal_set_animation_time(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.animation_time_ = value;
}

// map<string, string> visible_equipment = 16;
inline int PlayerState::_internal_visible_equipment_size() const {
  return _internal_visible_equipment().size();
}
inline int PlayerState::visible_equipment_size() const {
  return _internal_visible_equipment_size();
}
inline void PlayerState::clear_visible_equipment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.visible_equipment_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& PlayerState::_internal_visible_equipment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.visible_equipment_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& PlayerState::visible_equipment() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:mmorpg.PlayerState.visible_equipment)
  return _internal_visible_equipment();
}
inline ::google::protobuf::Map<std::string, std::string>* PlayerState::_internal_mutable_visible_equipment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.visible_equipment_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* PlayerState::mutable_visible_equipment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:mmorpg.PlayerState.visible_equipment)
  return _internal_mutable_visible_equipment();
}

// -------------------------------------------------------------------

// NPCState

// string npc_id = 1;
inline void NPCState::clear_npc_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.npc_id_.ClearToEmpty();
}
inline const std::string& NPCState::npc_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.NPCState.npc_id)
  return _internal_npc_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NPCState::set_npc_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.npc_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.NPCState.npc_id)
}
inline std::string* NPCState::mutable_npc_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_npc_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.NPCState.npc_id)
  return _s;
}
inline const std::string& NPCState::_internal_npc_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.npc_id_.Get();
}
inline void NPCState::_internal_set_npc_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.npc_id_.Set(value, GetArena());
}
inline std::string* NPCState::_internal_mutable_npc_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.npc_id_.Mutable( GetArena());
}
inline std::string* NPCState::release_npc_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.NPCState.npc_id)
  return _impl_.npc_id_.Release();
}
inline void NPCState::set_allocated_npc_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.npc_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.npc_id_.IsDefault()) {
          _impl_.npc_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.NPCState.npc_id)
}

// string npc_type = 2;
inline void NPCState::clear_npc_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.npc_type_.ClearToEmpty();
}
inline const std::string& NPCState::npc_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.NPCState.npc_type)
  return _internal_npc_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NPCState::set_npc_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.npc_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.NPCState.npc_type)
}
inline std::string* NPCState::mutable_npc_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_npc_type();
  // @@protoc_insertion_point(field_mutable:mmorpg.NPCState.npc_type)
  return _s;
}
inline const std::string& NPCState::_internal_npc_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.npc_type_.Get();
}
inline void NPCState::_internal_set_npc_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.npc_type_.Set(value, GetArena());
}
inline std::string* NPCState::_internal_mutable_npc_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.npc_type_.Mutable( GetArena());
}
inline std::string* NPCState::release_npc_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.NPCState.npc_type)
  return _impl_.npc_type_.Release();
}
inline void NPCState::set_allocated_npc_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.npc_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.npc_type_.IsDefault()) {
          _impl_.npc_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.NPCState.npc_type)
}

// string display_name = 3;
inline void NPCState::clear_display_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& NPCState::display_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.NPCState.display_name)
  return _internal_display_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NPCState::set_display_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.display_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.NPCState.display_name)
}
inline std::string* NPCState::mutable_display_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:mmorpg.NPCState.display_name)
  return _s;
}
inline const std::string& NPCState::_internal_display_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.display_name_.Get();
}
inline void NPCState::_internal_set_display_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.display_name_.Set(value, GetArena());
}
inline std::string* NPCState::_internal_mutable_display_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.display_name_.Mutable( GetArena());
}
inline std::string* NPCState::release_display_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.NPCState.display_name)
  return _impl_.display_name_.Release();
}
inline void NPCState::set_allocated_display_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.display_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.display_name_.IsDefault()) {
          _impl_.display_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.NPCState.display_name)
}

// .mmorpg.Transform transform = 4;
inline bool NPCState::has_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transform_ != nullptr);
  return value;
}
inline const ::mmorpg::Transform& NPCState::_internal_transform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::mmorpg::Transform* p = _impl_.transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::mmorpg::Transform&>(::mmorpg::_Transform_default_instance_);
}
inline const ::mmorpg::Transform& NPCState::transform() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.NPCState.transform)
  return _internal_transform();
}
inline void NPCState::unsafe_arena_set_allocated_transform(::mmorpg::Transform* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transform_);
  }
  _impl_.transform_ = reinterpret_cast<::mmorpg::Transform*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.NPCState.transform)
}
inline ::mmorpg::Transform* NPCState::release_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Transform* released = _impl_.transform_;
  _impl_.transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::mmorpg::Transform* NPCState::unsafe_arena_release_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.NPCState.transform)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Transform* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
  return temp;
}
inline ::mmorpg::Transform* NPCState::_internal_mutable_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::mmorpg::Transform>(GetArena());
    _impl_.transform_ = reinterpret_cast<::mmorpg::Transform*>(p);
  }
  return _impl_.transform_;
}
inline ::mmorpg::Transform* NPCState::mutable_transform() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::Transform* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:mmorpg.NPCState.transform)
  return _msg;
}
inline void NPCState::set_allocated_transform(::mmorpg::Transform* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transform_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.transform_ = reinterpret_cast<::mmorpg::Transform*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.NPCState.transform)
}

// .mmorpg.Vector3 velocity = 5;
inline bool NPCState::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline const ::mmorpg::Vector3& NPCState::_internal_velocity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::mmorpg::Vector3* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::mmorpg::Vector3&>(::mmorpg::_Vector3_default_instance_);
}
inline const ::mmorpg::Vector3& NPCState::velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.NPCState.velocity)
  return _internal_velocity();
}
inline void NPCState::unsafe_arena_set_allocated_velocity(::mmorpg::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = reinterpret_cast<::mmorpg::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.NPCState.velocity)
}
inline ::mmorpg::Vector3* NPCState::release_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::mmorpg::Vector3* released = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::mmorpg::Vector3* NPCState::unsafe_arena_release_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.NPCState.velocity)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::mmorpg::Vector3* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::mmorpg::Vector3* NPCState::_internal_mutable_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::mmorpg::Vector3>(GetArena());
    _impl_.velocity_ = reinterpret_cast<::mmorpg::Vector3*>(p);
  }
  return _impl_.velocity_;
}
inline ::mmorpg::Vector3* NPCState::mutable_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::Vector3* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:mmorpg.NPCState.velocity)
  return _msg;
}
inline void NPCState::set_allocated_velocity(::mmorpg::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.velocity_ = reinterpret_cast<::mmorpg::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.NPCState.velocity)
}

// int32 health = 6;
inline void NPCState::clear_health() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.health_ = 0;
}
inline ::int32_t NPCState::health() const {
  // @@protoc_insertion_point(field_get:mmorpg.NPCState.health)
  return _internal_health();
}
inline void NPCState::set_health(::int32_t value) {
  _internal_set_health(value);
  // @@protoc_insertion_point(field_set:mmorpg.NPCState.health)
}
inline ::int32_t NPCState::_internal_health() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.health_;
}
inline void NPCState::_internal_set_health(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.health_ = value;
}

// int32 max_health = 7;
inline void NPCState::clear_max_health() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_health_ = 0;
}
inline ::int32_t NPCState::max_health() const {
  // @@protoc_insertion_point(field_get:mmorpg.NPCState.max_health)
  return _internal_max_health();
}
inline void NPCState::set_max_health(::int32_t value) {
  _internal_set_max_health(value);
  // @@protoc_insertion_point(field_set:mmorpg.NPCState.max_health)
}
inline ::int32_t NPCState::_internal_max_health() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_health_;
}
inline void NPCState::_internal_set_max_health(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.max_health_ = value;
}

// int32 level = 8;
inline void NPCState::clear_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = 0;
}
inline ::int32_t NPCState::level() const {
  // @@protoc_insertion_point(field_get:mmorpg.NPCState.level)
  return _internal_level();
}
inline void NPCState::set_level(::int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:mmorpg.NPCState.level)
}
inline ::int32_t NPCState::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.level_;
}
inline void NPCState::_internal_set_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.level_ = value;
}

// .mmorpg.NPCBehaviorState behavior_state = 9;
inline void NPCState::clear_behavior_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.behavior_state_ = 0;
}
inline ::mmorpg::NPCBehaviorState NPCState::behavior_state() const {
  // @@protoc_insertion_point(field_get:mmorpg.NPCState.behavior_state)
  return _internal_behavior_state();
}
inline void NPCState::set_behavior_state(::mmorpg::NPCBehaviorState value) {
  _internal_set_behavior_state(value);
  // @@protoc_insertion_point(field_set:mmorpg.NPCState.behavior_state)
}
inline ::mmorpg::NPCBehaviorState NPCState::_internal_behavior_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::NPCBehaviorState>(_impl_.behavior_state_);
}
inline void NPCState::_internal_set_behavior_state(::mmorpg::NPCBehaviorState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.behavior_state_ = value;
}

// string target_id = 10;
inline void NPCState::clear_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_id_.ClearToEmpty();
}
inline const std::string& NPCState::target_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.NPCState.target_id)
  return _internal_target_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NPCState::set_target_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.NPCState.target_id)
}
inline std::string* NPCState::mutable_target_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.NPCState.target_id)
  return _s;
}
inline const std::string& NPCState::_internal_target_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_id_.Get();
}
inline void NPCState::_internal_set_target_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_id_.Set(value, GetArena());
}
inline std::string* NPCState::_internal_mutable_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.target_id_.Mutable( GetArena());
}
inline std::string* NPCState::release_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.NPCState.target_id)
  return _impl_.target_id_.Release();
}
inline void NPCState::set_allocated_target_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_id_.IsDefault()) {
          _impl_.target_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.NPCState.target_id)
}

// repeated .mmorpg.StatusEffect status_effects = 11;
inline int NPCState::_internal_status_effects_size() const {
  return _internal_status_effects().size();
}
inline int NPCState::status_effects_size() const {
  return _internal_status_effects_size();
}
inline void NPCState::clear_status_effects() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_effects_.Clear();
}
inline ::mmorpg::StatusEffect* NPCState::mutable_status_effects(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.NPCState.status_effects)
  return _internal_mutable_status_effects()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::StatusEffect>* NPCState::mutable_status_effects()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.NPCState.status_effects)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_status_effects();
}
inline const ::mmorpg::StatusEffect& NPCState::status_effects(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.NPCState.status_effects)
  return _internal_status_effects().Get(index);
}
inline ::mmorpg::StatusEffect* NPCState::add_status_effects() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::mmorpg::StatusEffect* _add = _internal_mutable_status_effects()->Add();
  // @@protoc_insertion_point(field_add:mmorpg.NPCState.status_effects)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::StatusEffect>& NPCState::status_effects() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.NPCState.status_effects)
  return _internal_status_effects();
}
inline const ::google::protobuf::RepeatedPtrField<::mmorpg::StatusEffect>&
NPCState::_internal_status_effects() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.status_effects_;
}
inline ::google::protobuf::RepeatedPtrField<::mmorpg::StatusEffect>*
NPCState::_internal_mutable_status_effects() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.status_effects_;
}

// bool is_hostile = 12;
inline void NPCState::clear_is_hostile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_hostile_ = false;
}
inline bool NPCState::is_hostile() const {
  // @@protoc_insertion_point(field_get:mmorpg.NPCState.is_hostile)
  return _internal_is_hostile();
}
inline void NPCState::set_is_hostile(bool value) {
  _internal_set_is_hostile(value);
  // @@protoc_insertion_point(field_set:mmorpg.NPCState.is_hostile)
}
inline bool NPCState::_internal_is_hostile() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_hostile_;
}
inline void NPCState::_internal_set_is_hostile(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_hostile_ = value;
}

// bool is_quest_giver = 13;
inline void NPCState::clear_is_quest_giver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_quest_giver_ = false;
}
inline bool NPCState::is_quest_giver() const {
  // @@protoc_insertion_point(field_get:mmorpg.NPCState.is_quest_giver)
  return _internal_is_quest_giver();
}
inline void NPCState::set_is_quest_giver(bool value) {
  _internal_set_is_quest_giver(value);
  // @@protoc_insertion_point(field_set:mmorpg.NPCState.is_quest_giver)
}
inline bool NPCState::_internal_is_quest_giver() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_quest_giver_;
}
inline void NPCState::_internal_set_is_quest_giver(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_quest_giver_ = value;
}

// bool is_vendor = 14;
inline void NPCState::clear_is_vendor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_vendor_ = false;
}
inline bool NPCState::is_vendor() const {
  // @@protoc_insertion_point(field_get:mmorpg.NPCState.is_vendor)
  return _internal_is_vendor();
}
inline void NPCState::set_is_vendor(bool value) {
  _internal_set_is_vendor(value);
  // @@protoc_insertion_point(field_set:mmorpg.NPCState.is_vendor)
}
inline bool NPCState::_internal_is_vendor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_vendor_;
}
inline void NPCState::_internal_set_is_vendor(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_vendor_ = value;
}

// string current_animation = 15;
inline void NPCState::clear_current_animation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.current_animation_.ClearToEmpty();
}
inline const std::string& NPCState::current_animation() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.NPCState.current_animation)
  return _internal_current_animation();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NPCState::set_current_animation(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.current_animation_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.NPCState.current_animation)
}
inline std::string* NPCState::mutable_current_animation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_current_animation();
  // @@protoc_insertion_point(field_mutable:mmorpg.NPCState.current_animation)
  return _s;
}
inline const std::string& NPCState::_internal_current_animation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.current_animation_.Get();
}
inline void NPCState::_internal_set_current_animation(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.current_animation_.Set(value, GetArena());
}
inline std::string* NPCState::_internal_mutable_current_animation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.current_animation_.Mutable( GetArena());
}
inline std::string* NPCState::release_current_animation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.NPCState.current_animation)
  return _impl_.current_animation_.Release();
}
inline void NPCState::set_allocated_current_animation(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.current_animation_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.current_animation_.IsDefault()) {
          _impl_.current_animation_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.NPCState.current_animation)
}

// float animation_time = 16;
inline void NPCState::clear_animation_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.animation_time_ = 0;
}
inline float NPCState::animation_time() const {
  // @@protoc_insertion_point(field_get:mmorpg.NPCState.animation_time)
  return _internal_animation_time();
}
inline void NPCState::set_animation_time(float value) {
  _internal_set_animation_time(value);
  // @@protoc_insertion_point(field_set:mmorpg.NPCState.animation_time)
}
inline float NPCState::_internal_animation_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.animation_time_;
}
inline void NPCState::_internal_set_animation_time(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.animation_time_ = value;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// WorldObject

// string object_id = 1;
inline void WorldObject::clear_object_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.object_id_.ClearToEmpty();
}
inline const std::string& WorldObject::object_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.WorldObject.object_id)
  return _internal_object_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorldObject::set_object_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.object_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.WorldObject.object_id)
}
inline std::string* WorldObject::mutable_object_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_object_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.WorldObject.object_id)
  return _s;
}
inline const std::string& WorldObject::_internal_object_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.object_id_.Get();
}
inline void WorldObject::_internal_set_object_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.object_id_.Set(value, GetArena());
}
inline std::string* WorldObject::_internal_mutable_object_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.object_id_.Mutable( GetArena());
}
inline std::string* WorldObject::release_object_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.WorldObject.object_id)
  return _impl_.object_id_.Release();
}
inline void WorldObject::set_allocated_object_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.object_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.object_id_.IsDefault()) {
          _impl_.object_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.WorldObject.object_id)
}

// string object_type = 2;
inline void WorldObject::clear_object_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.object_type_.ClearToEmpty();
}
inline const std::string& WorldObject::object_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.WorldObject.object_type)
  return _internal_object_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorldObject::set_object_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.object_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.WorldObject.object_type)
}
inline std::string* WorldObject::mutable_object_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_object_type();
  // @@protoc_insertion_point(field_mutable:mmorpg.WorldObject.object_type)
  return _s;
}
inline const std::string& WorldObject::_internal_object_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.object_type_.Get();
}
inline void WorldObject::_internal_set_object_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.object_type_.Set(value, GetArena());
}
inline std::string* WorldObject::_internal_mutable_object_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.object_type_.Mutable( GetArena());
}
inline std::string* WorldObject::release_object_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.WorldObject.object_type)
  return _impl_.object_type_.Release();
}
inline void WorldObject::set_allocated_object_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.object_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.object_type_.IsDefault()) {
          _impl_.object_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.WorldObject.object_type)
}

// .mmorpg.Transform transform = 3;
inline bool WorldObject::has_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transform_ != nullptr);
  return value;
}
inline const ::mmorpg::Transform& WorldObject::_internal_transform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::mmorpg::Transform* p = _impl_.transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::mmorpg::Transform&>(::mmorpg::_Transform_default_instance_);
}
inline const ::mmorpg::Transform& WorldObject::transform() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.WorldObject.transform)
  return _internal_transform();
}
inline void WorldObject::unsafe_arena_set_allocated_transform(::mmorpg::Transform* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transform_);
  }
  _impl_.transform_ = reinterpret_cast<::mmorpg::Transform*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.WorldObject.transform)
}
inline ::mmorpg::Transform* WorldObject::release_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Transform* released = _impl_.transform_;
  _impl_.transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::mmorpg::Transform* WorldObject::unsafe_arena_release_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.WorldObject.transform)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Transform* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
  return temp;
}
inline ::mmorpg::Transform* WorldObject::_internal_mutable_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::mmorpg::Transform>(GetArena());
    _impl_.transform_ = reinterpret_cast<::mmorpg::Transform*>(p);
  }
  return _impl_.transform_;
}
inline ::mmorpg::Transform* WorldObject::mutable_transform() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::Transform* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:mmorpg.WorldObject.transform)
  return _msg;
}
inline void WorldObject::set_allocated_transform(::mmorpg::Transform* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.transform_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.transform_ = reinterpret_cast<::mmorpg::Transform*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.WorldObject.transform)
}

// bool is_interactable = 4;
inline void WorldObject::clear_is_interactable() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_interactable_ = false;
}
inline bool WorldObject::is_interactable() const {
  // @@protoc_insertion_point(field_get:mmorpg.WorldObject.is_interactable)
  return _internal_is_interactable();
}
inline void WorldObject::set_is_interactable(bool value) {
  _internal_set_is_interactable(value);
  // @@protoc_insertion_point(field_set:mmorpg.WorldObject.is_interactable)
}
inline bool WorldObject::_internal_is_interactable() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_interactable_;
}
inline void WorldObject::_internal_set_is_interactable(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_interactable_ = value;
}

// string interaction_type = 5;
inline void WorldObject::clear_interaction_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interaction_type_.ClearToEmpty();
}
inline const std::string& WorldObject::interaction_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.WorldObject.interaction_type)
  return _internal_interaction_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WorldObject::set_interaction_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.interaction_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.WorldObject.interaction_type)
}
inline std::string* WorldObject::mutable_interaction_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_interaction_type();
  // @@protoc_insertion_point(field_mutable:mmorpg.WorldObject.interaction_type)
  return _s;
}
inline const std::string& WorldObject::_internal_interaction_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interaction_type_.Get();
}
inline void WorldObject::_internal_set_interaction_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.interaction_type_.Set(value, GetArena());
}
inline std::string* WorldObject::_internal_mutable_interaction_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.interaction_type_.Mutable( GetArena());
}
inline std::string* WorldObject::release_interaction_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.WorldObject.interaction_type)
  return _impl_.interaction_type_.Release();
}
inline void WorldObject::set_allocated_interaction_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interaction_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.interaction_type_.IsDefault()) {
          _impl_.interaction_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.WorldObject.interaction_type)
}

// float interaction_range = 6;
inline void WorldObject::clear_interaction_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interaction_range_ = 0;
}
inline float WorldObject::interaction_range() const {
  // @@protoc_insertion_point(field_get:mmorpg.WorldObject.interaction_range)
  return _internal_interaction_range();
}
inline void WorldObject::set_interaction_range(float value) {
  _internal_set_interaction_range(value);
  // @@protoc_insertion_point(field_set:mmorpg.WorldObject.interaction_range)
}
inline float WorldObject::_internal_interaction_range() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interaction_range_;
}
inline void WorldObject::_internal_set_interaction_range(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.interaction_range_ = value;
}

// map<string, string> properties = 7;
inline int WorldObject::_internal_properties_size() const {
  return _internal_properties().size();
}
inline int WorldObject::properties_size() const {
  return _internal_properties_size();
}
inline void WorldObject::clear_properties() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.properties_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& WorldObject::_internal_properties() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.properties_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& WorldObject::properties() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:mmorpg.WorldObject.properties)
  return _internal_properties();
}
inline ::google::protobuf::Map<std::string, std::string>* WorldObject::_internal_mutable_properties() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.properties_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* WorldObject::mutable_properties() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:mmorpg.WorldObject.properties)
  return _internal_mutable_properties();
}

// bool is_lootable = 8;
inline void WorldObject::clear_is_lootable() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_lootable_ = false;
}
inline bool WorldObject::is_lootable() const {
  // @@protoc_insertion_point(field_get:mmorpg.WorldObject.is_lootable)
  return _internal_is_lootable();
}
inline void WorldObject::set_is_lootable(bool value) {
  _internal_set_is_lootable(value);
  // @@protoc_insertion_point(field_set:mmorpg.WorldObject.is_lootable)
}
inline bool WorldObject::_internal_is_lootable() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_lootable_;
}
inline void WorldObject::_internal_set_is_lootable(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_lootable_ = value;
}

// repeated string allowed_looters = 9;
inline int WorldObject::_internal_allowed_looters_size() const {
  return _internal_allowed_looters().size();
}
inline int WorldObject::allowed_looters_size() const {
  return _internal_allowed_looters_size();
}
inline void WorldObject::clear_allowed_looters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.allowed_looters_.Clear();
}
inline std::string* WorldObject::add_allowed_looters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_allowed_looters()->Add();
  // @@protoc_insertion_point(field_add_mutable:mmorpg.WorldObject.allowed_looters)
  return _s;
}
inline const std::string& WorldObject::allowed_looters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.WorldObject.allowed_looters)
  return _internal_allowed_looters().Get(index);
}
inline std::string* WorldObject::mutable_allowed_looters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.WorldObject.allowed_looters)
  return _internal_mutable_allowed_looters()->Mutable(index);
}
inline void WorldObject::set_allowed_looters(int index, const std::string& value) {
  _internal_mutable_allowed_looters()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:mmorpg.WorldObject.allowed_looters)
}
inline void WorldObject::set_allowed_looters(int index, std::string&& value) {
  _internal_mutable_allowed_looters()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:mmorpg.WorldObject.allowed_looters)
}
inline void WorldObject::set_allowed_looters(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_allowed_looters()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mmorpg.WorldObject.allowed_looters)
}
inline void WorldObject::set_allowed_looters(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_allowed_looters()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mmorpg.WorldObject.allowed_looters)
}
inline void WorldObject::set_allowed_looters(int index, absl::string_view value) {
  _internal_mutable_allowed_looters()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:mmorpg.WorldObject.allowed_looters)
}
inline void WorldObject::add_allowed_looters(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_allowed_looters()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:mmorpg.WorldObject.allowed_looters)
}
inline void WorldObject::add_allowed_looters(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_allowed_looters()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:mmorpg.WorldObject.allowed_looters)
}
inline void WorldObject::add_allowed_looters(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_allowed_looters()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mmorpg.WorldObject.allowed_looters)
}
inline void WorldObject::add_allowed_looters(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_allowed_looters()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mmorpg.WorldObject.allowed_looters)
}
inline void WorldObject::add_allowed_looters(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_allowed_looters()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:mmorpg.WorldObject.allowed_looters)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
WorldObject::allowed_looters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.WorldObject.allowed_looters)
  return _internal_allowed_looters();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
WorldObject::mutable_allowed_looters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.WorldObject.allowed_looters)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_allowed_looters();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
WorldObject::_internal_allowed_looters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.allowed_looters_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
WorldObject::_internal_mutable_allowed_looters() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.allowed_looters_;
}

// -------------------------------------------------------------------

// EntitySpawn

// .mmorpg.PlayerState player = 1;
inline bool EntitySpawn::has_player() const {
  return entity_case() == kPlayer;
}
inline bool EntitySpawn::_internal_has_player() const {
  return entity_case() == kPlayer;
}
inline void EntitySpawn::set_has_player() {
  _impl_._oneof_case_[0] = kPlayer;
}
inline void EntitySpawn::clear_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (entity_case() == kPlayer) {
    if (GetArena() == nullptr) {
      delete _impl_.entity_.player_;
    }
    clear_has_entity();
  }
}
inline ::mmorpg::PlayerState* EntitySpawn::release_player() {
  // @@protoc_insertion_point(field_release:mmorpg.EntitySpawn.player)
  if (entity_case() == kPlayer) {
    clear_has_entity();
    auto* temp = _impl_.entity_.player_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.entity_.player_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mmorpg::PlayerState& EntitySpawn::_internal_player() const {
  return entity_case() == kPlayer ? *_impl_.entity_.player_ : reinterpret_cast<::mmorpg::PlayerState&>(::mmorpg::_PlayerState_default_instance_);
}
inline const ::mmorpg::PlayerState& EntitySpawn::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.EntitySpawn.player)
  return _internal_player();
}
inline ::mmorpg::PlayerState* EntitySpawn::unsafe_arena_release_player() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mmorpg.EntitySpawn.player)
  if (entity_case() == kPlayer) {
    clear_has_entity();
    auto* temp = _impl_.entity_.player_;
    _impl_.entity_.player_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntitySpawn::unsafe_arena_set_allocated_player(::mmorpg::PlayerState* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_entity();
  if (value) {
    set_has_player();
    _impl_.entity_.player_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.EntitySpawn.player)
}
inline ::mmorpg::PlayerState* EntitySpawn::_internal_mutable_player() {
  if (entity_case() != kPlayer) {
    clear_entity();
    set_has_player();
    _impl_.entity_.player_ = CreateMaybeMessage<::mmorpg::PlayerState>(GetArena());
  }
  return _impl_.entity_.player_;
}
inline ::mmorpg::PlayerState* EntitySpawn::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::PlayerState* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:mmorpg.EntitySpawn.player)
  return _msg;
}

// .mmorpg.NPCState npc = 2;
inline bool EntitySpawn::has_npc() const {
  return entity_case() == kNpc;
}
inline bool EntitySpawn::_internal_has_npc() const {
  return entity_case() == kNpc;
}
inline void EntitySpawn::set_has_npc() {
  _impl_._oneof_case_[0] = kNpc;
}
inline void EntitySpawn::clear_npc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (entity_case() == kNpc) {
    if (GetArena() == nullptr) {
      delete _impl_.entity_.npc_;
    }
    clear_has_entity();
  }
}
inline ::mmorpg::NPCState* EntitySpawn::release_npc() {
  // @@protoc_insertion_point(field_release:mmorpg.EntitySpawn.npc)
  if (entity_case() == kNpc) {
    clear_has_entity();
    auto* temp = _impl_.entity_.npc_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.entity_.npc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mmorpg::NPCState& EntitySpawn::_internal_npc() const {
  return entity_case() == kNpc ? *_impl_.entity_.npc_ : reinterpret_cast<::mmorpg::NPCState&>(::mmorpg::_NPCState_default_instance_);
}
inline const ::mmorpg::NPCState& EntitySpawn::npc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.EntitySpawn.npc)
  return _internal_npc();
}
inline ::mmorpg::NPCState* EntitySpawn::unsafe_arena_release_npc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mmorpg.EntitySpawn.npc)
  if (entity_case() == kNpc) {
    clear_has_entity();
    auto* temp = _impl_.entity_.npc_;
    _impl_.entity_.npc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntitySpawn::unsafe_arena_set_allocated_npc(::mmorpg::NPCState* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_entity();
  if (value) {
    set_has_npc();
    _impl_.entity_.npc_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.EntitySpawn.npc)
}
inline ::mmorpg::NPCState* EntitySpawn::_internal_mutable_npc() {
  if (entity_case() != kNpc) {
    clear_entity();
    set_has_npc();
    _impl_.entity_.npc_ = CreateMaybeMessage<::mmorpg::NPCState>(GetArena());
  }
  return _impl_.entity_.npc_;
}
inline ::mmorpg::NPCState* EntitySpawn::mutable_npc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::NPCState* _msg = _internal_mutable_npc();
  // @@protoc_insertion_point(field_mutable:mmorpg.EntitySpawn.npc)
  return _msg;
}

// .mmorpg.WorldObject object = 3;
inline bool EntitySpawn::has_object() const {
  return entity_case() == kObject;
}
inline bool EntitySpawn::_internal_has_object() const {
  return entity_case() == kObject;
}
inline void EntitySpawn::set_has_object() {
  _impl_._oneof_case_[0] = kObject;
}
inline void EntitySpawn::clear_object() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (entity_case() == kObject) {
    if (GetArena() == nullptr) {
      delete _impl_.entity_.object_;
    }
    clear_has_entity();
  }
}
inline ::mmorpg::WorldObject* EntitySpawn::release_object() {
  // @@protoc_insertion_point(field_release:mmorpg.EntitySpawn.object)
  if (entity_case() == kObject) {
    clear_has_entity();
    auto* temp = _impl_.entity_.object_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.entity_.object_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mmorpg::WorldObject& EntitySpawn::_internal_object() const {
  return entity_case() == kObject ? *_impl_.entity_.object_ : reinterpret_cast<::mmorpg::WorldObject&>(::mmorpg::_WorldObject_default_instance_);
}
inline const ::mmorpg::WorldObject& EntitySpawn::object() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.EntitySpawn.object)
  return _internal_object();
}
inline ::mmorpg::WorldObject* EntitySpawn::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mmorpg.EntitySpawn.object)
  if (entity_case() == kObject) {
    clear_has_entity();
    auto* temp = _impl_.entity_.object_;
    _impl_.entity_.object_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntitySpawn::unsafe_arena_set_allocated_object(::mmorpg::WorldObject* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_entity();
  if (value) {
    set_has_object();
    _impl_.entity_.object_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.EntitySpawn.object)
}
inline ::mmorpg::WorldObject* EntitySpawn::_internal_mutable_object() {
  if (entity_case() != kObject) {
    clear_entity();
    set_has_object();
    _impl_.entity_.object_ = CreateMaybeMessage<::mmorpg::WorldObject>(GetArena());
  }
  return _impl_.entity_.object_;
}
inline ::mmorpg::WorldObject* EntitySpawn::mutable_object() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::WorldObject* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:mmorpg.EntitySpawn.object)
  return _msg;
}

inline bool EntitySpawn::has_entity() const {
  return entity_case() != ENTITY_NOT_SET;
}
inline void EntitySpawn::clear_has_entity() {
  _impl_._oneof_case_[0] = ENTITY_NOT_SET;
}
inline EntitySpawn::EntityCase EntitySpawn::entity_case() const {
  return EntitySpawn::EntityCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// EntityDespawn

// string entity_id = 1;
inline void EntityDespawn::clear_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entity_id_.ClearToEmpty();
}
inline const std::string& EntityDespawn::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.EntityDespawn.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EntityDespawn::set_entity_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.EntityDespawn.entity_id)
}
inline std::string* EntityDespawn::mutable_entity_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.EntityDespawn.entity_id)
  return _s;
}
inline const std::string& EntityDespawn::_internal_entity_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.entity_id_.Get();
}
inline void EntityDespawn::_internal_set_entity_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.entity_id_.Set(value, GetArena());
}
inline std::string* EntityDespawn::_internal_mutable_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.entity_id_.Mutable( GetArena());
}
inline std::string* EntityDespawn::release_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.EntityDespawn.entity_id)
  return _impl_.entity_id_.Release();
}
inline void EntityDespawn::set_allocated_entity_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entity_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.entity_id_.IsDefault()) {
          _impl_.entity_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.EntityDespawn.entity_id)
}

// .mmorpg.EntityType entity_type = 2;
inline void EntityDespawn::clear_entity_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entity_type_ = 0;
}
inline ::mmorpg::EntityType EntityDespawn::entity_type() const {
  // @@protoc_insertion_point(field_get:mmorpg.EntityDespawn.entity_type)
  return _internal_entity_type();
}
inline void EntityDespawn::set_entity_type(::mmorpg::EntityType value) {
  _internal_set_entity_type(value);
  // @@protoc_insertion_point(field_set:mmorpg.EntityDespawn.entity_type)
}
inline ::mmorpg::EntityType EntityDespawn::_internal_entity_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::EntityType>(_impl_.entity_type_);
}
inline void EntityDespawn::_internal_set_entity_type(::mmorpg::EntityType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.entity_type_ = value;
}

// string reason = 3;
inline void EntityDespawn::clear_reason() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reason_.ClearToEmpty();
}
inline const std::string& EntityDespawn::reason() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.EntityDespawn.reason)
  return _internal_reason();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EntityDespawn::set_reason(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reason_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.EntityDespawn.reason)
}
inline std::string* EntityDespawn::mutable_reason() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:mmorpg.EntityDespawn.reason)
  return _s;
}
inline const std::string& EntityDespawn::_internal_reason() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reason_.Get();
}
inline void EntityDespawn::_internal_set_reason(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reason_.Set(value, GetArena());
}
inline std::string* EntityDespawn::_internal_mutable_reason() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.reason_.Mutable( GetArena());
}
inline std::string* EntityDespawn::release_reason() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.EntityDespawn.reason)
  return _impl_.reason_.Release();
}
inline void EntityDespawn::set_allocated_reason(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reason_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.reason_.IsDefault()) {
          _impl_.reason_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.EntityDespawn.reason)
}

// -------------------------------------------------------------------

// EntityEvent

// string entity_id = 1;
inline void EntityEvent::clear_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entity_id_.ClearToEmpty();
}
inline const std::string& EntityEvent::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.EntityEvent.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EntityEvent::set_entity_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.EntityEvent.entity_id)
}
inline std::string* EntityEvent::mutable_entity_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.EntityEvent.entity_id)
  return _s;
}
inline const std::string& EntityEvent::_internal_entity_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.entity_id_.Get();
}
inline void EntityEvent::_internal_set_entity_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.entity_id_.Set(value, GetArena());
}
inline std::string* EntityEvent::_internal_mutable_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.entity_id_.Mutable( GetArena());
}
inline std::string* EntityEvent::release_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.EntityEvent.entity_id)
  return _impl_.entity_id_.Release();
}
inline void EntityEvent::set_allocated_entity_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entity_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.entity_id_.IsDefault()) {
          _impl_.entity_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.EntityEvent.entity_id)
}

// string event_type = 2;
inline void EntityEvent::clear_event_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.event_type_.ClearToEmpty();
}
inline const std::string& EntityEvent::event_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.EntityEvent.event_type)
  return _internal_event_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EntityEvent::set_event_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.event_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.EntityEvent.event_type)
}
inline std::string* EntityEvent::mutable_event_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_event_type();
  // @@protoc_insertion_point(field_mutable:mmorpg.EntityEvent.event_type)
  return _s;
}
inline const std::string& EntityEvent::_internal_event_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.event_type_.Get();
}
inline void EntityEvent::_internal_set_event_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.event_type_.Set(value, GetArena());
}
inline std::string* EntityEvent::_internal_mutable_event_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.event_type_.Mutable( GetArena());
}
inline std::string* EntityEvent::release_event_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.EntityEvent.event_type)
  return _impl_.event_type_.Release();
}
inline void EntityEvent::set_allocated_event_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.event_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.event_type_.IsDefault()) {
          _impl_.event_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.EntityEvent.event_type)
}

// .google.protobuf.Timestamp timestamp = 3;
inline bool EntityEvent::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& EntityEvent::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& EntityEvent::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.EntityEvent.timestamp)
  return _internal_timestamp();
}
inline void EntityEvent::unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.EntityEvent.timestamp)
}
inline ::google::protobuf::Timestamp* EntityEvent::release_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* EntityEvent::unsafe_arena_release_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.EntityEvent.timestamp)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* EntityEvent::_internal_mutable_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::google::protobuf::Timestamp* EntityEvent::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:mmorpg.EntityEvent.timestamp)
  return _msg;
}
inline void EntityEvent::set_allocated_timestamp(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.EntityEvent.timestamp)
}

// .mmorpg.DamageEvent damage = 4;
inline bool EntityEvent::has_damage() const {
  return event_data_case() == kDamage;
}
inline bool EntityEvent::_internal_has_damage() const {
  return event_data_case() == kDamage;
}
inline void EntityEvent::set_has_damage() {
  _impl_._oneof_case_[0] = kDamage;
}
inline void EntityEvent::clear_damage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (event_data_case() == kDamage) {
    if (GetArena() == nullptr) {
      delete _impl_.event_data_.damage_;
    }
    clear_has_event_data();
  }
}
inline ::mmorpg::DamageEvent* EntityEvent::release_damage() {
  // @@protoc_insertion_point(field_release:mmorpg.EntityEvent.damage)
  if (event_data_case() == kDamage) {
    clear_has_event_data();
    auto* temp = _impl_.event_data_.damage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.damage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mmorpg::DamageEvent& EntityEvent::_internal_damage() const {
  return event_data_case() == kDamage ? *_impl_.event_data_.damage_ : reinterpret_cast<::mmorpg::DamageEvent&>(::mmorpg::_DamageEvent_default_instance_);
}
inline const ::mmorpg::DamageEvent& EntityEvent::damage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.EntityEvent.damage)
  return _internal_damage();
}
inline ::mmorpg::DamageEvent* EntityEvent::unsafe_arena_release_damage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mmorpg.EntityEvent.damage)
  if (event_data_case() == kDamage) {
    clear_has_event_data();
    auto* temp = _impl_.event_data_.damage_;
    _impl_.event_data_.damage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityEvent::unsafe_arena_set_allocated_damage(::mmorpg::DamageEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event_data();
  if (value) {
    set_has_damage();
    _impl_.event_data_.damage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.EntityEvent.damage)
}
inline ::mmorpg::DamageEvent* EntityEvent::_internal_mutable_damage() {
  if (event_data_case() != kDamage) {
    clear_event_data();
    set_has_damage();
    _impl_.event_data_.damage_ = CreateMaybeMessage<::mmorpg::DamageEvent>(GetArena());
  }
  return _impl_.event_data_.damage_;
}
inline ::mmorpg::DamageEvent* EntityEvent::mutable_damage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::DamageEvent* _msg = _internal_mutable_damage();
  // @@protoc_insertion_point(field_mutable:mmorpg.EntityEvent.damage)
  return _msg;
}

// .mmorpg.HealEvent heal = 5;
inline bool EntityEvent::has_heal() const {
  return event_data_case() == kHeal;
}
inline bool EntityEvent::_internal_has_heal() const {
  return event_data_case() == kHeal;
}
inline void EntityEvent::set_has_heal() {
  _impl_._oneof_case_[0] = kHeal;
}
inline void EntityEvent::clear_heal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (event_data_case() == kHeal) {
    if (GetArena() == nullptr) {
      delete _impl_.event_data_.heal_;
    }
    clear_has_event_data();
  }
}
inline ::mmorpg::HealEvent* EntityEvent::release_heal() {
  // @@protoc_insertion_point(field_release:mmorpg.EntityEvent.heal)
  if (event_data_case() == kHeal) {
    clear_has_event_data();
    auto* temp = _impl_.event_data_.heal_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.heal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mmorpg::HealEvent& EntityEvent::_internal_heal() const {
  return event_data_case() == kHeal ? *_impl_.event_data_.heal_ : reinterpret_cast<::mmorpg::HealEvent&>(::mmorpg::_HealEvent_default_instance_);
}
inline const ::mmorpg::HealEvent& EntityEvent::heal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.EntityEvent.heal)
  return _internal_heal();
}
inline ::mmorpg::HealEvent* EntityEvent::unsafe_arena_release_heal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mmorpg.EntityEvent.heal)
  if (event_data_case() == kHeal) {
    clear_has_event_data();
    auto* temp = _impl_.event_data_.heal_;
    _impl_.event_data_.heal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityEvent::unsafe_arena_set_allocated_heal(::mmorpg::HealEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event_data();
  if (value) {
    set_has_heal();
    _impl_.event_data_.heal_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.EntityEvent.heal)
}
inline ::mmorpg::HealEvent* EntityEvent::_internal_mutable_heal() {
  if (event_data_case() != kHeal) {
    clear_event_data();
    set_has_heal();
    _impl_.event_data_.heal_ = CreateMaybeMessage<::mmorpg::HealEvent>(GetArena());
  }
  return _impl_.event_data_.heal_;
}
inline ::mmorpg::HealEvent* EntityEvent::mutable_heal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::HealEvent* _msg = _internal_mutable_heal();
  // @@protoc_insertion_point(field_mutable:mmorpg.EntityEvent.heal)
  return _msg;
}

// .mmorpg.DeathEvent death = 6;
inline bool EntityEvent::has_death() const {
  return event_data_case() == kDeath;
}
inline bool EntityEvent::_internal_has_death() const {
  return event_data_case() == kDeath;
}
inline void EntityEvent::set_has_death() {
  _impl_._oneof_case_[0] = kDeath;
}
inline void EntityEvent::clear_death() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (event_data_case() == kDeath) {
    if (GetArena() == nullptr) {
      delete _impl_.event_data_.death_;
    }
    clear_has_event_data();
  }
}
inline ::mmorpg::DeathEvent* EntityEvent::release_death() {
  // @@protoc_insertion_point(field_release:mmorpg.EntityEvent.death)
  if (event_data_case() == kDeath) {
    clear_has_event_data();
    auto* temp = _impl_.event_data_.death_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.death_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mmorpg::DeathEvent& EntityEvent::_internal_death() const {
  return event_data_case() == kDeath ? *_impl_.event_data_.death_ : reinterpret_cast<::mmorpg::DeathEvent&>(::mmorpg::_DeathEvent_default_instance_);
}
inline const ::mmorpg::DeathEvent& EntityEvent::death() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.EntityEvent.death)
  return _internal_death();
}
inline ::mmorpg::DeathEvent* EntityEvent::unsafe_arena_release_death() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mmorpg.EntityEvent.death)
  if (event_data_case() == kDeath) {
    clear_has_event_data();
    auto* temp = _impl_.event_data_.death_;
    _impl_.event_data_.death_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityEvent::unsafe_arena_set_allocated_death(::mmorpg::DeathEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event_data();
  if (value) {
    set_has_death();
    _impl_.event_data_.death_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.EntityEvent.death)
}
inline ::mmorpg::DeathEvent* EntityEvent::_internal_mutable_death() {
  if (event_data_case() != kDeath) {
    clear_event_data();
    set_has_death();
    _impl_.event_data_.death_ = CreateMaybeMessage<::mmorpg::DeathEvent>(GetArena());
  }
  return _impl_.event_data_.death_;
}
inline ::mmorpg::DeathEvent* EntityEvent::mutable_death() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::DeathEvent* _msg = _internal_mutable_death();
  // @@protoc_insertion_point(field_mutable:mmorpg.EntityEvent.death)
  return _msg;
}

// .mmorpg.LevelUpEvent level_up = 7;
inline bool EntityEvent::has_level_up() const {
  return event_data_case() == kLevelUp;
}
inline bool EntityEvent::_internal_has_level_up() const {
  return event_data_case() == kLevelUp;
}
inline void EntityEvent::set_has_level_up() {
  _impl_._oneof_case_[0] = kLevelUp;
}
inline void EntityEvent::clear_level_up() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (event_data_case() == kLevelUp) {
    if (GetArena() == nullptr) {
      delete _impl_.event_data_.level_up_;
    }
    clear_has_event_data();
  }
}
inline ::mmorpg::LevelUpEvent* EntityEvent::release_level_up() {
  // @@protoc_insertion_point(field_release:mmorpg.EntityEvent.level_up)
  if (event_data_case() == kLevelUp) {
    clear_has_event_data();
    auto* temp = _impl_.event_data_.level_up_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.level_up_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mmorpg::LevelUpEvent& EntityEvent::_internal_level_up() const {
  return event_data_case() == kLevelUp ? *_impl_.event_data_.level_up_ : reinterpret_cast<::mmorpg::LevelUpEvent&>(::mmorpg::_LevelUpEvent_default_instance_);
}
inline const ::mmorpg::LevelUpEvent& EntityEvent::level_up() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.EntityEvent.level_up)
  return _internal_level_up();
}
inline ::mmorpg::LevelUpEvent* EntityEvent::unsafe_arena_release_level_up() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mmorpg.EntityEvent.level_up)
  if (event_data_case() == kLevelUp) {
    clear_has_event_data();
    auto* temp = _impl_.event_data_.level_up_;
    _impl_.event_data_.level_up_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityEvent::unsafe_arena_set_allocated_level_up(::mmorpg::LevelUpEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event_data();
  if (value) {
    set_has_level_up();
    _impl_.event_data_.level_up_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.EntityEvent.level_up)
}
inline ::mmorpg::LevelUpEvent* EntityEvent::_internal_mutable_level_up() {
  if (event_data_case() != kLevelUp) {
    clear_event_data();
    set_has_level_up();
    _impl_.event_data_.level_up_ = CreateMaybeMessage<::mmorpg::LevelUpEvent>(GetArena());
  }
  return _impl_.event_data_.level_up_;
}
inline ::mmorpg::LevelUpEvent* EntityEvent::mutable_level_up() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::LevelUpEvent* _msg = _internal_mutable_level_up();
  // @@protoc_insertion_point(field_mutable:mmorpg.EntityEvent.level_up)
  return _msg;
}

// .mmorpg.EmoteEvent emote = 8;
inline bool EntityEvent::has_emote() const {
  return event_data_case() == kEmote;
}
inline bool EntityEvent::_internal_has_emote() const {
  return event_data_case() == kEmote;
}
inline void EntityEvent::set_has_emote() {
  _impl_._oneof_case_[0] = kEmote;
}
inline void EntityEvent::clear_emote() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (event_data_case() == kEmote) {
    if (GetArena() == nullptr) {
      delete _impl_.event_data_.emote_;
    }
    clear_has_event_data();
  }
}
inline ::mmorpg::EmoteEvent* EntityEvent::release_emote() {
  // @@protoc_insertion_point(field_release:mmorpg.EntityEvent.emote)
  if (event_data_case() == kEmote) {
    clear_has_event_data();
    auto* temp = _impl_.event_data_.emote_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.emote_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mmorpg::EmoteEvent& EntityEvent::_internal_emote() const {
  return event_data_case() == kEmote ? *_impl_.event_data_.emote_ : reinterpret_cast<::mmorpg::EmoteEvent&>(::mmorpg::_EmoteEvent_default_instance_);
}
inline const ::mmorpg::EmoteEvent& EntityEvent::emote() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.EntityEvent.emote)
  return _internal_emote();
}
inline ::mmorpg::EmoteEvent* EntityEvent::unsafe_arena_release_emote() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mmorpg.EntityEvent.emote)
  if (event_data_case() == kEmote) {
    clear_has_event_data();
    auto* temp = _impl_.event_data_.emote_;
    _impl_.event_data_.emote_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityEvent::unsafe_arena_set_allocated_emote(::mmorpg::EmoteEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event_data();
  if (value) {
    set_has_emote();
    _impl_.event_data_.emote_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.EntityEvent.emote)
}
inline ::mmorpg::EmoteEvent* EntityEvent::_internal_mutable_emote() {
  if (event_data_case() != kEmote) {
    clear_event_data();
    set_has_emote();
    _impl_.event_data_.emote_ = CreateMaybeMessage<::mmorpg::EmoteEvent>(GetArena());
  }
  return _impl_.event_data_.emote_;
}
inline ::mmorpg::EmoteEvent* EntityEvent::mutable_emote() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::EmoteEvent* _msg = _internal_mutable_emote();
  // @@protoc_insertion_point(field_mutable:mmorpg.EntityEvent.emote)
  return _msg;
}

// .mmorpg.SoundEvent sound = 9;
inline bool EntityEvent::has_sound() const {
  return event_data_case() == kSound;
}
inline bool EntityEvent::_internal_has_sound() const {
  return event_data_case() == kSound;
}
inline void EntityEvent::set_has_sound() {
  _impl_._oneof_case_[0] = kSound;
}
inline void EntityEvent::clear_sound() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (event_data_case() == kSound) {
    if (GetArena() == nullptr) {
      delete _impl_.event_data_.sound_;
    }
    clear_has_event_data();
  }
}
inline ::mmorpg::SoundEvent* EntityEvent::release_sound() {
  // @@protoc_insertion_point(field_release:mmorpg.EntityEvent.sound)
  if (event_data_case() == kSound) {
    clear_has_event_data();
    auto* temp = _impl_.event_data_.sound_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.sound_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mmorpg::SoundEvent& EntityEvent::_internal_sound() const {
  return event_data_case() == kSound ? *_impl_.event_data_.sound_ : reinterpret_cast<::mmorpg::SoundEvent&>(::mmorpg::_SoundEvent_default_instance_);
}
inline const ::mmorpg::SoundEvent& EntityEvent::sound() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.EntityEvent.sound)
  return _internal_sound();
}
inline ::mmorpg::SoundEvent* EntityEvent::unsafe_arena_release_sound() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mmorpg.EntityEvent.sound)
  if (event_data_case() == kSound) {
    clear_has_event_data();
    auto* temp = _impl_.event_data_.sound_;
    _impl_.event_data_.sound_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityEvent::unsafe_arena_set_allocated_sound(::mmorpg::SoundEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event_data();
  if (value) {
    set_has_sound();
    _impl_.event_data_.sound_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.EntityEvent.sound)
}
inline ::mmorpg::SoundEvent* EntityEvent::_internal_mutable_sound() {
  if (event_data_case() != kSound) {
    clear_event_data();
    set_has_sound();
    _impl_.event_data_.sound_ = CreateMaybeMessage<::mmorpg::SoundEvent>(GetArena());
  }
  return _impl_.event_data_.sound_;
}
inline ::mmorpg::SoundEvent* EntityEvent::mutable_sound() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::SoundEvent* _msg = _internal_mutable_sound();
  // @@protoc_insertion_point(field_mutable:mmorpg.EntityEvent.sound)
  return _msg;
}

// .mmorpg.VisualEffectEvent visual_effect = 10;
inline bool EntityEvent::has_visual_effect() const {
  return event_data_case() == kVisualEffect;
}
inline bool EntityEvent::_internal_has_visual_effect() const {
  return event_data_case() == kVisualEffect;
}
inline void EntityEvent::set_has_visual_effect() {
  _impl_._oneof_case_[0] = kVisualEffect;
}
inline void EntityEvent::clear_visual_effect() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (event_data_case() == kVisualEffect) {
    if (GetArena() == nullptr) {
      delete _impl_.event_data_.visual_effect_;
    }
    clear_has_event_data();
  }
}
inline ::mmorpg::VisualEffectEvent* EntityEvent::release_visual_effect() {
  // @@protoc_insertion_point(field_release:mmorpg.EntityEvent.visual_effect)
  if (event_data_case() == kVisualEffect) {
    clear_has_event_data();
    auto* temp = _impl_.event_data_.visual_effect_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_data_.visual_effect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::mmorpg::VisualEffectEvent& EntityEvent::_internal_visual_effect() const {
  return event_data_case() == kVisualEffect ? *_impl_.event_data_.visual_effect_ : reinterpret_cast<::mmorpg::VisualEffectEvent&>(::mmorpg::_VisualEffectEvent_default_instance_);
}
inline const ::mmorpg::VisualEffectEvent& EntityEvent::visual_effect() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.EntityEvent.visual_effect)
  return _internal_visual_effect();
}
inline ::mmorpg::VisualEffectEvent* EntityEvent::unsafe_arena_release_visual_effect() {
  // @@protoc_insertion_point(field_unsafe_arena_release:mmorpg.EntityEvent.visual_effect)
  if (event_data_case() == kVisualEffect) {
    clear_has_event_data();
    auto* temp = _impl_.event_data_.visual_effect_;
    _impl_.event_data_.visual_effect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EntityEvent::unsafe_arena_set_allocated_visual_effect(::mmorpg::VisualEffectEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event_data();
  if (value) {
    set_has_visual_effect();
    _impl_.event_data_.visual_effect_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.EntityEvent.visual_effect)
}
inline ::mmorpg::VisualEffectEvent* EntityEvent::_internal_mutable_visual_effect() {
  if (event_data_case() != kVisualEffect) {
    clear_event_data();
    set_has_visual_effect();
    _impl_.event_data_.visual_effect_ = CreateMaybeMessage<::mmorpg::VisualEffectEvent>(GetArena());
  }
  return _impl_.event_data_.visual_effect_;
}
inline ::mmorpg::VisualEffectEvent* EntityEvent::mutable_visual_effect() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::VisualEffectEvent* _msg = _internal_mutable_visual_effect();
  // @@protoc_insertion_point(field_mutable:mmorpg.EntityEvent.visual_effect)
  return _msg;
}

inline bool EntityEvent::has_event_data() const {
  return event_data_case() != EVENT_DATA_NOT_SET;
}
inline void EntityEvent::clear_has_event_data() {
  _impl_._oneof_case_[0] = EVENT_DATA_NOT_SET;
}
inline EntityEvent::EventDataCase EntityEvent::event_data_case() const {
  return EntityEvent::EventDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DamageEvent

// string source_id = 1;
inline void DamageEvent::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_id_.ClearToEmpty();
}
inline const std::string& DamageEvent::source_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.DamageEvent.source_id)
  return _internal_source_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DamageEvent::set_source_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.DamageEvent.source_id)
}
inline std::string* DamageEvent::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.DamageEvent.source_id)
  return _s;
}
inline const std::string& DamageEvent::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_id_.Get();
}
inline void DamageEvent::_internal_set_source_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_id_.Set(value, GetArena());
}
inline std::string* DamageEvent::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.source_id_.Mutable( GetArena());
}
inline std::string* DamageEvent::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.DamageEvent.source_id)
  return _impl_.source_id_.Release();
}
inline void DamageEvent::set_allocated_source_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_id_.IsDefault()) {
          _impl_.source_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.DamageEvent.source_id)
}

// string target_id = 2;
inline void DamageEvent::clear_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_id_.ClearToEmpty();
}
inline const std::string& DamageEvent::target_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.DamageEvent.target_id)
  return _internal_target_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DamageEvent::set_target_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.DamageEvent.target_id)
}
inline std::string* DamageEvent::mutable_target_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.DamageEvent.target_id)
  return _s;
}
inline const std::string& DamageEvent::_internal_target_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_id_.Get();
}
inline void DamageEvent::_internal_set_target_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_id_.Set(value, GetArena());
}
inline std::string* DamageEvent::_internal_mutable_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.target_id_.Mutable( GetArena());
}
inline std::string* DamageEvent::release_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.DamageEvent.target_id)
  return _impl_.target_id_.Release();
}
inline void DamageEvent::set_allocated_target_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_id_.IsDefault()) {
          _impl_.target_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.DamageEvent.target_id)
}

// int32 damage = 3;
inline void DamageEvent::clear_damage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.damage_ = 0;
}
inline ::int32_t DamageEvent::damage() const {
  // @@protoc_insertion_point(field_get:mmorpg.DamageEvent.damage)
  return _internal_damage();
}
inline void DamageEvent::set_damage(::int32_t value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:mmorpg.DamageEvent.damage)
}
inline ::int32_t DamageEvent::_internal_damage() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.damage_;
}
inline void DamageEvent::_internal_set_damage(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.damage_ = value;
}

// .mmorpg.DamageType damage_type = 4;
inline void DamageEvent::clear_damage_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.damage_type_ = 0;
}
inline ::mmorpg::DamageType DamageEvent::damage_type() const {
  // @@protoc_insertion_point(field_get:mmorpg.DamageEvent.damage_type)
  return _internal_damage_type();
}
inline void DamageEvent::set_damage_type(::mmorpg::DamageType value) {
  _internal_set_damage_type(value);
  // @@protoc_insertion_point(field_set:mmorpg.DamageEvent.damage_type)
}
inline ::mmorpg::DamageType DamageEvent::_internal_damage_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::DamageType>(_impl_.damage_type_);
}
inline void DamageEvent::_internal_set_damage_type(::mmorpg::DamageType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.damage_type_ = value;
}

// bool is_critical = 5;
inline void DamageEvent::clear_is_critical() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_critical_ = false;
}
inline bool DamageEvent::is_critical() const {
  // @@protoc_insertion_point(field_get:mmorpg.DamageEvent.is_critical)
  return _internal_is_critical();
}
inline void DamageEvent::set_is_critical(bool value) {
  _internal_set_is_critical(value);
  // @@protoc_insertion_point(field_set:mmorpg.DamageEvent.is_critical)
}
inline bool DamageEvent::_internal_is_critical() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_critical_;
}
inline void DamageEvent::_internal_set_is_critical(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_critical_ = value;
}

// bool is_blocked = 6;
inline void DamageEvent::clear_is_blocked() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_blocked_ = false;
}
inline bool DamageEvent::is_blocked() const {
  // @@protoc_insertion_point(field_get:mmorpg.DamageEvent.is_blocked)
  return _internal_is_blocked();
}
inline void DamageEvent::set_is_blocked(bool value) {
  _internal_set_is_blocked(value);
  // @@protoc_insertion_point(field_set:mmorpg.DamageEvent.is_blocked)
}
inline bool DamageEvent::_internal_is_blocked() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_blocked_;
}
inline void DamageEvent::_internal_set_is_blocked(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_blocked_ = value;
}

// bool is_dodged = 7;
inline void DamageEvent::clear_is_dodged() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_dodged_ = false;
}
inline bool DamageEvent::is_dodged() const {
  // @@protoc_insertion_point(field_get:mmorpg.DamageEvent.is_dodged)
  return _internal_is_dodged();
}
inline void DamageEvent::set_is_dodged(bool value) {
  _internal_set_is_dodged(value);
  // @@protoc_insertion_point(field_set:mmorpg.DamageEvent.is_dodged)
}
inline bool DamageEvent::_internal_is_dodged() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_dodged_;
}
inline void DamageEvent::_internal_set_is_dodged(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_dodged_ = value;
}

// -------------------------------------------------------------------

// HealEvent

// string source_id = 1;
inline void HealEvent::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_id_.ClearToEmpty();
}
inline const std::string& HealEvent::source_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.HealEvent.source_id)
  return _internal_source_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HealEvent::set_source_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.HealEvent.source_id)
}
inline std::string* HealEvent::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.HealEvent.source_id)
  return _s;
}
inline const std::string& HealEvent::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_id_.Get();
}
inline void HealEvent::_internal_set_source_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_id_.Set(value, GetArena());
}
inline std::string* HealEvent::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.source_id_.Mutable( GetArena());
}
inline std::string* HealEvent::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.HealEvent.source_id)
  return _impl_.source_id_.Release();
}
inline void HealEvent::set_allocated_source_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_id_.IsDefault()) {
          _impl_.source_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.HealEvent.source_id)
}

// string target_id = 2;
inline void HealEvent::clear_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_id_.ClearToEmpty();
}
inline const std::string& HealEvent::target_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.HealEvent.target_id)
  return _internal_target_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HealEvent::set_target_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.HealEvent.target_id)
}
inline std::string* HealEvent::mutable_target_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.HealEvent.target_id)
  return _s;
}
inline const std::string& HealEvent::_internal_target_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_id_.Get();
}
inline void HealEvent::_internal_set_target_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_id_.Set(value, GetArena());
}
inline std::string* HealEvent::_internal_mutable_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.target_id_.Mutable( GetArena());
}
inline std::string* HealEvent::release_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.HealEvent.target_id)
  return _impl_.target_id_.Release();
}
inline void HealEvent::set_allocated_target_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_id_.IsDefault()) {
          _impl_.target_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.HealEvent.target_id)
}

// int32 heal_amount = 3;
inline void HealEvent::clear_heal_amount() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heal_amount_ = 0;
}
inline ::int32_t HealEvent::heal_amount() const {
  // @@protoc_insertion_point(field_get:mmorpg.HealEvent.heal_amount)
  return _internal_heal_amount();
}
inline void HealEvent::set_heal_amount(::int32_t value) {
  _internal_set_heal_amount(value);
  // @@protoc_insertion_point(field_set:mmorpg.HealEvent.heal_amount)
}
inline ::int32_t HealEvent::_internal_heal_amount() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heal_amount_;
}
inline void HealEvent::_internal_set_heal_amount(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.heal_amount_ = value;
}

// string heal_type = 4;
inline void HealEvent::clear_heal_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heal_type_.ClearToEmpty();
}
inline const std::string& HealEvent::heal_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.HealEvent.heal_type)
  return _internal_heal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HealEvent::set_heal_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.heal_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.HealEvent.heal_type)
}
inline std::string* HealEvent::mutable_heal_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_heal_type();
  // @@protoc_insertion_point(field_mutable:mmorpg.HealEvent.heal_type)
  return _s;
}
inline const std::string& HealEvent::_internal_heal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heal_type_.Get();
}
inline void HealEvent::_internal_set_heal_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.heal_type_.Set(value, GetArena());
}
inline std::string* HealEvent::_internal_mutable_heal_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.heal_type_.Mutable( GetArena());
}
inline std::string* HealEvent::release_heal_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.HealEvent.heal_type)
  return _impl_.heal_type_.Release();
}
inline void HealEvent::set_allocated_heal_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heal_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.heal_type_.IsDefault()) {
          _impl_.heal_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.HealEvent.heal_type)
}

// bool is_critical = 5;
inline void HealEvent::clear_is_critical() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_critical_ = false;
}
inline bool HealEvent::is_critical() const {
  // @@protoc_insertion_point(field_get:mmorpg.HealEvent.is_critical)
  return _internal_is_critical();
}
inline void HealEvent::set_is_critical(bool value) {
  _internal_set_is_critical(value);
  // @@protoc_insertion_point(field_set:mmorpg.HealEvent.is_critical)
}
inline bool HealEvent::_internal_is_critical() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_critical_;
}
inline void HealEvent::_internal_set_is_critical(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_critical_ = value;
}

// -------------------------------------------------------------------

// DeathEvent

// string entity_id = 1;
inline void DeathEvent::clear_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entity_id_.ClearToEmpty();
}
inline const std::string& DeathEvent::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.DeathEvent.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeathEvent::set_entity_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.DeathEvent.entity_id)
}
inline std::string* DeathEvent::mutable_entity_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.DeathEvent.entity_id)
  return _s;
}
inline const std::string& DeathEvent::_internal_entity_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.entity_id_.Get();
}
inline void DeathEvent::_internal_set_entity_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.entity_id_.Set(value, GetArena());
}
inline std::string* DeathEvent::_internal_mutable_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.entity_id_.Mutable( GetArena());
}
inline std::string* DeathEvent::release_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.DeathEvent.entity_id)
  return _impl_.entity_id_.Release();
}
inline void DeathEvent::set_allocated_entity_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entity_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.entity_id_.IsDefault()) {
          _impl_.entity_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.DeathEvent.entity_id)
}

// string killer_id = 2;
inline void DeathEvent::clear_killer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.killer_id_.ClearToEmpty();
}
inline const std::string& DeathEvent::killer_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.DeathEvent.killer_id)
  return _internal_killer_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeathEvent::set_killer_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.killer_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.DeathEvent.killer_id)
}
inline std::string* DeathEvent::mutable_killer_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_killer_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.DeathEvent.killer_id)
  return _s;
}
inline const std::string& DeathEvent::_internal_killer_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.killer_id_.Get();
}
inline void DeathEvent::_internal_set_killer_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.killer_id_.Set(value, GetArena());
}
inline std::string* DeathEvent::_internal_mutable_killer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.killer_id_.Mutable( GetArena());
}
inline std::string* DeathEvent::release_killer_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.DeathEvent.killer_id)
  return _impl_.killer_id_.Release();
}
inline void DeathEvent::set_allocated_killer_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.killer_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.killer_id_.IsDefault()) {
          _impl_.killer_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.DeathEvent.killer_id)
}

// string death_type = 3;
inline void DeathEvent::clear_death_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.death_type_.ClearToEmpty();
}
inline const std::string& DeathEvent::death_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.DeathEvent.death_type)
  return _internal_death_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeathEvent::set_death_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.death_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.DeathEvent.death_type)
}
inline std::string* DeathEvent::mutable_death_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_death_type();
  // @@protoc_insertion_point(field_mutable:mmorpg.DeathEvent.death_type)
  return _s;
}
inline const std::string& DeathEvent::_internal_death_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.death_type_.Get();
}
inline void DeathEvent::_internal_set_death_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.death_type_.Set(value, GetArena());
}
inline std::string* DeathEvent::_internal_mutable_death_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.death_type_.Mutable( GetArena());
}
inline std::string* DeathEvent::release_death_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.DeathEvent.death_type)
  return _impl_.death_type_.Release();
}
inline void DeathEvent::set_allocated_death_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.death_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.death_type_.IsDefault()) {
          _impl_.death_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.DeathEvent.death_type)
}

// .mmorpg.Transform death_location = 4;
inline bool DeathEvent::has_death_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.death_location_ != nullptr);
  return value;
}
inline const ::mmorpg::Transform& DeathEvent::_internal_death_location() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::mmorpg::Transform* p = _impl_.death_location_;
  return p != nullptr ? *p : reinterpret_cast<const ::mmorpg::Transform&>(::mmorpg::_Transform_default_instance_);
}
inline const ::mmorpg::Transform& DeathEvent::death_location() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.DeathEvent.death_location)
  return _internal_death_location();
}
inline void DeathEvent::unsafe_arena_set_allocated_death_location(::mmorpg::Transform* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.death_location_);
  }
  _impl_.death_location_ = reinterpret_cast<::mmorpg::Transform*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.DeathEvent.death_location)
}
inline ::mmorpg::Transform* DeathEvent::release_death_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Transform* released = _impl_.death_location_;
  _impl_.death_location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::mmorpg::Transform* DeathEvent::unsafe_arena_release_death_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.DeathEvent.death_location)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Transform* temp = _impl_.death_location_;
  _impl_.death_location_ = nullptr;
  return temp;
}
inline ::mmorpg::Transform* DeathEvent::_internal_mutable_death_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.death_location_ == nullptr) {
    auto* p = CreateMaybeMessage<::mmorpg::Transform>(GetArena());
    _impl_.death_location_ = reinterpret_cast<::mmorpg::Transform*>(p);
  }
  return _impl_.death_location_;
}
inline ::mmorpg::Transform* DeathEvent::mutable_death_location() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::Transform* _msg = _internal_mutable_death_location();
  // @@protoc_insertion_point(field_mutable:mmorpg.DeathEvent.death_location)
  return _msg;
}
inline void DeathEvent::set_allocated_death_location(::mmorpg::Transform* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.death_location_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.death_location_ = reinterpret_cast<::mmorpg::Transform*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.DeathEvent.death_location)
}

// -------------------------------------------------------------------

// LevelUpEvent

// string player_id = 1;
inline void LevelUpEvent::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& LevelUpEvent::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.LevelUpEvent.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LevelUpEvent::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.LevelUpEvent.player_id)
}
inline std::string* LevelUpEvent::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.LevelUpEvent.player_id)
  return _s;
}
inline const std::string& LevelUpEvent::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void LevelUpEvent::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* LevelUpEvent::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* LevelUpEvent::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.LevelUpEvent.player_id)
  return _impl_.player_id_.Release();
}
inline void LevelUpEvent::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.LevelUpEvent.player_id)
}

// int32 new_level = 2;
inline void LevelUpEvent::clear_new_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.new_level_ = 0;
}
inline ::int32_t LevelUpEvent::new_level() const {
  // @@protoc_insertion_point(field_get:mmorpg.LevelUpEvent.new_level)
  return _internal_new_level();
}
inline void LevelUpEvent::set_new_level(::int32_t value) {
  _internal_set_new_level(value);
  // @@protoc_insertion_point(field_set:mmorpg.LevelUpEvent.new_level)
}
inline ::int32_t LevelUpEvent::_internal_new_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.new_level_;
}
inline void LevelUpEvent::_internal_set_new_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.new_level_ = value;
}

// int32 stat_points_gained = 3;
inline void LevelUpEvent::clear_stat_points_gained() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stat_points_gained_ = 0;
}
inline ::int32_t LevelUpEvent::stat_points_gained() const {
  // @@protoc_insertion_point(field_get:mmorpg.LevelUpEvent.stat_points_gained)
  return _internal_stat_points_gained();
}
inline void LevelUpEvent::set_stat_points_gained(::int32_t value) {
  _internal_set_stat_points_gained(value);
  // @@protoc_insertion_point(field_set:mmorpg.LevelUpEvent.stat_points_gained)
}
inline ::int32_t LevelUpEvent::_internal_stat_points_gained() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stat_points_gained_;
}
inline void LevelUpEvent::_internal_set_stat_points_gained(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.stat_points_gained_ = value;
}

// int32 skill_points_gained = 4;
inline void LevelUpEvent::clear_skill_points_gained() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skill_points_gained_ = 0;
}
inline ::int32_t LevelUpEvent::skill_points_gained() const {
  // @@protoc_insertion_point(field_get:mmorpg.LevelUpEvent.skill_points_gained)
  return _internal_skill_points_gained();
}
inline void LevelUpEvent::set_skill_points_gained(::int32_t value) {
  _internal_set_skill_points_gained(value);
  // @@protoc_insertion_point(field_set:mmorpg.LevelUpEvent.skill_points_gained)
}
inline ::int32_t LevelUpEvent::_internal_skill_points_gained() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skill_points_gained_;
}
inline void LevelUpEvent::_internal_set_skill_points_gained(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.skill_points_gained_ = value;
}

// -------------------------------------------------------------------

// EmoteEvent

// string entity_id = 1;
inline void EmoteEvent::clear_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entity_id_.ClearToEmpty();
}
inline const std::string& EmoteEvent::entity_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.EmoteEvent.entity_id)
  return _internal_entity_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EmoteEvent::set_entity_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.entity_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.EmoteEvent.entity_id)
}
inline std::string* EmoteEvent::mutable_entity_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_entity_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.EmoteEvent.entity_id)
  return _s;
}
inline const std::string& EmoteEvent::_internal_entity_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.entity_id_.Get();
}
inline void EmoteEvent::_internal_set_entity_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.entity_id_.Set(value, GetArena());
}
inline std::string* EmoteEvent::_internal_mutable_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.entity_id_.Mutable( GetArena());
}
inline std::string* EmoteEvent::release_entity_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.EmoteEvent.entity_id)
  return _impl_.entity_id_.Release();
}
inline void EmoteEvent::set_allocated_entity_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.entity_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.entity_id_.IsDefault()) {
          _impl_.entity_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.EmoteEvent.entity_id)
}

// string emote_id = 2;
inline void EmoteEvent::clear_emote_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.emote_id_.ClearToEmpty();
}
inline const std::string& EmoteEvent::emote_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.EmoteEvent.emote_id)
  return _internal_emote_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EmoteEvent::set_emote_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.emote_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.EmoteEvent.emote_id)
}
inline std::string* EmoteEvent::mutable_emote_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_emote_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.EmoteEvent.emote_id)
  return _s;
}
inline const std::string& EmoteEvent::_internal_emote_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.emote_id_.Get();
}
inline void EmoteEvent::_internal_set_emote_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.emote_id_.Set(value, GetArena());
}
inline std::string* EmoteEvent::_internal_mutable_emote_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.emote_id_.Mutable( GetArena());
}
inline std::string* EmoteEvent::release_emote_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.EmoteEvent.emote_id)
  return _impl_.emote_id_.Release();
}
inline void EmoteEvent::set_allocated_emote_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.emote_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.emote_id_.IsDefault()) {
          _impl_.emote_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.EmoteEvent.emote_id)
}

// string target_id = 3;
inline void EmoteEvent::clear_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_id_.ClearToEmpty();
}
inline const std::string& EmoteEvent::target_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.EmoteEvent.target_id)
  return _internal_target_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EmoteEvent::set_target_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.EmoteEvent.target_id)
}
inline std::string* EmoteEvent::mutable_target_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.EmoteEvent.target_id)
  return _s;
}
inline const std::string& EmoteEvent::_internal_target_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_id_.Get();
}
inline void EmoteEvent::_internal_set_target_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_id_.Set(value, GetArena());
}
inline std::string* EmoteEvent::_internal_mutable_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.target_id_.Mutable( GetArena());
}
inline std::string* EmoteEvent::release_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.EmoteEvent.target_id)
  return _impl_.target_id_.Release();
}
inline void EmoteEvent::set_allocated_target_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_id_.IsDefault()) {
          _impl_.target_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.EmoteEvent.target_id)
}

// -------------------------------------------------------------------

// SoundEvent

// string sound_id = 1;
inline void SoundEvent::clear_sound_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sound_id_.ClearToEmpty();
}
inline const std::string& SoundEvent::sound_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.SoundEvent.sound_id)
  return _internal_sound_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SoundEvent::set_sound_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sound_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.SoundEvent.sound_id)
}
inline std::string* SoundEvent::mutable_sound_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sound_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.SoundEvent.sound_id)
  return _s;
}
inline const std::string& SoundEvent::_internal_sound_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sound_id_.Get();
}
inline void SoundEvent::_internal_set_sound_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sound_id_.Set(value, GetArena());
}
inline std::string* SoundEvent::_internal_mutable_sound_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.sound_id_.Mutable( GetArena());
}
inline std::string* SoundEvent::release_sound_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.SoundEvent.sound_id)
  return _impl_.sound_id_.Release();
}
inline void SoundEvent::set_allocated_sound_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sound_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sound_id_.IsDefault()) {
          _impl_.sound_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.SoundEvent.sound_id)
}

// .mmorpg.Transform location = 2;
inline bool SoundEvent::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.location_ != nullptr);
  return value;
}
inline const ::mmorpg::Transform& SoundEvent::_internal_location() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::mmorpg::Transform* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::mmorpg::Transform&>(::mmorpg::_Transform_default_instance_);
}
inline const ::mmorpg::Transform& SoundEvent::location() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.SoundEvent.location)
  return _internal_location();
}
inline void SoundEvent::unsafe_arena_set_allocated_location(::mmorpg::Transform* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = reinterpret_cast<::mmorpg::Transform*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.SoundEvent.location)
}
inline ::mmorpg::Transform* SoundEvent::release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Transform* released = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::mmorpg::Transform* SoundEvent::unsafe_arena_release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.SoundEvent.location)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Transform* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::mmorpg::Transform* SoundEvent::_internal_mutable_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::mmorpg::Transform>(GetArena());
    _impl_.location_ = reinterpret_cast<::mmorpg::Transform*>(p);
  }
  return _impl_.location_;
}
inline ::mmorpg::Transform* SoundEvent::mutable_location() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::Transform* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:mmorpg.SoundEvent.location)
  return _msg;
}
inline void SoundEvent::set_allocated_location(::mmorpg::Transform* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.location_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.location_ = reinterpret_cast<::mmorpg::Transform*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.SoundEvent.location)
}

// float volume = 3;
inline void SoundEvent::clear_volume() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.volume_ = 0;
}
inline float SoundEvent::volume() const {
  // @@protoc_insertion_point(field_get:mmorpg.SoundEvent.volume)
  return _internal_volume();
}
inline void SoundEvent::set_volume(float value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:mmorpg.SoundEvent.volume)
}
inline float SoundEvent::_internal_volume() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.volume_;
}
inline void SoundEvent::_internal_set_volume(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.volume_ = value;
}

// float range = 4;
inline void SoundEvent::clear_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.range_ = 0;
}
inline float SoundEvent::range() const {
  // @@protoc_insertion_point(field_get:mmorpg.SoundEvent.range)
  return _internal_range();
}
inline void SoundEvent::set_range(float value) {
  _internal_set_range(value);
  // @@protoc_insertion_point(field_set:mmorpg.SoundEvent.range)
}
inline float SoundEvent::_internal_range() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.range_;
}
inline void SoundEvent::_internal_set_range(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.range_ = value;
}

// -------------------------------------------------------------------

// VisualEffectEvent

// string effect_id = 1;
inline void VisualEffectEvent::clear_effect_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effect_id_.ClearToEmpty();
}
inline const std::string& VisualEffectEvent::effect_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.VisualEffectEvent.effect_id)
  return _internal_effect_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VisualEffectEvent::set_effect_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.effect_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.VisualEffectEvent.effect_id)
}
inline std::string* VisualEffectEvent::mutable_effect_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_effect_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.VisualEffectEvent.effect_id)
  return _s;
}
inline const std::string& VisualEffectEvent::_internal_effect_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effect_id_.Get();
}
inline void VisualEffectEvent::_internal_set_effect_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.effect_id_.Set(value, GetArena());
}
inline std::string* VisualEffectEvent::_internal_mutable_effect_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.effect_id_.Mutable( GetArena());
}
inline std::string* VisualEffectEvent::release_effect_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.VisualEffectEvent.effect_id)
  return _impl_.effect_id_.Release();
}
inline void VisualEffectEvent::set_allocated_effect_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effect_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.effect_id_.IsDefault()) {
          _impl_.effect_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.VisualEffectEvent.effect_id)
}

// .mmorpg.Transform location = 2;
inline bool VisualEffectEvent::has_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.location_ != nullptr);
  return value;
}
inline const ::mmorpg::Transform& VisualEffectEvent::_internal_location() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::mmorpg::Transform* p = _impl_.location_;
  return p != nullptr ? *p : reinterpret_cast<const ::mmorpg::Transform&>(::mmorpg::_Transform_default_instance_);
}
inline const ::mmorpg::Transform& VisualEffectEvent::location() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.VisualEffectEvent.location)
  return _internal_location();
}
inline void VisualEffectEvent::unsafe_arena_set_allocated_location(::mmorpg::Transform* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.location_);
  }
  _impl_.location_ = reinterpret_cast<::mmorpg::Transform*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.VisualEffectEvent.location)
}
inline ::mmorpg::Transform* VisualEffectEvent::release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Transform* released = _impl_.location_;
  _impl_.location_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::mmorpg::Transform* VisualEffectEvent::unsafe_arena_release_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.VisualEffectEvent.location)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Transform* temp = _impl_.location_;
  _impl_.location_ = nullptr;
  return temp;
}
inline ::mmorpg::Transform* VisualEffectEvent::_internal_mutable_location() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.location_ == nullptr) {
    auto* p = CreateMaybeMessage<::mmorpg::Transform>(GetArena());
    _impl_.location_ = reinterpret_cast<::mmorpg::Transform*>(p);
  }
  return _impl_.location_;
}
inline ::mmorpg::Transform* VisualEffectEvent::mutable_location() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::Transform* _msg = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:mmorpg.VisualEffectEvent.location)
  return _msg;
}
inline void VisualEffectEvent::set_allocated_location(::mmorpg::Transform* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.location_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.location_ = reinterpret_cast<::mmorpg::Transform*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.VisualEffectEvent.location)
}

// float duration = 3;
inline void VisualEffectEvent::clear_duration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.duration_ = 0;
}
inline float VisualEffectEvent::duration() const {
  // @@protoc_insertion_point(field_get:mmorpg.VisualEffectEvent.duration)
  return _internal_duration();
}
inline void VisualEffectEvent::set_duration(float value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:mmorpg.VisualEffectEvent.duration)
}
inline float VisualEffectEvent::_internal_duration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.duration_;
}
inline void VisualEffectEvent::_internal_set_duration(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.duration_ = value;
}

// float scale = 4;
inline void VisualEffectEvent::clear_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scale_ = 0;
}
inline float VisualEffectEvent::scale() const {
  // @@protoc_insertion_point(field_get:mmorpg.VisualEffectEvent.scale)
  return _internal_scale();
}
inline void VisualEffectEvent::set_scale(float value) {
  _internal_set_scale(value);
  // @@protoc_insertion_point(field_set:mmorpg.VisualEffectEvent.scale)
}
inline float VisualEffectEvent::_internal_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.scale_;
}
inline void VisualEffectEvent::_internal_set_scale(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.scale_ = value;
}

// string attach_to_entity = 5;
inline void VisualEffectEvent::clear_attach_to_entity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.attach_to_entity_.ClearToEmpty();
}
inline const std::string& VisualEffectEvent::attach_to_entity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.VisualEffectEvent.attach_to_entity)
  return _internal_attach_to_entity();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VisualEffectEvent::set_attach_to_entity(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.attach_to_entity_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.VisualEffectEvent.attach_to_entity)
}
inline std::string* VisualEffectEvent::mutable_attach_to_entity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_attach_to_entity();
  // @@protoc_insertion_point(field_mutable:mmorpg.VisualEffectEvent.attach_to_entity)
  return _s;
}
inline const std::string& VisualEffectEvent::_internal_attach_to_entity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attach_to_entity_.Get();
}
inline void VisualEffectEvent::_internal_set_attach_to_entity(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.attach_to_entity_.Set(value, GetArena());
}
inline std::string* VisualEffectEvent::_internal_mutable_attach_to_entity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.attach_to_entity_.Mutable( GetArena());
}
inline std::string* VisualEffectEvent::release_attach_to_entity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.VisualEffectEvent.attach_to_entity)
  return _impl_.attach_to_entity_.Release();
}
inline void VisualEffectEvent::set_allocated_attach_to_entity(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.attach_to_entity_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.attach_to_entity_.IsDefault()) {
          _impl_.attach_to_entity_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.VisualEffectEvent.attach_to_entity)
}

// -------------------------------------------------------------------

// StatusEffect

// string effect_id = 1;
inline void StatusEffect::clear_effect_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effect_id_.ClearToEmpty();
}
inline const std::string& StatusEffect::effect_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.StatusEffect.effect_id)
  return _internal_effect_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StatusEffect::set_effect_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.effect_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.StatusEffect.effect_id)
}
inline std::string* StatusEffect::mutable_effect_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_effect_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.StatusEffect.effect_id)
  return _s;
}
inline const std::string& StatusEffect::_internal_effect_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effect_id_.Get();
}
inline void StatusEffect::_internal_set_effect_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.effect_id_.Set(value, GetArena());
}
inline std::string* StatusEffect::_internal_mutable_effect_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.effect_id_.Mutable( GetArena());
}
inline std::string* StatusEffect::release_effect_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.StatusEffect.effect_id)
  return _impl_.effect_id_.Release();
}
inline void StatusEffect::set_allocated_effect_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effect_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.effect_id_.IsDefault()) {
          _impl_.effect_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.StatusEffect.effect_id)
}

// string effect_type = 2;
inline void StatusEffect::clear_effect_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effect_type_.ClearToEmpty();
}
inline const std::string& StatusEffect::effect_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.StatusEffect.effect_type)
  return _internal_effect_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StatusEffect::set_effect_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.effect_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.StatusEffect.effect_type)
}
inline std::string* StatusEffect::mutable_effect_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_effect_type();
  // @@protoc_insertion_point(field_mutable:mmorpg.StatusEffect.effect_type)
  return _s;
}
inline const std::string& StatusEffect::_internal_effect_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effect_type_.Get();
}
inline void StatusEffect::_internal_set_effect_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.effect_type_.Set(value, GetArena());
}
inline std::string* StatusEffect::_internal_mutable_effect_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.effect_type_.Mutable( GetArena());
}
inline std::string* StatusEffect::release_effect_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.StatusEffect.effect_type)
  return _impl_.effect_type_.Release();
}
inline void StatusEffect::set_allocated_effect_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effect_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.effect_type_.IsDefault()) {
          _impl_.effect_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.StatusEffect.effect_type)
}

// string icon_id = 3;
inline void StatusEffect::clear_icon_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.icon_id_.ClearToEmpty();
}
inline const std::string& StatusEffect::icon_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.StatusEffect.icon_id)
  return _internal_icon_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StatusEffect::set_icon_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.icon_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.StatusEffect.icon_id)
}
inline std::string* StatusEffect::mutable_icon_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_icon_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.StatusEffect.icon_id)
  return _s;
}
inline const std::string& StatusEffect::_internal_icon_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.icon_id_.Get();
}
inline void StatusEffect::_internal_set_icon_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.icon_id_.Set(value, GetArena());
}
inline std::string* StatusEffect::_internal_mutable_icon_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.icon_id_.Mutable( GetArena());
}
inline std::string* StatusEffect::release_icon_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.StatusEffect.icon_id)
  return _impl_.icon_id_.Release();
}
inline void StatusEffect::set_allocated_icon_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.icon_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.icon_id_.IsDefault()) {
          _impl_.icon_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.StatusEffect.icon_id)
}

// float duration = 4;
inline void StatusEffect::clear_duration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.duration_ = 0;
}
inline float StatusEffect::duration() const {
  // @@protoc_insertion_point(field_get:mmorpg.StatusEffect.duration)
  return _internal_duration();
}
inline void StatusEffect::set_duration(float value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:mmorpg.StatusEffect.duration)
}
inline float StatusEffect::_internal_duration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.duration_;
}
inline void StatusEffect::_internal_set_duration(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.duration_ = value;
}

// int32 stacks = 5;
inline void StatusEffect::clear_stacks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stacks_ = 0;
}
inline ::int32_t StatusEffect::stacks() const {
  // @@protoc_insertion_point(field_get:mmorpg.StatusEffect.stacks)
  return _internal_stacks();
}
inline void StatusEffect::set_stacks(::int32_t value) {
  _internal_set_stacks(value);
  // @@protoc_insertion_point(field_set:mmorpg.StatusEffect.stacks)
}
inline ::int32_t StatusEffect::_internal_stacks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stacks_;
}
inline void StatusEffect::_internal_set_stacks(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.stacks_ = value;
}

// string source_id = 6;
inline void StatusEffect::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_id_.ClearToEmpty();
}
inline const std::string& StatusEffect::source_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.StatusEffect.source_id)
  return _internal_source_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StatusEffect::set_source_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.StatusEffect.source_id)
}
inline std::string* StatusEffect::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.StatusEffect.source_id)
  return _s;
}
inline const std::string& StatusEffect::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_id_.Get();
}
inline void StatusEffect::_internal_set_source_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.source_id_.Set(value, GetArena());
}
inline std::string* StatusEffect::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.source_id_.Mutable( GetArena());
}
inline std::string* StatusEffect::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.StatusEffect.source_id)
  return _impl_.source_id_.Release();
}
inline void StatusEffect::set_allocated_source_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_id_.IsDefault()) {
          _impl_.source_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.StatusEffect.source_id)
}

// -------------------------------------------------------------------

// ZoneChangeRequest

// string player_id = 1;
inline void ZoneChangeRequest::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& ZoneChangeRequest::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ZoneChangeRequest.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ZoneChangeRequest::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ZoneChangeRequest.player_id)
}
inline std::string* ZoneChangeRequest::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ZoneChangeRequest.player_id)
  return _s;
}
inline const std::string& ZoneChangeRequest::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void ZoneChangeRequest::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* ZoneChangeRequest::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* ZoneChangeRequest::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ZoneChangeRequest.player_id)
  return _impl_.player_id_.Release();
}
inline void ZoneChangeRequest::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ZoneChangeRequest.player_id)
}

// string target_zone_id = 2;
inline void ZoneChangeRequest::clear_target_zone_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_zone_id_.ClearToEmpty();
}
inline const std::string& ZoneChangeRequest::target_zone_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ZoneChangeRequest.target_zone_id)
  return _internal_target_zone_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ZoneChangeRequest::set_target_zone_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_zone_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ZoneChangeRequest.target_zone_id)
}
inline std::string* ZoneChangeRequest::mutable_target_zone_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_target_zone_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ZoneChangeRequest.target_zone_id)
  return _s;
}
inline const std::string& ZoneChangeRequest::_internal_target_zone_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_zone_id_.Get();
}
inline void ZoneChangeRequest::_internal_set_target_zone_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_zone_id_.Set(value, GetArena());
}
inline std::string* ZoneChangeRequest::_internal_mutable_target_zone_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.target_zone_id_.Mutable( GetArena());
}
inline std::string* ZoneChangeRequest::release_target_zone_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ZoneChangeRequest.target_zone_id)
  return _impl_.target_zone_id_.Release();
}
inline void ZoneChangeRequest::set_allocated_target_zone_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_zone_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.target_zone_id_.IsDefault()) {
          _impl_.target_zone_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ZoneChangeRequest.target_zone_id)
}

// .mmorpg.Transform target_transform = 3;
inline bool ZoneChangeRequest::has_target_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_transform_ != nullptr);
  return value;
}
inline const ::mmorpg::Transform& ZoneChangeRequest::_internal_target_transform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::mmorpg::Transform* p = _impl_.target_transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::mmorpg::Transform&>(::mmorpg::_Transform_default_instance_);
}
inline const ::mmorpg::Transform& ZoneChangeRequest::target_transform() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ZoneChangeRequest.target_transform)
  return _internal_target_transform();
}
inline void ZoneChangeRequest::unsafe_arena_set_allocated_target_transform(::mmorpg::Transform* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_transform_);
  }
  _impl_.target_transform_ = reinterpret_cast<::mmorpg::Transform*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.ZoneChangeRequest.target_transform)
}
inline ::mmorpg::Transform* ZoneChangeRequest::release_target_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Transform* released = _impl_.target_transform_;
  _impl_.target_transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::mmorpg::Transform* ZoneChangeRequest::unsafe_arena_release_target_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ZoneChangeRequest.target_transform)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Transform* temp = _impl_.target_transform_;
  _impl_.target_transform_ = nullptr;
  return temp;
}
inline ::mmorpg::Transform* ZoneChangeRequest::_internal_mutable_target_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::mmorpg::Transform>(GetArena());
    _impl_.target_transform_ = reinterpret_cast<::mmorpg::Transform*>(p);
  }
  return _impl_.target_transform_;
}
inline ::mmorpg::Transform* ZoneChangeRequest::mutable_target_transform() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::Transform* _msg = _internal_mutable_target_transform();
  // @@protoc_insertion_point(field_mutable:mmorpg.ZoneChangeRequest.target_transform)
  return _msg;
}
inline void ZoneChangeRequest::set_allocated_target_transform(::mmorpg::Transform* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_transform_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.target_transform_ = reinterpret_cast<::mmorpg::Transform*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ZoneChangeRequest.target_transform)
}

// -------------------------------------------------------------------

// ZoneChangeResponse

// bool success = 1;
inline void ZoneChangeResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool ZoneChangeResponse::success() const {
  // @@protoc_insertion_point(field_get:mmorpg.ZoneChangeResponse.success)
  return _internal_success();
}
inline void ZoneChangeResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:mmorpg.ZoneChangeResponse.success)
}
inline bool ZoneChangeResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void ZoneChangeResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string new_zone_id = 2;
inline void ZoneChangeResponse::clear_new_zone_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.new_zone_id_.ClearToEmpty();
}
inline const std::string& ZoneChangeResponse::new_zone_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ZoneChangeResponse.new_zone_id)
  return _internal_new_zone_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ZoneChangeResponse::set_new_zone_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.new_zone_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ZoneChangeResponse.new_zone_id)
}
inline std::string* ZoneChangeResponse::mutable_new_zone_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_new_zone_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.ZoneChangeResponse.new_zone_id)
  return _s;
}
inline const std::string& ZoneChangeResponse::_internal_new_zone_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.new_zone_id_.Get();
}
inline void ZoneChangeResponse::_internal_set_new_zone_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.new_zone_id_.Set(value, GetArena());
}
inline std::string* ZoneChangeResponse::_internal_mutable_new_zone_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.new_zone_id_.Mutable( GetArena());
}
inline std::string* ZoneChangeResponse::release_new_zone_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ZoneChangeResponse.new_zone_id)
  return _impl_.new_zone_id_.Release();
}
inline void ZoneChangeResponse::set_allocated_new_zone_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.new_zone_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.new_zone_id_.IsDefault()) {
          _impl_.new_zone_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ZoneChangeResponse.new_zone_id)
}

// string world_server_url = 3;
inline void ZoneChangeResponse::clear_world_server_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.world_server_url_.ClearToEmpty();
}
inline const std::string& ZoneChangeResponse::world_server_url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ZoneChangeResponse.world_server_url)
  return _internal_world_server_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ZoneChangeResponse::set_world_server_url(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.world_server_url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ZoneChangeResponse.world_server_url)
}
inline std::string* ZoneChangeResponse::mutable_world_server_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_world_server_url();
  // @@protoc_insertion_point(field_mutable:mmorpg.ZoneChangeResponse.world_server_url)
  return _s;
}
inline const std::string& ZoneChangeResponse::_internal_world_server_url() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.world_server_url_.Get();
}
inline void ZoneChangeResponse::_internal_set_world_server_url(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.world_server_url_.Set(value, GetArena());
}
inline std::string* ZoneChangeResponse::_internal_mutable_world_server_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.world_server_url_.Mutable( GetArena());
}
inline std::string* ZoneChangeResponse::release_world_server_url() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ZoneChangeResponse.world_server_url)
  return _impl_.world_server_url_.Release();
}
inline void ZoneChangeResponse::set_allocated_world_server_url(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.world_server_url_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.world_server_url_.IsDefault()) {
          _impl_.world_server_url_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ZoneChangeResponse.world_server_url)
}

// string world_token = 4;
inline void ZoneChangeResponse::clear_world_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.world_token_.ClearToEmpty();
}
inline const std::string& ZoneChangeResponse::world_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ZoneChangeResponse.world_token)
  return _internal_world_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ZoneChangeResponse::set_world_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.world_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ZoneChangeResponse.world_token)
}
inline std::string* ZoneChangeResponse::mutable_world_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_world_token();
  // @@protoc_insertion_point(field_mutable:mmorpg.ZoneChangeResponse.world_token)
  return _s;
}
inline const std::string& ZoneChangeResponse::_internal_world_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.world_token_.Get();
}
inline void ZoneChangeResponse::_internal_set_world_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.world_token_.Set(value, GetArena());
}
inline std::string* ZoneChangeResponse::_internal_mutable_world_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.world_token_.Mutable( GetArena());
}
inline std::string* ZoneChangeResponse::release_world_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ZoneChangeResponse.world_token)
  return _impl_.world_token_.Release();
}
inline void ZoneChangeResponse::set_allocated_world_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.world_token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.world_token_.IsDefault()) {
          _impl_.world_token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ZoneChangeResponse.world_token)
}

// .mmorpg.Transform spawn_transform = 5;
inline bool ZoneChangeResponse::has_spawn_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.spawn_transform_ != nullptr);
  return value;
}
inline const ::mmorpg::Transform& ZoneChangeResponse::_internal_spawn_transform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::mmorpg::Transform* p = _impl_.spawn_transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::mmorpg::Transform&>(::mmorpg::_Transform_default_instance_);
}
inline const ::mmorpg::Transform& ZoneChangeResponse::spawn_transform() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ZoneChangeResponse.spawn_transform)
  return _internal_spawn_transform();
}
inline void ZoneChangeResponse::unsafe_arena_set_allocated_spawn_transform(::mmorpg::Transform* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.spawn_transform_);
  }
  _impl_.spawn_transform_ = reinterpret_cast<::mmorpg::Transform*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:mmorpg.ZoneChangeResponse.spawn_transform)
}
inline ::mmorpg::Transform* ZoneChangeResponse::release_spawn_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Transform* released = _impl_.spawn_transform_;
  _impl_.spawn_transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::mmorpg::Transform* ZoneChangeResponse::unsafe_arena_release_spawn_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ZoneChangeResponse.spawn_transform)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::mmorpg::Transform* temp = _impl_.spawn_transform_;
  _impl_.spawn_transform_ = nullptr;
  return temp;
}
inline ::mmorpg::Transform* ZoneChangeResponse::_internal_mutable_spawn_transform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.spawn_transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::mmorpg::Transform>(GetArena());
    _impl_.spawn_transform_ = reinterpret_cast<::mmorpg::Transform*>(p);
  }
  return _impl_.spawn_transform_;
}
inline ::mmorpg::Transform* ZoneChangeResponse::mutable_spawn_transform() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::mmorpg::Transform* _msg = _internal_mutable_spawn_transform();
  // @@protoc_insertion_point(field_mutable:mmorpg.ZoneChangeResponse.spawn_transform)
  return _msg;
}
inline void ZoneChangeResponse::set_allocated_spawn_transform(::mmorpg::Transform* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.spawn_transform_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.spawn_transform_ = reinterpret_cast<::mmorpg::Transform*>(value);
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ZoneChangeResponse.spawn_transform)
}

// string error_message = 6;
inline void ZoneChangeResponse::clear_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& ZoneChangeResponse::error_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.ZoneChangeResponse.error_message)
  return _internal_error_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ZoneChangeResponse::set_error_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.ZoneChangeResponse.error_message)
}
inline std::string* ZoneChangeResponse::mutable_error_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:mmorpg.ZoneChangeResponse.error_message)
  return _s;
}
inline const std::string& ZoneChangeResponse::_internal_error_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_message_.Get();
}
inline void ZoneChangeResponse::_internal_set_error_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_message_.Set(value, GetArena());
}
inline std::string* ZoneChangeResponse::_internal_mutable_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.error_message_.Mutable( GetArena());
}
inline std::string* ZoneChangeResponse::release_error_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.ZoneChangeResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void ZoneChangeResponse::set_allocated_error_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_message_.IsDefault()) {
          _impl_.error_message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.ZoneChangeResponse.error_message)
}

// .mmorpg.ErrorCode error_code = 7;
inline void ZoneChangeResponse::clear_error_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_code_ = 0;
}
inline ::mmorpg::ErrorCode ZoneChangeResponse::error_code() const {
  // @@protoc_insertion_point(field_get:mmorpg.ZoneChangeResponse.error_code)
  return _internal_error_code();
}
inline void ZoneChangeResponse::set_error_code(::mmorpg::ErrorCode value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:mmorpg.ZoneChangeResponse.error_code)
}
inline ::mmorpg::ErrorCode ZoneChangeResponse::_internal_error_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::mmorpg::ErrorCode>(_impl_.error_code_);
}
inline void ZoneChangeResponse::_internal_set_error_code(::mmorpg::ErrorCode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_code_ = value;
}

// -------------------------------------------------------------------

// InterestUpdateRequest

// string player_id = 1;
inline void InterestUpdateRequest::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& InterestUpdateRequest::player_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.InterestUpdateRequest.player_id)
  return _internal_player_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InterestUpdateRequest::set_player_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:mmorpg.InterestUpdateRequest.player_id)
}
inline std::string* InterestUpdateRequest::mutable_player_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:mmorpg.InterestUpdateRequest.player_id)
  return _s;
}
inline const std::string& InterestUpdateRequest::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_.Get();
}
inline void InterestUpdateRequest::_internal_set_player_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_.Set(value, GetArena());
}
inline std::string* InterestUpdateRequest::_internal_mutable_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.player_id_.Mutable( GetArena());
}
inline std::string* InterestUpdateRequest::release_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:mmorpg.InterestUpdateRequest.player_id)
  return _impl_.player_id_.Release();
}
inline void InterestUpdateRequest::set_allocated_player_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.player_id_.IsDefault()) {
          _impl_.player_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:mmorpg.InterestUpdateRequest.player_id)
}

// float view_distance = 2;
inline void InterestUpdateRequest::clear_view_distance() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.view_distance_ = 0;
}
inline float InterestUpdateRequest::view_distance() const {
  // @@protoc_insertion_point(field_get:mmorpg.InterestUpdateRequest.view_distance)
  return _internal_view_distance();
}
inline void InterestUpdateRequest::set_view_distance(float value) {
  _internal_set_view_distance(value);
  // @@protoc_insertion_point(field_set:mmorpg.InterestUpdateRequest.view_distance)
}
inline float InterestUpdateRequest::_internal_view_distance() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.view_distance_;
}
inline void InterestUpdateRequest::_internal_set_view_distance(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.view_distance_ = value;
}

// repeated string interest_filters = 3;
inline int InterestUpdateRequest::_internal_interest_filters_size() const {
  return _internal_interest_filters().size();
}
inline int InterestUpdateRequest::interest_filters_size() const {
  return _internal_interest_filters_size();
}
inline void InterestUpdateRequest::clear_interest_filters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.interest_filters_.Clear();
}
inline std::string* InterestUpdateRequest::add_interest_filters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_interest_filters()->Add();
  // @@protoc_insertion_point(field_add_mutable:mmorpg.InterestUpdateRequest.interest_filters)
  return _s;
}
inline const std::string& InterestUpdateRequest::interest_filters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:mmorpg.InterestUpdateRequest.interest_filters)
  return _internal_interest_filters().Get(index);
}
inline std::string* InterestUpdateRequest::mutable_interest_filters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:mmorpg.InterestUpdateRequest.interest_filters)
  return _internal_mutable_interest_filters()->Mutable(index);
}
inline void InterestUpdateRequest::set_interest_filters(int index, const std::string& value) {
  _internal_mutable_interest_filters()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:mmorpg.InterestUpdateRequest.interest_filters)
}
inline void InterestUpdateRequest::set_interest_filters(int index, std::string&& value) {
  _internal_mutable_interest_filters()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:mmorpg.InterestUpdateRequest.interest_filters)
}
inline void InterestUpdateRequest::set_interest_filters(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_interest_filters()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mmorpg.InterestUpdateRequest.interest_filters)
}
inline void InterestUpdateRequest::set_interest_filters(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_interest_filters()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mmorpg.InterestUpdateRequest.interest_filters)
}
inline void InterestUpdateRequest::set_interest_filters(int index, absl::string_view value) {
  _internal_mutable_interest_filters()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:mmorpg.InterestUpdateRequest.interest_filters)
}
inline void InterestUpdateRequest::add_interest_filters(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_interest_filters()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:mmorpg.InterestUpdateRequest.interest_filters)
}
inline void InterestUpdateRequest::add_interest_filters(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_interest_filters()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:mmorpg.InterestUpdateRequest.interest_filters)
}
inline void InterestUpdateRequest::add_interest_filters(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_interest_filters()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mmorpg.InterestUpdateRequest.interest_filters)
}
inline void InterestUpdateRequest::add_interest_filters(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_interest_filters()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mmorpg.InterestUpdateRequest.interest_filters)
}
inline void InterestUpdateRequest::add_interest_filters(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_interest_filters()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:mmorpg.InterestUpdateRequest.interest_filters)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
InterestUpdateRequest::interest_filters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:mmorpg.InterestUpdateRequest.interest_filters)
  return _internal_interest_filters();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
InterestUpdateRequest::mutable_interest_filters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:mmorpg.InterestUpdateRequest.interest_filters)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_interest_filters();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
InterestUpdateRequest::_internal_interest_filters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.interest_filters_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
InterestUpdateRequest::_internal_mutable_interest_filters() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.interest_filters_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace mmorpg


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::mmorpg::EntityType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mmorpg::EntityType>() {
  return ::mmorpg::EntityType_descriptor();
}
template <>
struct is_proto_enum<::mmorpg::DamageType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mmorpg::DamageType>() {
  return ::mmorpg::DamageType_descriptor();
}
template <>
struct is_proto_enum<::mmorpg::CombatState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mmorpg::CombatState>() {
  return ::mmorpg::CombatState_descriptor();
}
template <>
struct is_proto_enum<::mmorpg::NPCBehaviorState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mmorpg::NPCBehaviorState>() {
  return ::mmorpg::NPCBehaviorState_descriptor();
}
template <>
struct is_proto_enum<::mmorpg::MovementFlag> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::mmorpg::MovementFlag>() {
  return ::mmorpg::MovementFlag_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_world_2eproto_2epb_2eh
